"Document Title",Authors,"Author Affiliations","Publication Title",Date Added To Xplore,"Publication_Year","Volume","Issue","Start Page","End Page","Abstract","ISSN",ISBNs,"DOI",Funding Information,PDF Link,"Author Keywords","IEEE Terms","INSPEC Controlled Terms","INSPEC Non-Controlled Terms","Mesh_Terms",Article Citation Count,"Reference Count","Copyright Year","License","Online Date",Issue Date,"Meeting Date","Publisher",Document Identifier
"Characterization of the Xen Project Code Review Process: an Experience Report","D. Izquierdo-Cortazar; L. Kurth; J. M. González-Barahona; S. Dueñas; N. Sekitoleko","NA; NA; NA; NA; NA","2016 IEEE/ACM 13th Working Conference on Mining Software Repositories (MSR)","","2016","","","386","390","Many software development projects have introduced mandatory code review for every change to the code. This means that the project needs to devote a significant effort to review all proposed changes, and that their merging into the code base may get considerably delayed. Therefore, all those projects need to understand how code review is working, and the delays it is causing in time to merge. This is the case in the Xen project, which performs peer review using mailing lists. During the first half of 2015, some people in the project observed a large and sustained increase in the number of messages related to code review, which had started some years before. This observation led to concerns on whether the code review process was having some trouble, and too large an impact on the overall development process. Those concerns were addressed with a quantitative study, which is presented in this paper. Based on the information in code review messages, some metrics were defined to infer delays imposed by code review. The study produced quantitative data suitable for informed discussion, which the project is using to understand its code review process, and to take decisions to improve it.","","978-1-4503-4186-8978-1-5090-2242","10.1109/MSR.2016.046","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7832917","data mining;software process;code review","Databases;Software;Market research;Message systems;Data mining;Merging;Delays","software engineering","quantitative data;code review messages;mailing lists;peer review;software development projects;Xen project code review process","","","7","","","","","","IEEE","IEEE Conferences"
"Automated API migration in a user-extensible refactoring tool for Erlang programs","H. Li; S. Thompson","University of Kent, UK; University of Kent, UK","2012 Proceedings of the 27th IEEE/ACM International Conference on Automated Software Engineering","","2012","","","294","297","Wrangler is a refactoring and code inspection tool for Erlang programs. Apart from providing a set of built-in refactorings and code inspection functionalities, Wrangler allows users to define refactorings, code inspections, and general program transformations for themselves to suit their particular needs. These are defined using a template- and rule-based program transformation and analysis framework built into Wrangler. This paper reports an extension to Wrangler's extension framework, supporting the automatic generation of API migration refactorings from a user-defined adapter module.","","978-1-4503-1204-2978-1-4503-1204","10.1145/2351676.2351727","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6494939","API migration;Erlang;Wrangler;refactoring;rewrite rule;software engineering;template","","application program interfaces;knowledge based systems;program diagnostics;programming languages;software maintenance","automated API migration refactoring;user-extensible refactoring tool;Erlang programs;Wrangler;code inspection tool;general program transformations;template-and rule-based program transformation;template-and rule-based program analysis framework;user-defined adapter module","","1","8","","","","","","IEEE","IEEE Conferences"
"Statistical process control to improve coding and code review","A. L. Jacob; S. K. Pillai","NeST, Kerala, India; NeST, Kerala, India","IEEE Software","","2003","20","3","50","55","Software process comprises activities such as estimation, planning, requirements analysis, design, coding, reviews, and testing, undertaken when creating a software product. Effective software process management involves proactively managing each of these activities. Statistical process control tools enable proactive software process management. One such tool, the control chart, can be used for managing, controlling, and improving the code review process.","0740-7459;1937-4194","","10.1109/MS.2003.1196321","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1196321","","Process control;Control charts;Quality assurance;Software performance;Software quality;Software tools;Quality management;Jacobian matrices;Size control;Resource management","software development management;statistical process control;software quality;quality management","process behavior prediction;code review processes;control charts;statistical process control;software development;software process management","","25","12","","","","","","IEEE","IEEE Journals & Magazines"
"Quality Assurance of Peer Code Review Process: A Web-Based MIS","Y. Wang; X. Zhang; L. Yu; H. Huang","NA; NA; NA; NA","2008 International Conference on Computer Science and Software Engineering","","2008","2","","631","634","The software industry and most multinational IT companies are starving for software engineers who can write high quality codes. Universities and colleges, being the most important educational institutions, should of course shoulder the burden to cultivate such qualified software engineers. Many methods have been explored to make this educational task more efficient. Peer code review (PCR) is such a teaching process that can be used to help instructors teach more efficiently. After three years' implementation, the advantage of PCR has been revealed while some major problems have been addressed, e.g. it is unacceptably troublesome to control the whole process manually, and its quality is hard to handle. So a web-based MIS with built-in PCR was developed. The detailed design and implementation of this system is presented. It is believed that the MIS will help teachers assure the quality of the PCR process.","","978-0-7695-3336","10.1109/CSSE.2008.1141","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4722130","peer code review;quality assurance (QA);web-based MIS;cooperative learning;software engineering education","Quality assurance;Education;Software quality;Educational institutions;Computer science;Software engineering;Concrete;Switches;Computer industry;Process control","computer science education;DP industry;Internet;management information systems;software quality","quality assurance;peer code review process;Web-based MIS;software industry;multinational IT companies;software engineers;high quality codes;universities;colleges;educational institutions;teaching process","","1","7","","","","","","IEEE","IEEE Conferences"
"Refactoring-aware code review","X. Ge; S. Sarkar; J. Witschey; E. Murphy-Hill","Apple Inc., USA; Microsoft Corporation, USA; North Carolina State University, USA; North Carolina State University, USA","2017 IEEE Symposium on Visual Languages and Human-Centric Computing (VL/HCC)","","2017","","","71","79","Code review, where developers manually inspect one another's code changes, improves software quality and transfers knowledge in a team. Unfortunately, tools that support code review treat behavior-preserving changes, or refactorings, and behavior-altering changes, or non-refactorings, the same way, so developers have to spend effort differentiating between the two before they can evaluate the impact of a change set. In this paper, we describe a formative study of 35 developers that motivates the need for separating refactorings from non-refactorings during code review. Then, we present a refactoring-aware code review tool, called ReviewFactor, that differentiates between refactoring and non-refactoring, and allows developers to focus on one of them at a time. Finally, a case study of two open source projects suggests that ReviewFactor detects refactorings in 39% of the commits, and identifies 4.6% of the total lines of code change as refactorings. Our results also show that the precision and recall of ReviewFactor's refactoring detection algorithm are 92.5% and 94.2%, respectively.","1943-6106","978-1-5386-0443-4978-1-5386-0444","10.1109/VLHCC.2017.8103453","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8103453","","Tools;Software;Manuals;Solids;Visualization;Detection algorithms;Java","software maintenance;software quality;software reviews","behavior-altering changes;refactoring-aware code review tool;code change;software quality;behavior-preserving changes;refactoring detection algorithm;ReviewFactor","","","42","","","","","","IEEE","IEEE Conferences"
"Refactoring Inspection Support for Manual Refactoring Edits","E. L. G. Alves; M. Song; T. Massoni; P. D. L. Machado; M. Kim","Computer Science Department, Federal University of Campina Grande, Campina Grande, Brazil; Computer Science Department, The University of Nebraska at Omaha, Omaha, NE; Computer Science Department, Universidade Federal de Campina Grande, Campina Grande, PB, Brazil; Systems and Computing Department, Federal University of Campina Grande, Campina Grande, Brazil; Computer Science Department, University of California, Los Angeles, CA","IEEE Transactions on Software Engineering","","2018","44","4","365","383","Refactoring is commonly performed manually, supported by regression testing, which serves as a safety net to provide confidence on the edits performed. However, inadequate test suites may prevent developers from initiating or performing refactorings. We propose RefDistiller, a static analysis approach to support the inspection of manual refactorings. It combines two techniques. First, it applies predefined templates to identify potential missed edits during manual refactoring. Second, it leverages an automated refactoring engine to identify extra edits that might be incorrect. RefDistiller also helps determine the root cause of detected anomalies. In our evaluation, RefDistiller identifies 97 percent of seeded anomalies, of which 24 percent are not detected by generated test suites. Compared to running existing regression test suites, it detects 22 times more anomalies, with 94 percent precision on average. In a study with 15 professional developers, the participants inspected problematic refactorings with RefDistiller versus testing only. With RefDistiller, participants located 90 percent of the seeded anomalies, while they located only 13 percent with testing. The results show RefDistiller can help check the correctness of manual refactorings.","0098-5589;1939-3520;2326-3881","","10.1109/TSE.2017.2679742","National Science Foundation; Google Faculty Award; National Institute of Science and Technology for Software Engineering; CNPq/Brasil; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7874212","Refactoring;refactoring anomalies;code inspection","Manuals;Inspection;Testing;Computer bugs;Transforms;Engines;Detectors","program diagnostics;program testing;regression analysis;software maintenance","RefDistiller;seeded anomalies;refactoring inspection support;manual refactoring edits;regression testing;inadequate test suites;potential missed edits;automated refactoring engine;extra edits;generated test suites;running existing regression test suites;problematic refactorings","","1","49","","","","","","IEEE","IEEE Journals & Magazines"
"ReDA: A Web-Based Visualization Tool for Analyzing Modern Code Review Dataset","P. Thongtanunam; X. Yang; N. Yoshida; R. G. Kula; A. E. C. Cruz; K. Fujiwara; H. Iida","NA; NA; NA; NA; NA; NA; NA","2014 IEEE International Conference on Software Maintenance and Evolution","","2014","","","605","608","ReDA (http://reda.naist.jp/) is a web-based visualization tool for analyzing Modern Code Review (MCR) datasets for large Open Source Software (OSS) projects. MCR is a commonly practiced and lightweight inspection of source code using a support tool such as Gerrit system. Recently, mining code review history of such systems has received attention as a potentially effective method of ensuring software quality. However, due to increasing size and complexity of softwares being developed, these datasets are becoming unmanageable. ReDA aims to assist researchers of mining code review data by enabling better understand of dataset context and identifying abnormalities. Through real-time data interaction, users can quickly gain insight into the data and hone in on interesting areas to investigate. A video highlighting the main features can be found at: http://youtu.be/ fEoTRRas0U.","1063-6773","978-1-4799-6146","10.1109/ICSME.2014.106","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6976150","Modern Code Review;Mining software repository;Visualization tool","Data visualization;Data mining;History;Google;Software quality;Androids","data visualisation;Internet;software quality;software tools;source code (software)","ReDA;Web-based visualization tool;modern code review dataset;MCR datasets;open source software;OSS projects;source code;Gerrit system;mining code review history;software quality;mining code review data;real-time data interaction","","12","13","","","","","","IEEE","IEEE Conferences"
"Code review tool for Visual Programming Languages","G. Ragusa; H. Henriques","FCT/UNL, Almada, Portugal; OutSystems SA, Linda-a-Velha, Portugal","2018 IEEE Symposium on Visual Languages and Human-Centric Computing (VL/HCC)","","2018","","","287","288","Code review is a common practice in the software industry, in contexts spanning from open to close source, and from free to proprietary software. Modern code reviews are essentially conducted using cloud-based dedicated tools. Existing review tools focus in textual code. In contrast, support of low-code software languages, namely Visual Programming Languages (VPLs), is not readily available. This presents a challenge for the effectiveness of the review process with a VPL. This showpiece will present VPLreviewer, a code review tool for VPLs. VPLreviewer provides a wide range of mechanisms previously not available to a VPL. It is expected to improve of communication among the stakeholders who have to review artifacts constructed with VPLs, with mechanisms that are easy to learn, use and understand.","1943-6106;1943-6092","978-1-5386-4235-1978-1-5386-4236","10.1109/VLHCC.2018.8506527","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8506527","","Tools;Visualization;Software;Message systems;Computer languages;Context;Industries","object-oriented methods;public domain software;software maintenance;software quality;software tools;visual programming","modern code reviews;cloud-based dedicated tools;textual code;low-code software languages;visual programming languages;review process;code review tool;software industry;VPL;free-to-proprietary software;review tool focus","","","4","","","","","","IEEE","IEEE Conferences"
"Gamifying Software Engineering Tasks Based on Cognitive Principles: The Case of Code Review","N. Unkelos-Shpigel; I. Hadar","NA; NA","2015 IEEE/ACM 8th International Workshop on Cooperative and Human Aspects of Software Engineering","","2015","","","119","120","Code review is an important task in software development. However, performing code review is perceived, for the most part, as an undesired task, presenting several challenges to the required collaboration and knowledge transfer between programmers and reviewers. In order to overcome these challenges and improve the effectiveness of code review, we developed SCRUT: Social Code Review Unifying Tool. By recruiting relevant cognitive theories and implementing gamification elements to motivate collaboration and knowledge sharing between programmers and reviewers, we plan to enhance the task of code review. This paper presents our vision for enhancing software engineering via gamification, and the theoretical cognitive foundation on which this vision is based, starting with the example of code review.","","978-1-4673-7031","10.1109/CHASE.2015.21","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7166104","Gamification;code review;boundary object","Software engineering;Games;Software;Collaboration;Conferences;Context","program compilers;software engineering","Gamifying software engineering tasks;cognitive principles;code review case;software development;knowledge transfer;social code review unifying tool;SCRUT;knowledge sharing","","4","7","","","","","","IEEE","IEEE Conferences"
"A Task-Based Code Review Process and Tool to Comply with the DO-278/ED-109 Standard for Air Traffic Managment Software Development: An Industrial Case Study","M. Bernhart; S. Reiterer; K. Matt; A. Mauczka; T. Grechenig","NA; NA; NA; NA; NA","2011 IEEE 13th International Symposium on High-Assurance Systems Engineering","","2011","","","182","187","Software reviews are one of the most efficient quality assurance techniques in software engineering. They are required for the enhancement of the software quality in early phases of the development process and often used in development of safety critical systems. In the field of software engineering for Air Traffic Management (ATM) the standard DO-278/ED-109 requires the rigorous application of code reviews and fully traceable reporting of the results. This case study presents a process and an IDE-integrated tool that complies with the requirements of the standard.","1530-2059;1530-2059","978-1-4673-0107-7978-0-7695-4615","10.1109/HASE.2011.54","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6113895","code review;code inspection;DO-278;ED-109;Air Traffic Management","Software;Servers;Planning;Companies;Programming;Inspection;Asynchronous transfer mode","air traffic;safety-critical software;software quality;software standards;task analysis","task-based code review process;DO-278/ED-109 standard;air traffic management software development;software reviews;quality assurance;software engineering;software quality;safety critical systems","","2","12","","","","","","IEEE","IEEE Conferences"
"Developers' Game: A Preliminary Study Concerning a Tool for Automated Developers Assessment","W. Frącz; J. Dajda","NA; NA","2018 IEEE International Conference on Software Maintenance and Evolution (ICSME)","","2018","","","695","699","These days, despite dynamic development of the software industry there is still no proven and accurate assessment method of developers' performance. Current solutions are based on limited set of factors that can be easily measured by managers, such as the number of hours worked, issues closed, or lines of code written. However, there is more than that: developers write code of better or worse quality, they perform code reviews and code refactorings. To answer these needs we have created the Code Review Analyzer (CRA) tool that uses information gathered in code review platforms to assess developers based on their work style. Among others, it collects information on commits frequency, number of code review rejections and code reviews performed. This information is used to calculate developers performance in a continuous manner and to introduce gamification techniques into the team space by providing developers with their ranking and awarding them with various achievement badges. Afterwards, the tool was experimentally evaluated in order to prove the evaluation accuracy but also to verify the motivational impact of the gamification techniques. The CRA tool demonstration can be seen at https://youtu.be/dUFFxCeH-ok.","2576-3148;1063-6773","978-1-5386-7870-1978-1-5386-7871","10.1109/ICSME.2018.00079","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8530082","code review, code review analyzer, gerrit code review, gamification, software engineering","Tools;Software;Task analysis;Measurement;Games;Industries;Computer bugs","DP industry;software development management;software maintenance;software tools","automated developers assessment;dynamic development;software industry;code reviews;code refactorings;Code Review Analyzer tool;code review platforms;code review rejections;developers performance;CRA tool demonstration;gamification techniques","","","14","","","","","","IEEE","IEEE Conferences"
"Automatically Recommending Peer Reviewers in Modern Code Review","M. B. Zanjani; H. Kagdi; C. Bird","Department of Electrical Engineering and Computer Science, Wichita State University, Wichita, Kansas; Department of Electrical Engineering and Computer Science, Wichita State University, Wichita, Kansas; Microsoft Research, Redmond, WA","IEEE Transactions on Software Engineering","","2016","42","6","530","543","Code review is an important part of the software development process. Recently, many open source projects have begun practicing code review through “modern” tools such as GitHub pull-requests and Gerrit. Many commercial software companies use similar tools for code review internally. These tools enable the owner of a source code change to request individuals to participate in the review, i.e., reviewers. However, this task comes with a challenge. Prior work has shown that the benefits of code review are dependent upon the expertise of the reviewers involved. Thus, a common problem faced by authors of source code changes is that of identifying the best reviewers for their source code change. To address this problem, we present an approach, namely cHRev, to automatically recommend reviewers who are best suited to participate in a given review, based on their historical contributions as demonstrated in their prior reviews. We evaluate the effectiveness of cHRev on three open source systems as well as a commercial codebase at Microsoft and compare it to the state of the art in reviewer recommendation. We show that by leveraging the specific information in previously completed reviews (i.e.,quantification of review comments and their recency), we are able to improve dramatically on the performance of prior approaches, which (limitedly) operate on generic review information (i.e., reviewers of similar source code file and path names) or source coderepository data. We also present the insights into why our approach cHRev outperforms the existing approaches.","0098-5589;1939-3520;2326-3881","","10.1109/TSE.2015.2500238","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7328331","Modern code review;reviewer recommendation;code change;Gerrit;Modern code review;reviewer recommendation;code change;Gerrit","History;Electronic mail;Birds;Inspection;Androids;Humanoid robots;Software","software engineering;software reviews","peer reviewer recommendation;code review;software development process;open source projects;GitHub pull-requests tool;Gerrit tool;source code change;cHRev approach;commercial codebase","","12","55","","","","","","IEEE","IEEE Journals & Magazines"
"A tool to support perspective based approach to software code inspection","L. Chan; K. Jiang; S. Karunasekera","Dept. of Comput. Sci. & Software Eng., Melbourne Univ., Parkville, Vic., Australia; Dept. of Comput. Sci. & Software Eng., Melbourne Univ., Parkville, Vic., Australia; Dept. of Comput. Sci. & Software Eng., Melbourne Univ., Parkville, Vic., Australia","2005 Australian Software Engineering Conference","","2005","","","110","117","It is widely accepted that code inspection is one of the more cost effective forms of testing. It requires a group of inspectors coming together to find defects in an inspection artifact. However, as inspection artifacts grow larger and more complicated, the burden of conducting the code inspection process outweighs the benefits that it provides. Even with the help of automated tools, the process itself has become inefficient as it consumes a large amount of limited resources. Therefore, there has been much research focus on improving the reading technique, which makes a significant impact on the quality of the inspection. In this paper, we discuss the perspective-based reading technique and its benefits to object-oriented projects. We also discuss the need for a new inspection tool and this leads us to propose a tool that supports the perspective-based reading technique with the use of UML design diagrams. This tool supports perspective-based reading technique by matching scenarios in the form of design diagrams to source code and subsequently searching for discrepancies between the two. The use of design diagrams avoids overlapping of inspection effort; thus, increases the efficiency of code inspection even for large projects. We explain how the tool makes the more effort-driven perspective-based reading technique relatively easy as compared to doing it manually.","1530-0803;2377-5408","0-7695-2257","10.1109/ASWEC.2005.10","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1402006","perspective-based reading;UML design diagram;inspection tool","Software tools;Inspection;Software engineering;Costs;Unified modeling language;Computer science;Software testing;Fault detection;Face detection;Australia","software quality;software tools;Unified Modeling Language;object-oriented programming;program testing","software code inspection;perspective-based reading technique;object-oriented projects;inspection tool;UML design diagram;software quality","","1","18","","","","","","IEEE","IEEE Conferences"
"The influence of non-technical factors on code review","O. Baysal; O. Kononenko; R. Holmes; M. W. Godfrey","David R. Cheriton School of Computer Science, University of Waterloo, Canada; David R. Cheriton School of Computer Science, University of Waterloo, Canada; David R. Cheriton School of Computer Science, University of Waterloo, Canada; David R. Cheriton School of Computer Science, University of Waterloo, Canada","2013 20th Working Conference on Reverse Engineering (WCRE)","","2013","","","122","131","When submitting a patch, the primary concerns of individual developers are “How can I maximize the chances of my patch being approved, and minimize the time it takes for this to happen?” In principle, code review is a transparent process that aims to assess qualities of the patch by their technical merits and in a timely manner; however, in practice the execution of this process can be affected by a variety of factors, some of which are external to the technical content of the patch itself. In this paper, we describe an empirical study of the code review process for WebKit, a large, open source project; we replicate the impact of previously studied factors - such as patch size, priority, and component and extend these studies by investigating organizational (the company) and personal dimensions (reviewer load and activity, patch writer experience) on code review response time and outcome. Our approach uses a reverse engineered model of the patch submission process and extracts key information from the issue tracking and code review systems. Our findings suggest that these nontechnical factors can significantly impact code review outcomes.","1095-1350;2375-5369","978-1-4799-2931","10.1109/WCRE.2013.6671287","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6671287","Code review;non-technical factors;personal and organizational aspects;WebKit;open source software","Companies;Electronic mail;Time factors;Browsers;Google;Databases","program diagnostics;reverse engineering;software quality","nontechnical factors;code review process;WebKit;open source project;patch size;priority;component;code review response time;reverse engineered model;patch submission process;issue tracking system;code review system;code review outcome;software quality","","28","14","","","","","","IEEE","IEEE Conferences"
"Who should review my code? A file location-based code-reviewer recommendation approach for Modern Code Review","P. Thongtanunam; C. Tantithamthavorn; R. G. Kula; N. Yoshida; H. Iida; K. Matsumoto","Nara Institute of Science and Technology, Japan; Nara Institute of Science and Technology, Japan; Osaka University, Japan; Nagoya University, Japan; Nara Institute of Science and Technology, Japan; Nara Institute of Science and Technology, Japan","2015 IEEE 22nd International Conference on Software Analysis, Evolution, and Reengineering (SANER)","","2015","","","141","150","Software code review is an inspection of a code change by an independent third-party developer in order to identify and fix defects before an integration. Effectively performing code review can improve the overall software quality. In recent years, Modern Code Review (MCR), a lightweight and tool-based code inspection, has been widely adopted in both proprietary and open-source software systems. Finding appropriate code-reviewers in MCR is a necessary step of reviewing a code change. However, little research is known the difficulty of finding code-reviewers in a distributed software development and its impact on reviewing time. In this paper, we investigate the impact of reviews with code-reviewer assignment problem has on reviewing time. We find that reviews with code-reviewer assignment problem take 12 days longer to approve a code change. To help developers find appropriate code-reviewers, we propose RevFinder, a file location-based code-reviewer recommendation approach. We leverage a similarity of previously reviewed file path to recommend an appropriate code-reviewer. The intuition is that files that are located in similar file paths would be managed and reviewed by similar experienced code-reviewers. Through an empirical evaluation on a case study of 42,045 reviews of Android Open Source Project (AOSP), OpenStack, Qt and LibreOffice projects, we find that RevFinder accurately recommended 79% of reviews with a top 10 recommendation. RevFinder also correctly recommended the code-reviewers with a median rank of 4. The overall ranking of RevFinder is 3 times better than that of a baseline approach. We believe that RevFinder could be applied to MCR in order to help developers find appropriate code-reviewers and speed up the overall code review process.","1534-5351","978-1-4799-8469","10.1109/SANER.2015.7081824","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7081824","Distributed Software Development;Modern Code Review;Code-Reviewer Recommendation","Androids;Humanoid robots;Open source software;Software systems;Manuals;History","public domain software;software reviews","file location;code-reviewer recommendation approach;modern code review;software code review;MCR;proprietary software system;open-source software system;Android open source project;AOSP;OpenStack;Qt project;LibreOffice project;RevFinder","","15","41","","","","","","IEEE","IEEE Conferences"
"Mining the Modern Code Review Repositories: A Dataset of People, Process and Product","X. Yang; R. G. Kula; N. Yoshida; H. Iida","NA; NA; NA; NA","2016 IEEE/ACM 13th Working Conference on Mining Software Repositories (MSR)","","2016","","","460","463","In this paper, we present a collection of Modern Code Review data for five open source projects. The data showcases mined data from both an integrated peer review system and source code repositories. We present an easy-to-use and richer data structure to retrieve the 1.) People 2.) Process and 3.) Product aspects of the peer review. This paper presents the extraction methodology, the dataset structure, and a collection of database dumps.","","978-1-4503-4186-8978-1-5090-2242","10.1109/MSR.2016.054","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7832925","","Data mining;History;Software;Servers;Electronic mail;Relational databases","data mining;data structures;public domain software;software reviews;source code (software)","database dumps collection;dataset structure;extraction methodology;source code repositories;peer review system;data mining;open source projects;code review data;product dataset;process dataset;people dataset;code review repositories","","","22","","","","","","IEEE","IEEE Conferences"
"Investigating code review quality: Do people and participation matter?","O. Kononenko; O. Baysal; L. Guerrouj; Y. Cao; M. W. Godfrey","David R. Cheriton School of Computer Science, University of Waterloo, Canada; Department of Computer Science and Operations Research, Université de Montréal, Canada; Département de Génie Logiciel et des Technologies de l'Information, École de technologie supérieure, Canada; Department of Computer Science and Operations Research, Université de Montréal, Canada; David R. Cheriton School of Computer Science, University of Waterloo, Canada","2015 IEEE International Conference on Software Maintenance and Evolution (ICSME)","","2015","","","111","120","Code review is an essential element of any mature software development project; it aims at evaluating code contributions submitted by developers. In principle, code review should improve the quality of code changes (patches) before they are committed to the project's master repository. In practice, bugs are sometimes unwittingly introduced during this process. In this paper, we report on an empirical study investigating code review quality for Mozilla, a large open-source project. We explore the relationships between the reviewers' code inspections and a set of factors, both personal and social in nature, that might affect the quality of such inspections. We applied the SZZ algorithm to detect bug-inducing changes that were then linked to the code review information extracted from the issue tracking system. We found that 54% of the reviewed changes introduced bugs in the code. Our findings also showed that both personal metrics, such as reviewer workload and experience, and participation metrics, such as the number of involved developers, are associated with the quality of the code review process.","","978-1-4673-7532-0978-1-4673-7531","10.1109/ICSM.2015.7332457","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7332457","Code review;code review quality;bug-inducing changes;mining software repositories;Mozilla;empirical study","Computer bugs;Data mining;Electronic mail;Software;Androids;Humanoid robots;Control systems","program debugging;project management;public domain software;software development management;software metrics;software quality;software reviews","code review quality;software development project;code change quality;project master repository;Mozilla;open-source project;reviewer code inspections;SZZ algorithm;bug-inducing change detection;personal metrics;reviewer workload;code review process","","12","43","","","","","","IEEE","IEEE Conferences"
"Software Architecture and Specification Model for Customizable Code Inspection Tools","M. Noro; A. Sawada","NA; NA","2015 Asia-Pacific Software Engineering Conference (APSEC)","","2015","","","230","237","This paper describes the aspect-oriented software architecture and the finite automaton based specification model for building customizable code inspection tools. Through the development of a production quality code inspection tool, five crosscutting concerns are identified: internal data model, language processing, data traverse, inspection logic, and decoupling control. We constructed an aspect-oriented software architecture manipulating the concerns. The architecture is flexible to various changes to code inspection tools. With a combination of six design patterns: Composite, Interpreter, Visitor, Mediator, Command and State, an application framework based on the architecture is implemented. The usefulness of the architecture is discussed. The finite automaton model for the specification to the inspection logic is introduced and its practicality is demonstrated with our inspection tool. We also show that the combination of our architecture and our specification model is a useful basis for test case generation for each inspection logic. Possibilities for automatic generation of inspection codes are discussed as well.","1530-1362","978-1-4673-9644","10.1109/APSEC.2015.44","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7467305","software architecture;source code inspection;aspect-oriented software architecture;application framework;finite-state automaton;test-case generation","Inspection;Syntactics;Computer architecture;Data models;Software architecture;Semantics;Automata","aspect-oriented programming;finite automata;formal specification;inspection;program testing;software architecture;software tools;source code (software)","test case generation;inspection logic;state pattern;command patterns;mediator pattern;visitor pattern;interpreter patterns;composite patterns;language processing;internal data model;production quality code inspection tools;customizable code inspection tool building;finite automaton based specification model;aspect-oriented software architecture;customizable code inspection tools;software specification model","","","16","","","","","","IEEE","IEEE Conferences"
"Tool Support for Managing Clone Refactorings to Facilitate Code Review in Evolving Software","Z. Chen; M. Mohanavilasam; Y. Kwon; M. Song","NA; NA; NA; NA","2017 IEEE 41st Annual Computer Software and Applications Conference (COMPSAC)","","2017","1","","288","297","Developers often perform copy-and-paste activities. This practice causes the similar code fragment (aka code clones) to be scattered throughout a code base. Refactoring for clone removal is beneficial, preventing clones from having negative effects on software quality, such as hidden bug propagation and unintentional inconsistent changes. However, recent research has provided evidence that factoring out clones is not always to reduce the risk of introducing defects, and it is often difficult or impossible to remove clones using standard refactoring techniques. To investigate which or how clones can be refactored, developers typically spend a significant amount of their time managing individual clone instances or clone groups scattered across a large code base. To address the problem, this paper presents a technique for managing clone refactorings, Pattern-based clone Refactoring Inspection (PRI), using refactoring pattern templates. By matching the refactoring pattern templates against a code base, it summarizes refactoring changes of clones, and detects the clone instances not consistently factored out as potential anomalies. PRI also provides novel visualization user interfaces specifically designed for inspecting clone refactorings. In the evaluation, PRI analyzes clone instances in six open source projects. It identifies clone refactorings with 94.1% accuracy and detects inconsistent refactorings with 98.4% accuracy. Our results show that PRI should help developers effectively inspect evolving clones and correctly apply refactorings to clone groups.","0730-3157","978-1-5386-0367-3978-1-5386-0368","10.1109/COMPSAC.2017.242","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8029620","Code clones;refactorings;software evolution;maintenance","Cloning;Tools;Computer bugs;Standards;Software;Inspection;Pattern matching","data visualisation;public domain software;software maintenance;software management;software quality;software tools;source code (software);user interfaces","code base;clone removal;code clones;PRI;tool support;clone refactorings management;code review facilitation;code fragment;pattern-based clone refactoring inspection;refactoring pattern templates matching;clone instances analysis;open source projects;visualization user interfaces;software quality","","1","46","","","","","","IEEE","IEEE Conferences"
"Process Cube for Software Defect Resolution","M. Gupta; A. Sureka","NA; NA","2014 21st Asia-Pacific Software Engineering Conference","","2014","1","","239","246","Online Analytical Processing (OLAP) cube is a multi-dimensional dataset used for analyzing data in a Data Warehouse (DW) for the purpose of extracting actionable intelligence. Process mining consists of analyzing event log data produced from Process Aware Information Systems (PAIS) for the purpose of discovering and improving business processes. Process cube is a concept which falls at the intersection of OLAP cube and process mining. Process cube facilitates process mining from multiple-dimensions and enables comparison of process mining results across various dimensions. We present an application of process cube to software defect resolution process to analyze and compare process data from a multi-dimensional perspective. We present a framework, a novel perspective to mine software repositories using process cube. Each cell of process cube is defined by metrics from multiple process mining perspectives like control flow, time, conformance and organizational perspective. We conduct a case-study on Google Chromium project data in which the software defect resolution process spans three software repositories: Issue Tracking System (ITS), Peer Code Review System (PCR) and Version Control System (VCS). We define process cube with 9 dimensions as issue report timestamp, priority, state, closed status, OS, component, bug type, reporter and owner. We define hierarchies along various dimensions and cluster members to handle sparsity. We apply OLAP cube operations such as slice, dice, roll-up and drill-down, and create materialized sub log for each cell. We demonstrate the solution approach by discovering process map and compare process mining results from Control Flow and Time perspective for Performance and Security issues.","1530-1362;1530-1362","978-1-4799-7426-9978-1-4799-7425","10.1109/APSEC.2014.45","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7091316","Empirical Software Engineering;Issue Tracking System;Mining Software Repositories;OLAP;Peer Code Review System;Process Cube;Process Mining;Version Control System","Data mining;Security;Software;Process control;Google;Measurement;Chromium","configuration management;data mining;data warehouses;program debugging;software engineering;software maintenance","online analytical processing cube;multidimensional dataset;data warehouse;DW;actionable intelligence extraction;process mining;event log data analysis;process aware information systems;PAIS;software defect resolution process;software repositories;control flow;organizational perspective;conformance perspective;Google Chromium project data;issue tracking system;ITS;peer code review system;PCR;version control system;VCS;issue report timestamp;issue report priority;issue report state;issue report closed status;issue report OS;issue report component;bug type;reporter;owner;OLAP cube operations;security issues;performance issues","","3","16","","","","","","IEEE","IEEE Conferences"
"Learning outcomes of programming language courses based on peer code review model","W. Yanqing; L. Hang; S. Yanan; J. Yu; Y. Jie","School of Management, Harbin Institute of Technology, Harbin 150001, China; School of Management, Harbin Institute of Technology, Harbin 150001, China; School of Management, Harbin Institute of Technology, Harbin 150001, China; School of Management, Harbin Institute of Technology, Harbin 150001, China; School of Management, Harbin Institute of Technology, Harbin 150001, China","2011 6th International Conference on Computer Science & Education (ICCSE)","","2011","","","751","754","Software quality assurance at source code level has drawn pressing concerns because of the increasing complexity and size of software projects. Based on the updated peer code review process model, an information system was constructed. After several academic years' implementation, questionnaire is made and data is analyzed. Some charming learning outcomes are recognized. Peer code review model is further proved vital in the pedagogy and evaluating of programming language although it can still be improved.","","978-1-4244-9718-8978-1-4244-9717-1978-1-4244-9716","10.1109/ICCSE.2011.6028746","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6028746","peer code review;learning outcome;programming language;SQA at source level;questionnaire","Programming;Encoding;Information systems;Standards;Software;Collaborative work;Conferences","computer aided instruction;computer science education;data analysis;educational courses;information systems;programming languages;quality assurance;software quality;source coding","programming language courses;peer code review model;software quality assurance;source code level;software projects;information system;questionnaire;learning outcomes;pedagogy;data analysis","","","10","","","","","","IEEE","IEEE Conferences"
"Semantics-assisted code review: An efficient tool chain and a user study","M. Menarini; Y. Yan; W. G. Griswold","Department of Computer Science and Engineering, University of California at San Diego, La Jolla, CA, USA; Department of Computer Science and Engineering, University of California at San Diego, La Jolla, CA, USA; Department of Computer Science and Engineering, University of California at San Diego, La Jolla, CA, USA","2017 32nd IEEE/ACM International Conference on Automated Software Engineering (ASE)","","2017","","","554","565","Code changes are often reviewed before they are deployed. Popular source control systems aid code review by presenting textual differences between old and new versions of the code, leaving developers with the difficult task of determining whether the differences actually produced the desired behavior. Fortunately, we can mine such information from code repositories. We propose aiding code review with inter-version semantic differential analysis. During review of a new commit, a developer is presented with summaries of both code differences and behavioral differences, which are expressed as diffs of likely invariants extracted by running the system's test cases. As a result, developers can more easily determine that the code changes produced the desired effect. We created an invariant-mining tool chain, Getty, to support our concept of semantically-assisted code review. To validate our approach, 1) we applied Getty to the commits of 6 popular open source projects, 2) we assessed the performance and cost of running Getty in different configurations, and 3) we performed a comparative user study with 18 developers. Our results demonstrate that semantically-assisted code review is feasible, effective, and that real programmers can leverage it to improve the quality of their reviews.","","978-1-5386-2684-9978-1-5386-3976","10.1109/ASE.2017.8115666","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115666","Software behavior;mining software repository;code review;likely invariants;dynamic impact analysis;scalability;software testing","Tools;Testing;Computer bugs;Semantics;Software;Navigation","data mining;Internet;project management;software maintenance","semantic-assisted code review;invariant-mining tool chain;code differences;inter-version semantic differential analysis;code repositories;code changes","","","38","","","","","","IEEE","IEEE Conferences"
"Analyzing Involvements of Reviewers through Mining a Code Review Repository","J. Liang; O. Mizuno","NA; NA","2011 Joint Conference of the 21st International Workshop on Software Measurement and the 6th International Conference on Software Process and Product Measurement","","2011","","","126","132","In order to assure the quality of software, early detection of defects is highly recommended. Code review is one of effective way for such early detection of defects in software. Code review activities must contain various useful insights for software quality. However, especially in open source software developments, records of code review merely exist. In this study, we try to analyze a code review repository of an open source software, Chromium, which adopts a code review tool in its development.Before analyzing the code review data, we address 7 research questions. We can find interesting answers for these questions by repositories mining.","","978-1-4577-1930","10.1109/IWSM-MENSURA.2011.33","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6113052","code review;quality;repository mining","Chromium;Data mining;Measurement;Correlation;Software;Control systems;Crawlers","data mining;public domain software;software quality","code review repository mining;software quality;defects detection;open source software;Chromium","","3","17","","","","","","IEEE","IEEE Conferences"
"A Collaborative Code Review Platform for GitHub","A. Kalyan; M. Chiam; J. Sun; S. Manoharan","NA; NA; NA; NA","2016 21st International Conference on Engineering of Complex Computer Systems (ICECCS)","","2016","","","191","196","The incorporation of peer code reviews as being part of a developer's work flow, and hence the software development lifecycle, has steadily grown in popularity over the past three decades. During the process of statically inspecting code, developers of a codebase are able to collaboratively detect possible code defects, as well as use code reviews as a means of transferring knowledge to improve the overall understanding of a system. The uptake of such practices is dependent on several factors, specifically the availability of tools that aid in providing an easy-to-use and intuitive platform to perform code reviews, and is readily accessible to members of a project. This paper briefly explores the act of code review, identifies the pitfalls of existing code review tools, and proposes the design and development of a web-based code review application, along with the evaluation of the prototype. The code review tool developed, Fistbump, targets the popular Git based repository hosting service, GitHub, and provides a versatile tool to coordinate and manage discussions between the owner of a pull request and the elected participants of a review.","","978-1-5090-5527-2978-1-5090-5526-5978-1-5090-5528","10.1109/ICECCS.2016.032","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7816585","Code Review;Team Programming;Collaborative Platform","Software;Inspection;Industries;Collaboration;Servers;Message systems;Computers","groupware;Internet;program debugging;software development management;software tools;source code (software)","code defect detection;Git based repository hosting service;Fistbump;Web-based code review application;code review tools;software development lifecycle;GitHub;collaborative code review platform","","1","12","","","","","","IEEE","IEEE Conferences"
"Process Aspects and Social Dynamics of Contemporary Code Review: Insights from Open Source Development and Industrial Practice at Microsoft","A. Bosu; J. C. Carver; C. Bird; J. Orbeck; C. Chockley","Department of Computer Science, Southern Illinois University, Carbondale, IL; Department of Computer Science, University of Alabama, Tuscaloosa, AL; Microsoft Research, Microsoft Corportation, Redmond, WA; Department of Computer Science, University of Alabama, Tuscaloosa, AL; Department of Computer Science, University of Alabama, Tuscaloosa, AL","IEEE Transactions on Software Engineering","","2017","43","1","56","75","Many open source and commercial developers practice contemporary code review, a lightweight, informal, tool-based code review process. To better understand this process and its benefits, we gathered information about code review practices via surveys of open source software developers and developers from Microsoft. The results of our analysis suggest that developers spend approximately 10-15 percent of their time in code reviews, with the amount of effort increasing with experience. Developers consider code review important, stating that in addition to finding defects, code reviews offer other benefits, including knowledge sharing, community building, and maintaining code quality. The quality of the code submitted for review helps reviewers form impressions about their teammates, which can influence future collaborations. We found a large amount of similarity between the Microsoft and OSS respondents. One interesting difference is that while OSS respondents view code review as an important method of impression formation, Microsoft respondents found knowledge dissemination to be more important. Finally, we found little difference between distributed and co-located Microsoft teams. Our findings identify the following key areas that warrant focused research: 1) exploring the non-technical benefits of code reviews, 2) helping developers in articulating review comments, and 3) assisting reviewers' program comprehension during code reviews.","0098-5589;1939-3520;2326-3881","","10.1109/TSE.2016.2576451","US National Science Foundation; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7484733","Code review;open source;OSS;survey;peer impressions;commercial projects","Inspection;Organizations;Collaboration;Context;Instruments;Measurement;Human factors","public domain software;software engineering;software management;software reviews;team working","contemporary code review;open source software developers;code quality;OSS;knowledge dissemination;Microsoft teams","","2","58","","","","","","IEEE","IEEE Journals & Magazines"
"Gerrit software code review data from Android","M. Mukadam; C. Bird; P. C. Rigby","Concordia University Montreal, QC, Canada; Microsoft Research, Redmond, WA, USA; Concordia University Montreal, QC, Canada","2013 10th Working Conference on Mining Software Repositories (MSR)","","2013","","","45","48","Over the past decade, a number of tools and systems have been developed to manage various aspects of the software development lifecycle. Until now, tool supported code review, an important aspect of software development, has been largely ignored. With the advent of open source code review tools such as Gerrit along with projects that use them, code review data is now available for collection, analysis, and triangulation with other software development data. In this paper, we extract Android peer review data from Gerrit. We describe the Android peer review process, the reverse engineering of the Gerrit JSON API, our data mining and cleaning methodology, database schema, and provide an example of how the data can be used to answer an empirical software engineering question. The database is available for use by the research community.","2160-1860;2160-1852","978-1-4673-2936-1978-1-4799-0345","10.1109/MSR.2013.6624002","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6624002","","Androids;Humanoid robots;Software;Databases;Data mining;Servers","application program interfaces;data mining;database management systems;operating system kernels;public domain software;reverse engineering;software development management;software tools","software development lifecycle management;open source code review tools;software development data;Android peer review data extract;Android peer review process;reverse engineering;Gerrit JSON API;data mining methodology;data cleaning methodology;database schema;software engineering;Android;Gerrit software code review data","","14","7","","","","","","IEEE","IEEE Conferences"
"0-1 Programming Model-Based Method for Planning Code Review Using Bug Fix History","H. Aman","NA","2013 20th Asia-Pacific Software Engineering Conference (APSEC)","","2013","2","","37","42","Code review is a powerful activity for software quality improvement, and is ideal to review all source files being developed. However, such an exhaustive review would be difficult because the available time and effort are in reality limited. Thus, practitioners prioritize the source files in terms of bug-proneness by using related data such as bug fix history, and review them in decreasing order of priority-such strategy in this paper is called the ""conventional method."" While the conventional method is straightforward, it focuses only on the bug-proneness and cannot consider the review cost properly, so the method does not produce a cost-effective review plan. To take into account both the bug-proneness and the review cost, this paper proposes a 0-1 programming model-based method for planning code review. The proposed method formulates a review plan as a 0-1 programming problem, and the solution is the recommendation list of source files to be reviewed. Moreover, the proposed method considers the type of file-if the file is newly-developed or not. Such difference in file type may affect on how to evaluate the bug-proneness and the review strategy: newly-developed files are notable but not appeared in the bug fix history. This paper conducts a case study using popular open source software, shows that the proposed method is up to 42% more effective than the conventional method in recommending buggy files as the review targets.","1530-1362;1530-1362","978-1-4799-2144-7978-1-4799-2143","10.1109/APSEC.2013.109","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6754348","code review;cost-effectiveness;0-1 programming model;bug fix history","Programming;Measurement;History;Planning;Software;Complexity theory;Mathematical model","integer programming;linear programming;program debugging;software cost estimation;software quality;source code (software)","software quality improvement;source files;bug fix history;cost-effective review plan;bug-proneness;review cost;0-1 programming model-based method;planning code review;file type;open source software","","","15","","","","","","IEEE","IEEE Conferences"
"Investigating Code Review Practices in Defective Files: An Empirical Study of the Qt System","P. Thongtanunam; S. McIntosh; A. E. Hassan; H. Iida","NA; NA; NA; NA","2015 IEEE/ACM 12th Working Conference on Mining Software Repositories","","2015","","","168","179","Software code review is a well-established software quality practice. Recently, Modern Code Review (MCR) has been widely adopted in both open source and proprietary projects. To evaluate the impact that characteristics of MCR practices have on software quality, this paper comparatively studies MCR practices in defective and clean source code files. We investigate defective files along two perspectives: 1) files that will eventually have defects (i.e., Future-defective files) and 2) files that have historically been defective (i.e., Risky files). Through an empirical study of 11,736 reviews of changes to 24,486 files from the Qt open source project, we find that both future-defective files and risky files tend to be reviewed less rigorously than their clean counterparts. We also find that the concerns addressed during the code reviews of both defective and clean files tend to enhance evolvability, i.e., Ease future maintenance (like documentation), rather than focus on functional issues (like incorrect program logic). Our findings suggest that although functionality concerns are rarely addressed during code review, the rigor of the reviewing process that is applied to a source code file throughout a development cycle shares a link with its defect proneness.","2160-1852;2160-1860","978-0-7695-5594","10.1109/MSR.2015.23","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7180077","Code Review;Software Quality","Measurement;Testing;Inspection;Data mining;Software quality;Maintenance engineering","program diagnostics;software development management;software maintenance;software quality","code review practices;defective files;Qt system;software code review;software quality practice;modern code review;MCR;future-defective files;risky files;future maintenance;functional issues;source code file;development cycle;defect proneness","","16","40","","","","","","IEEE","IEEE Conferences"
"A Study of the Quality-Impacting Practices of Modern Code Review at Sony Mobile","J. Shimagaki; Y. Kamei; S. Mcintosh; A. E. Hassan; N. Ubayashi","NA; NA; NA; NA; NA","2016 IEEE/ACM 38th International Conference on Software Engineering Companion (ICSE-C)","","2016","","","212","221","Nowadays, a flexible, lightweight variant of the code review process (i.e., the practice of having other team members critique software changes) is adopted by open source and proprietary software projects. While this flexibility is a blessing (e.g., enabling code reviews to span the globe), it does not mandate minimum review quality criteria like the formal code inspections of the past. Recent work shows that lax reviewing can impact the quality of open source systems. In this paper, we investigate the impact that code reviewing practices have on the quality of a proprietary system that is developed by Sony Mobile. We begin by replicating open source analyses of the relationship between software quality (as approximated by post-release defect-proneness) and: (1) code review coverage, i.e., the proportion of code changes that have been reviewed and (2) code review participation, i.e., the degree of reviewer involvement in the code review process. We also perform a qualitative analysis, with a survey of 93 stakeholders, semi-structured interviews with 15 stakeholders, and a follow-up survey of 25 senior engineers. Our results indicate that while past measures of review coverage and participation do not share a relationship with defect-proneness at Sony Mobile, reviewing measures that are aware of the Sony Mobile development context are associated with defect-proneness. Our results have lead to improvements of the Sony Mobile code review process.","","978-1-4503-4205-6978-1-5090-2245","","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7883305","Code review;software quality","Mobile communication;Measurement;Software quality;Stakeholders;Inspection;Interviews","program testing;public domain software;software quality","quality-impacting practices;Sony Mobile;open source systems;software quality;code review coverage;code review participation;defect-proneness;software testing","","","32","","","","","","IEEE","IEEE Conferences"
"Mining Peer Code Review System for Computing Effort and Contribution Metrics for Patch Reviewers","R. Mishra; A. Sureka","NA; NA","2014 IEEE 4th Workshop on Mining Unstructured Data","","2014","","","11","15","Peer code review is a software quality assurance activity followed in several open-source and closed-source software projects. Rietveld and Gerrit are the most popular peer code review systems used by open-source software projects. Despite the popularity and usefulness of these systems, they do not record or maintain the cost and effort information for a submitted patch review activity. Currently there are no formal or standard metrics available to measure effort and contribution of a patch review activity. We hypothesize that the size and complexity of modified files and patches are significant indicators of effort and contribution of patch reviewers in a patch review process. We propose a metric for computing the effort and contribution of a patch reviewer based on modified file size, patch size and program complexity variables. We conduct a survey of developers involved in peer code review activity to test our hypothesis of causal relationship between proposed indicators and effort. We employ the proposed model and conduct an empirical analysis using the proposed metrics on open-source Google Android project.","","978-1-4799-6793","10.1109/MUD.2014.11","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6980189","Contribution and Performance Assessment;Empirical Software Engineering and Measurements;Mining Software Repositories;Peer Code Review;Software Maintenance","Complexity theory;Software;Google;Smart phones;Data mining;Size measurement","data mining;public domain software;software metrics;software quality;software reviews;source code (software)","computing effort;contribution metrics;software quality assurance activity;open-source software projects;closed-source software projects;peer code review system mining;patch review activity;patch review process;modified file size;patch size;program complexity variables;peer code review activity;causal relationship;open-source Google Android project","","3","9","","","","","","IEEE","IEEE Conferences"
"Multimedia groupware for code inspection","L. R. Brothers","Bellcore, Morristown, NJ, USA","[Conference Record] SUPERCOMM/ICC '92 Discovering a New World of Communications","","1992","","","1076","1081 vol.2","ICICLE is a multifaced software system intended to augment the process of formal code inspection. There are two principle phases of code inspection: comment preparation and the code inspection meeting. ICICLE addresses the first phase, comment preparation, by providing a variety of software tools to help individual code inspectors find potential problems, and to record their comments. New ICICLE versions incorporate various media to support distributed work groups and informal code review sessions. The author reports the results of experimentation with various configurations of multiple media and underlying computer communications networks.<<ETX>>","","0-7803-0599","10.1109/ICC.1992.268149","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=268149","","Collaborative software;Collaborative work;Inspection;Computer bugs;Software testing;Programming;Software systems;Software prototyping;Industrial training;Computer industry","groupware;multimedia systems;program diagnostics;software tools","multimedia groupware;intelligent code inspection in C language environment;ICICLE;multifaced software system;formal code inspection;comment preparation;software tools;distributed work groups;informal code review sessions;computer communications networks","","","11","","","","","","IEEE","IEEE Conferences"
"A Security Perspective on Code Review: The Case of Chromium","M. di Biase; M. Bruntink; A. Bacchelli","NA; NA; NA","2016 IEEE 16th International Working Conference on Source Code Analysis and Manipulation (SCAM)","","2016","","","21","30","Modern Code Review (MCR) is an established software development process that aims to improve software quality. Although evidence showed that higher levels of review coverage relates to less post-release bugs, it remains unknown the effectiveness of MCR at specifically finding security issues. We present a work we conduct aiming to fill that gap by exploring the MCR process in the Chromium open source project. We manually analyzed large sets of registered (114 cases) and missed (71 cases) security issues by backtracking in the project's issue, review, and code histories. This enabled us to qualify MCR in Chromium from the security perspective from several angles: Are security issues being discussed frequently? What categories of security issues are often missed or found? What characteristics of code reviews appear relevant to the discovery rate? Within the cases we analyzed, MCR in Chromium addresses security issues at a rate of 1% of reviewers' comments. Chromium code reviews mostly tend to miss language-specific issues (eg C++ issues and buffer overflows) and domain-specific ones (eg such as Cross-Site Scripting), when code reviews address issues, mostly they address those that pertain to the latter type. Initial evidence points to reviews conducted by more than 2 reviewers being more successful at finding security issues.","2470-6892","978-1-5090-3848-0978-1-5090-3849","10.1109/SCAM.2016.30","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7781793","code review;modern code review;software security;security flaw;mining software repositories;empirical software engineering","Security;Chromium;Inspection;Computer bugs;Manuals;Software quality","backtracking;program debugging;public domain software;safety-critical software;software quality;source code (software)","modern code review;MCR;software development process;software quality improvement;bugs;security issues;Chromium open source project;Chromium code reviews;language-specific issues;domain-specific ones;backtracking","","","39","","","","","","IEEE","IEEE Conferences"
"SentiCR: A customized sentiment analysis tool for code review interactions","T. Ahmed; A. Bosu; A. Iqbal; S. Rahimi","Department of Computer Science &amp; Engineering, Bangladesh University of Engineering and Technology, Dhaka, Bangladeshi; Department of Computer Science, Southern Illinois University Carbondale, IL, USA; Department of Computer Science &amp; Engineering, Bangladesh University of Engineering and Technology, Dhaka, Bangladeshi; Department of Computer Science, Southern Illinois University Carbondale, IL, USA","2017 32nd IEEE/ACM International Conference on Automated Software Engineering (ASE)","","2017","","","106","111","Sentiment Analysis tools, developed for analyzing social media text or product reviews, work poorly on a Software Engineering (SE) dataset. Since prior studies have found developers expressing sentiments during various SE activities, there is a need for a customized sentiment analysis tool for the SE domain. On this goal, we manually labeled 2000 review comments to build a training dataset and used our dataset to evaluate seven popular sentiment analysis tools. The poor performances of the existing sentiment analysis tools motivated us to build SentiCR, a sentiment analysis tool especially designed for code review comments. We evaluated SentiCR using one hundred 10-fold cross-validations of eight supervised learning algorithms. We found a model, trained using the Gradient Boosting Tree (GBT) algorithm, providing the highest mean accuracy (83%), the highest mean precision (67.8%), and the highest mean recall (58.4%) in identifying negative review comments.","","978-1-5386-2684-9978-1-5386-3976","10.1109/ASE.2017.8115623","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115623","","Tools;Sentiment analysis;Supervised learning;Training;Algorithm design and analysis;Dictionaries;Social network services","learning (artificial intelligence);natural language processing;pattern classification;social networking (online);text analysis;trees (mathematics)","software engineering dataset;gradient boosting tree algorithm;GBT algorithm;SentiCR;negative review comments;code review comments;SE domain;SE activities;social media text;code review interactions;customized sentiment analysis tool","","3","48","","","","","","IEEE","IEEE Conferences"
"CloneMap: A Clone-Aware Code Inspection Tool in Evolving Software","A. Fish; T. L. Nguyen; M. Song","Department of Computer Science, University of Nebraska, Omaha, NE, USA; Department of Computer Science, University of Nebraska, Omaha, NE, USA; Department of Computer Science, University of Nebraska, Omaha, NE, USA","2018 IEEE International Conference on Electro/Information Technology (EIT)","","2018","","","0368","0372","Mining software repositories is a frequent tactic in the evaluation of software in our research. Software modification of large code bases often consists of recurring changes, similar but slightly different changes across multiple locations and revisions. It is a high-effort, time consuming process for developers to find all the relevant locations to maintain such changes among bug-fixes, refactorings, and new code being added to the code base for new features. This process is highly error-prone leading to many mistakes, such as inconsistent or incorrect updates. To address this problem, we present a tool that helps developers ensure correctness of recurring changes to multiple locations in an evolving software. CloneMap is a clone-aware code inspection tool which allows developers to specify the older and newer revisions of a software. It then applies a clone detection technique to (1) mine repositories for extracting differences of recurring changes, (2) visualize the clone evolution, and (3) help developers focus their attention to potential anomalies, such as inconsistent and missing updates as the software evolves from one revision to the next.","2154-0373;2154-0357","978-1-5386-5398-2978-1-5386-5397-5978-1-5386-5399","10.1109/EIT.2018.8500143","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8500143","","Cloning;Software;Tools;Computer bugs;Inspection;Visualization;Task analysis","data mining;inspection;program debugging;program diagnostics;program visualisation;software maintenance","clone-aware code inspection tool;clone detection technique;recurring changes;mining software repositories;software modification;code base;time consuming process;highly error-prone;clonemap;potential anomalies","","","12","","","","","","IEEE","IEEE Conferences"
"What makes a code review trustworthy?","S. Nelson; J. Schumann","NA; NA","37th Annual Hawaii International Conference on System Sciences, 2004. Proceedings of the","","2004","","","10 pp.","","Code review is an important step during the process of certifying safety-critical software because only code that passes review can be implemented. Reviews are performed by review boards composed of highly skilled and experienced computer scientists, engineers and analysts who generally rely upon a checklist of properties ranging from high-level requirements to minute language details. While many checklists and coding standards exist, the actual decision of which properties are most important is generally based on the experience of the person in charge. This paper addresses the questions: How can code review ensure certification of trustworthy code? and Is code review trustworthy? We surveyed technical leaders at NASA and the Aerospace industry to find out which properties are most important during the code review. To make analyze easier, the most common properties have been classified along different ""views"", ranging from a standards-oriented view (defined as the properties needed to satisfy a specific standard) to a tool-oriented view. In this paper, we present this classification together with a summary of findings and feed-back from the survey. We also discuss how a more uniform view on properties of code review and tool capabilities can result in increased trust for safety-critical software.","","0-7695-2056","10.1109/HICSS.2004.1265711","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1265711","","NASA;Software safety;Aerospace industry;Certification;Software tools;Code standards;Computer errors;High performance computing;Performance analysis;Software design","safety-critical software;certification","code review;safety-critical software;software certification;high-level requirements;coding standards;NASA;aerospace industry","","6","28","","","","","","IEEE","IEEE Conferences"
"How is IF Statement Fixed Through Code Review? A Case Study of Qt Project","Y. Ueda; A. Ihara; T. Hirao; T. Ishio; K. Matsumoto","NA; NA; NA; NA; NA","2017 IEEE International Symposium on Software Reliability Engineering Workshops (ISSREW)","","2017","","","207","213","Peer code review is key to ensuring the absence of software defects. To improve the review process, many code review tools provide OSS(Open Source Software) project CI(Continuous Integration) tests that automatically verify code quality issues such as a code convention issues. However, these tests do not cover project policy issues and a code readability issues. In this study, our main goal is to understand how a code owner fixes conditional statement issues based on reviewers feedback. We conduct an empirical study to understand if statement changes after review. Using 69,325 review requests in the Qt project, we analyze changes of the if conditional statements that (1) are requested to be reviewed, and (2) that are implemented after review. As a result, we find the most common symbolic changes are ""("" and "")"" (35%), ""!"" operator (20%) and ""->"" operator (12%). Also, ""!"" operator is frequently replaced with ""("" and "")"".","","978-1-5386-2387-9978-1-5386-2388","10.1109/ISSREW.2017.32","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8109285","if statement;code review;conditional statement;static code analysis;fix detection","Software;Itemsets;Data mining;Tools;Syntactics;Manuals;Programming","program debugging;program testing;program verification;project management;public domain software;software quality;source code (software)","reviewers feedback;open source software;OSS;continuous integration;CI;code quality verification;code convention;project policy;code readability;code review tools;review process;software defects;peer code review;Qt project","","","26","","","","","","IEEE","IEEE Conferences"
"Identifying Software Process Management Challenges: Survey of Practitioners in a Large Global IT Company","M. Gupta; A. Sureka; S. Padmanabhuni; A. M. Asadullah","NA; NA; NA; NA","2015 IEEE/ACM 12th Working Conference on Mining Software Repositories","","2015","","","346","356","Process mining consists of mining event logs generated from business process execution supported by Information Systems (IS). Process mining of software repositories has diverse applications because vast data is generated during Software Development Life Cycle (SDLC) and archived in IS such as Version Control System (VCS), Peer Code Review (PCR) System, Issue Tracking System (ITS), and mail archives. There is need to explore its applications on different repositories to aid managers in process management. We conduct two phase surveys and interviews with managers in a large, global, IT company. The first survey and in-person interviews identify the process challenges encountered by them that can be addressed by novel applications of process mining. We filter, group and abstract responses formulating 30 generic problem statements. On the basis of process mining type, we classify identified problems to eight categories such as control analysis, organizational analysis, conformance analysis, and preventive analysis. The second survey asks distinct participants the importance of solving identified problems. We calculate proposed Net Importance Metric (NIM) using 1262 ratings from 43 participants. Combined analysis of NIM and first survey responses reveals that the problems mentioned by few practitioners in first survey are considered important by majority in the second survey. We elaborate on possible solutions and challenges for most frequent and important problems. We believe solving these validated problems will help managers in improving project quality and productivity.","2160-1852;2160-1860","978-0-7695-5594","10.1109/MSR.2015.39","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7180093","Process Mining;Qualitative Study;Software Development Life Cycle;Software Repositories","Data mining;Software;Process control;Interviews;Measurement;Companies","business process re-engineering;data mining;information systems;information technology;software process improvement","software process management;global IT company;process mining;event logs mining;business process execution;information systems;IS;software development life cycle;SDLC;net importance metric;NIM;project quality;productivity","","1","32","","","","","","IEEE","IEEE Conferences"
"Assessing the Effectiveness of a Distributed Method for Code Inspection: A Controlled Experiment","A. De Lucia; F. Fasano; G. Tortora; G. Scanniello","University of Salerno, Via Ponte Don Melillo; University of Salerno, Via Ponte Don Melillo; University of Salerno, Via Ponte Don Melillo; University of Basilicata, Viale Dell'Ateneo","International Conference on Global Software Engineering (ICGSE 2007)","","2007","","","252","261","We propose a distributed inspection method that tries to minimise the synchronous collaboration among team members to identify defects in software artefacts. The approach consists of identifying conflicts on the potential defects and then resolving them using an asynchronous discussion before performing a traditional synchronous meeting. This approach has been implemented in a Web based tool and assessed through a controlled experiment with master students in Computer Science at the University of Salerno. The tool presented provides automatic merge and conflict highlighting functionalities to support the inspectors during the pre-meeting refinement phase and provides the moderator with information about the inspection progress as a decision support. The tool also supports a synchronous inspection meeting to discuss about unsolved conflicts. However, by analysing the data collected during a controlled experiment we found that this phase can often be skipped due to the fact that asynchronous discussion resolved most of the conflicts.","2329-6305;2329-6313","0-7695-2920-8978-0-7695-2920","10.1109/ICGSE.2007.11","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4299861","","Inspection;Costs;Collaborative software;Automatic control;Software quality;Software engineering;Meeting planning;Process planning;Human resource management;Project management","program verification","code inspection;distributed inspection method;software defects identification;Salerno University","","4","26","","","","","","IEEE","IEEE Conferences"
"Teaching software quality via source code inspection tool","P. H. de Andrade Gomes; R. E. Garcia; G. Spadon; D. M. Eler; C. Olivete; R. C. M. Correia","São Paulo State University (UNESP) Faculty of Science and Technology - Presidente Prudente, São Paulo, Brazil, Department of Mathematics and Computer Science - Presidente Prudente-SP, Brazil; São Paulo State University (UNESP) Faculty of Science and Technology - Presidente Prudente, São Paulo, Brazil, Department of Mathematics and Computer Science - Presidente Prudente-SP, Brazil; São Paulo State University (UNESP) Faculty of Science and Technology - Presidente Prudente, São Paulo, Brazil, Department of Mathematics and Computer Science - Presidente Prudente-SP, Brazil; São Paulo State University (UNESP) Faculty of Science and Technology - Presidente Prudente, São Paulo, Brazil, Department of Mathematics and Computer Science - Presidente Prudente-SP, Brazil; São Paulo State University (UNESP) Faculty of Science and Technology - Presidente Prudente, São Paulo, Brazil, Department of Mathematics and Computer Science - Presidente Prudente-SP, Brazil; São Paulo State University (UNESP) Faculty of Science and Technology - Presidente Prudente, São Paulo, Brazil, Department of Mathematics and Computer Science - Presidente Prudente-SP, Brazil","2017 IEEE Frontiers in Education Conference (FIE)","","2017","","","1","8","Software Quality Assurance is a sub-process that ensures that developed software meets and complies with defined or standardized quality specifications. Focusing on source code, there are characteristics that can be used to evaluate the quality. Introductory courses must encourage freshmen students to improve internal quality of their source code, but only as sophomore they have contact with Software Engineering concepts, including Quality Assurance. In this paper we present a tool to source code quality evaluation aimed at supporting students to improve their source code and, consequently, their programming skills. The proposed tool uses quality reports (available to professional environment integrate with software repositories) to analyze students' source code and provide a feedback about the student coding. The proposed tool run locally, with few computational resources. In addition, we proposed the methodology to use the proposed tool: it consists of challenging students to perform a set of maintenance tasks in a controlled environment. We prepared a source code by introducing common defects, what decreases the quality of source code, and ask to students to perform maintenance tasks in order to both eliminate the introduced defects and introduce new features. After each modification, the students must evaluate their code using the proposed tool to obtain a feedback about quality of source code. To evaluate the approach and the tool, we created a survey and applied to students and the teacher. As a result, we show the benefits of using the proposed tool to both teachers and students perspectives. The results are positive to enhance the teaching-learning Software Quality Assurance to Software Engineering students.","","978-1-5090-5920-1978-1-5090-5919-5978-1-5090-4920","10.1109/FIE.2017.8190658","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8190658","","Tools;Maintenance engineering;Computer bugs;Inspection;Software quality;Servers","computer aided instruction;computer science education;educational courses;educational institutions;engineering education;inspection;programming;software maintenance;software quality;teaching","quality reports;student coding;Software Engineering students;source code inspection tool;standardized quality specifications;internal quality;source code quality evaluation;Software Quality Assurance teaching;Software Quality Assurance learning;software quality teaching;source code quality;programming skills","","","30","","","","","","IEEE","IEEE Conferences"
"Code review analysis of software system using machine learning techniques","H. Lal; G. Pahwa","Aricent, Gurgaon, India; Aricent, Gurgaon, India","2017 11th International Conference on Intelligent Systems and Control (ISCO)","","2017","","","8","13","Code review is systematic examination of a software system's source code. It is intended to find mistakes overlooked in the initial development phase, improving the overall quality of software and reducing the risk of bugs among other benefits. Reviews are done in various forms such as pair programming, informal walk-through, and formal inspections. Code review has been found to accelerate and streamline the process of software development like very few other practices in software development can. In this paper we propose a machine learning approach for the code reviews in a software system. This would help in faster and a cleaner reviews of the checked in code. The proposed approach is evaluated for feasibility on an open source system eclipse. [1], [2], [3].","","978-1-5090-2717-0978-1-5090-2718","10.1109/ISCO.2017.7855962","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7855962","Code Review;Software development process;Machine learning","Computer bugs;Software systems;Data models;Control systems;Predictive models;Standards","formal specification;learning (artificial intelligence);program diagnostics;public domain software;software quality","code review analysis;software system;machine learning techniques;source code;software quality;pair programming;informal walk-through;formal inspections;open source system eclipse","","1","19","","","","","","IEEE","IEEE Conferences"
"Supporting Automatic Code Review via Design","J. He; L. Wang; J. Zhao","NA; NA; NA","2013 IEEE Seventh International Conference on Software Security and Reliability Companion","","2013","","","211","218","Code review is a very important means to ensure the quality of code in practice. It has been widely used in industry since it was proposed. Nowadays code review is still mainly done by manual work in industry. However, increasing scale of the software challenges manual reviewing. So automating the code review process is highly desired. Design patterns are a set of summaries of code design experiences that are widely used repeatedly, and well classified. Programmers need to correctly implement code based on design patterns. To ensure that the code is implemented as expected, this paper proposes an approach to automatically review code in the view of specified design patterns. Firstly, we identify the design patterns that are specified in the design models. Second, we construct a set of review rules by extracting design constraints from identified design patterns. Last, the code is checked against the generated review rules, and inconsistencies are reported as result. A supporting tool was developed, and two experiments were conducted to demonstrate the applicability of our approach.","","978-1-4799-2925-2978-1-4799-2924","10.1109/SERE-C.2013.37","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6616346","Code Review;Design pattern;UML;Abstract Syntax Tree","Unified modeling language;Software;Abstracts;Syntactics;Concrete;XML;Java","software architecture;software quality;software reviews","automatic code review process;manual reviewing;design patterns;design constraint extraction;software quality","","","14","","","","","","IEEE","IEEE Conferences"
"When Does a Refactoring Induce Bugs? An Empirical Study","G. Bavota; B. De Carluccio; A. De Lucia; M. Di Penta; R. Oliveto; O. Strollo","NA; NA; NA; NA; NA; NA","2012 IEEE 12th International Working Conference on Source Code Analysis and Manipulation","","2012","","","104","113","Refactorings are - as defined by Fowler - behavior preserving source code transformations. Their main purpose is to improve maintainability or comprehensibility, or also reduce the code footprint if needed. In principle, refactorings are defined as simple operations so that are ""unlikely to go wrong"" and introduce faults. In practice, refactoring activities could have their risks, as other changes. This paper reports an empirical study carried out on three Java software systems, namely Apache Ant, Xerces, and Ar-go UML, aimed at investigating to what extent refactoring activities induce faults. Specifically, we automatically detect (and then manually validate) 15,008 refactoring operations (of 52 different kinds) using an existing tool (Ref-Finder). Then, we use the SZZ algorithm to determine whether it is likely that refactorings induced a fault. Results indicate that, while some kinds of refactorings are unlikely to be harmful, others, such as refactorings involving hierarchies (e.g., pull up method), tend to induce faults very frequently. This suggests more accurate code inspection or testing activities when such specific refactorings are performed.","","978-0-7695-4783-1978-1-4673-2398","10.1109/SCAM.2012.20","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6392107","Refactoring;Fault-inducing changes;Mining software repositories;Empirical Studies","Computer bugs;Software systems;Java;Data mining;Context;Software algorithms","program debugging","refactoring induce bugs;empirical study;source code transformations;Java software systems;Apache Ant;Xerces;Argo UML;code inspection;testing activities","","33","24","","","","","","IEEE","IEEE Conferences"
"Search-Based Peer Reviewers Recommendation in Modern Code Review","A. Ouni; R. G. Kula; K. Inoue","NA; NA; NA","2016 IEEE International Conference on Software Maintenance and Evolution (ICSME)","","2016","","","367","377","Code review is of primary importance in modern software development. It is widely recognized that peer review is an efficient and effective practice for improving software quality and reducing defect proneness. For successful review process, peer reviewers should have a deep experience and knowledge with the code being reviewed, and familiar to work and collaborate together. However, one of the main challenging tasks in modern code review is to find the most appropriate reviewers for submitted code changes. So far, reviewers assignment is still a manual, costly and time-consuming task. In this paper, we introduce a search-based approach, namely RevRec, to provide decision-making support for code change submitters and/or reviewers assigners to identify most appropriate peer reviewers for their code changes. RevRec aims at finding reviewers to be assigned for a code change based on their expertise and collaboration in past reviews using genetic algorithm (GA). We evaluated our approach on a benchmark of three open-source software systems, Android, OpenStack, and Qt. Results indicate that RevRec accurately recommends code reviewers with up to 59% of precision and 74% of recall. Our experiments provide evidence that leveraging reviewers expertise from their prior reviews and the socio-technical aspects of the team work and collaboration is relevant in improving the performance of peer reviewers recommendation in modern code review.","","978-1-5090-3806-0978-1-5090-3807","10.1109/ICSME.2016.65","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7816482","Code review;Reviewer recommendation;Search-based Software Engineeging","Search problems;Genetic algorithms;Software;Software engineering;Teamwork;Sociology","Android (operating system);decision making;genetic algorithms;public domain software;search problems;software quality;software reviews;source code (software);team working","search-based peer reviewer recommendation;code review;software development;peer review;software quality;search-based approach;RevRec;decision making support;genetic algorithm;open-source software systems;Android;OpenStack;team work socio-technical aspects;precision;recall;Qt","","3","41","","","","","","IEEE","IEEE Conferences"
"Evaluating how static analysis tools can reduce code review effort","D. Singh; V. R. Sekar; K. T. Stolee; B. Johnson","Department of Computer Science, North Carolina State University; Department of Computer Science, North Carolina State University; Department of Computer Science, North Carolina State University; College of Information and Computer Science, University of Massachusetts, Amherst","2017 IEEE Symposium on Visual Languages and Human-Centric Computing (VL/HCC)","","2017","","","101","105","Peer code reviews are important for giving and receiving peer feedback, but the code review process is time consuming. Static analysis tools can help reduce reviewer effort by catching common mistakes prior to peer code review. Ideally, contributors would use static analysis tools prior to pull request submission so common mistakes could be addressed first, before invoking the reviewer. To explore the potential efficiency gains for peer reviewers, we explore the overlap between reviewer comments on pull requests and warnings from the PMD static analysis tool. In an empirical study of 274 comments from 92 pull requests on GitHub, we observed that PMD overlapped with nearly 16% of the reviewer comments, indicating a time benefit to the reviewer if static analyzers would have been used prior to pull request submission. Using the non-overlapping set of comments, we identify four additional rules that, if implemented, could further reduce reviewer effort.","1943-6106","978-1-5386-0443-4978-1-5386-0444","10.1109/VLHCC.2017.8103456","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8103456","","Tools;Standards;Encoding;Java;Visualization;Manuals","program diagnostics;public domain software","static analysis tools;code review effort;peer code reviews;code review process;peer reviewers;reviewer comments;PMD static analysis tool;static analyzers;pull requests;GitHub","","1","24","","","","","","IEEE","IEEE Conferences"
"A Faceted Classification Scheme for Change-Based Industrial Code Review Processes","T. Baum; O. Liskin; K. Niklas; K. Schneider","NA; NA; NA; NA","2016 IEEE International Conference on Software Quality, Reliability and Security (QRS)","","2016","","","74","85","Code review in the industry today is different to code review twenty years ago. The process has become more lightweight, reviews are performed frequently and change-based and the use of specialized tools is increasing. An accurate view of the current state of the industrial practice is an indispensable foundation for improving it. Most recent descriptions of review practices come from a limited population of large hightech companies. Therefore, we used interviews with software engineering professionals from a broad sample of 19 companies to gain insight into their code review practices. We augmented our findings with data for 11 companies found through a semisystematic literature review. There are many commonalities in the code review processes of these companies, but also a lot of variation in the details. A simple process taxonomy cannot describe these variations adequately. Therefore, we present a faceted classification scheme that is grounded in our observations.","","978-1-5090-4127-5978-1-5090-4128","10.1109/QRS.2016.19","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7589787","Code Reviews;Code Inspections and Walkthroughs;Software Engineering Process;Empirical Software Engineering","Companies;Interviews;Software;Bibliographies;Inspection;Industries;Standards","pattern classification;software quality","faceted classification scheme;change-based industrial code review process;software engineering professionals;semisystematic literature review;process taxonomy","","8","38","","","","","","IEEE","IEEE Conferences"
"On the Optimal Order of Reading Source Code Changes for Review","T. Baum; K. Schneider; A. Bacchelli","NA; NA; NA","2017 IEEE International Conference on Software Maintenance and Evolution (ICSME)","","2017","","","329","340","Change-based code review, e.g., in the form of pull requests, is the dominant style of code review in practice. An important option to improve review's efficiency is cognitive support for the reviewer. Nevertheless, review tools present the change parts under review sorted in alphabetical order of file path, thus leaving the effort of understanding the construction, connections, and logic of the changes on the reviewer. This leads to the question: How should a code review tool order the parts of a code change to best support the reviewer? We answer this question with a middle-range theory, which we generated inductively in a mixed methods study, based on interviews, an online survey, and existing findings from related areas. Our results indicate that an optimal order is mainly an optimal grouping of the change parts by relatedness. We present our findings as a collection of principles and formalize them as a partial order relation among review orders.","","978-1-5386-0992-7978-1-5386-0993","10.1109/ICSME.2017.28","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8094433","Change-based code review;Modern code review;Pull-based development;Cognitive support review tools;Program comprehension","Interviews;Tools;Software;Navigation;Industries;Software engineering","program diagnostics;public domain software;software quality;source code (software)","optimal order;reviewer;review tools;change parts;alphabetical order;partial order relation;review orders;optimal grouping;middle-range theory;code review tool;review efficiency;change-based code review;source code change reading","","1","75","","","","","","IEEE","IEEE Conferences"
"A code inspection tool by mining recurring changes in evolving software","A. Fish; T. L. Nguyen; M. Song","Department of Computer Science, University of Nebraska, Omaha, NE, USA; Department of Computer Science, University of Nebraska, Omaha, NE, USA; Department of Computer Science, University of Nebraska, Omaha, NE, USA","2017 6th International Workshop on Software Mining (SoftwareMining)","","2017","","","48","51","Mining software repositories have frequently been investigated in recent research. Software modification in repositories are often recurring changes, similar but different changes across multiple locations. It is not easy for developers to find all the relevant locations to maintain such changes, including bug-fixes, new feature addition, and refactorings. Performing recurring changes is tedious and error-prone, resulting in in-consistent and missing updates. To address this problem, we present CloneMap, a clone-aware code inspection tool that helps developers ensure correctness of recurring changes to multiple locations in an evolving software. CloneMap allows developers to specify the old and new versions of a program. It then applies a clone detection technique to (1) mine repositories for extracting differences of recurring changes, (2) visualize the clone evolution, and (3) help developers focus their attention to potential anomalies, such as inconsistent and missing updates.","","978-1-5386-1389-4978-1-5386-1390","10.1109/SOFTWAREMINING.2017.8100853","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8100853","","Cloning;Tools;Software;Inspection;Data visualization;Data mining;Visualization","data mining;inspection;program debugging;program diagnostics;program visualisation;software maintenance","multiple locations;clone-aware code inspection tool;evolving software;software modification;software repositories mining;recurring changes mining;bug-fixes;refactorings;CloneMap;new feature addition;clone detection technique;clone visualization;inconsistent updates;missing updates","","","14","","","","","","IEEE","IEEE Conferences"
"Code Review Quality: How Developers See It","O. Kononenko; O. Baysal; M. W. Godfrey","NA; NA; NA","2016 IEEE/ACM 38th International Conference on Software Engineering (ICSE)","","2016","","","1028","1038","In a large, long-lived project, an effective code review process is key to ensuring the long-term quality of the code base. In this work, we study code review practices of a large, open source project, and we investigate how the developers themselves perceive code review quality. We present a qualitative study that summarizes the results from a survey of 88 Mozilla core developers. The results provide developer insights into how they define review quality, what factors contribute to how they evaluate submitted code, and what challenges they face when performing review tasks. We found that the review quality is primarily associated with the thoroughness of the feedback, the reviewer's familiarity with the code, and the perceived quality of the code itself. Also, we found that while different factors are perceived to contribute to the review quality, reviewers often find it difficult to keep their technical skills up-to-date, manage personal priorities, and mitigate context switching.","1558-1225","978-1-4503-3900-1978-1-5090-2071","10.1145/2884781.2884840","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886977","Code review;review quality;survey;developer perception","Software;Data mining;Computer science;Face;Computer bugs;Measurement;Electronic mail","software quality","effective code review process;long-term quality;Mozilla core developers;open source project","","6","32","","","","","","IEEE","IEEE Conferences"
"Evaluation of design and code revisions in academic practices of software engineering","L. B. Angarita; J. P. L. Tovar","Universidad Nacional de Colombia - Sede Manizales, Departamento de Informática y Computación, Manizales, Colombia; Universidad Nacional de Colombia - Sede Manizales, Departamento de Informática y Computación, Manizales, Colombia","2017 6th International Conference on Software Process Improvement (CIMPS)","","2017","","","1","8","Personal Software Process (PSP) is a process that develops individual skills in software engineers to control and improve the quality of their work practices. This paper presents an evaluative study on the effectiveness of design and code reviews includes into the PSP development activities. The study carried out with students of the Management Information Systems in National University of Colombia - Manizales. An experiment was designed to develop a program using PSP scripts forms standards and measures. The program was developed by two groups of students one group used the revisions and the other did not. Test hypotheses carried out show that there are no significant differences in the effectiveness of PSP code and design revisions compared to traditional development in which no revisions are made. However design and code reviews achieved to eliminate defects in the early stages effectively. This work benefits software engineers to know the effectiveness of design and code reviews from an empirical point of view.","","978-1-5386-3230-7978-1-5386-3229-1978-1-5386-3231","10.1109/CIMPS.2017.8169951","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8169951","Personal software process;design review;code review","Software;Software engineering;Process control;Silicon compounds;Management information systems;Standards;Knowledge engineering","computer science education;management information systems;software process improvement;standards","PSP development activities;Management Information Systems;measures;design revisions;traditional development;code reviews;software engineers;code revisions;academic practices;software engineering;evaluative study;PSP code;test hypothesis;standards;PSP scripts;Manizales;National University of Colombia;work practice quality;personal software process;design evaluation","","","","","","","","","IEEE","IEEE Conferences"
"Lessons Learned from Building and Deploying a Code Review Analytics Platform","C. Bird; T. Carnahan; M. Greiler","NA; NA; NA","2015 IEEE/ACM 12th Working Conference on Mining Software Repositories","","2015","","","191","201","Tool-based code review is growing in popularity and has become a standard part of the development process at Mi-crosoft. Adoption of these tools makes it possible to mine data from code reviews and provide access to it. In this paper, we pre-sent an experience report for CodeFlow Analytics, a system that collects code review data, generates metrics from this data, and provides a number of ways for development teams to access the metrics and data. We discuss the design, design decisions and chal-lenges that we encountered when building CodeFlow Analytics. We contacted teams that used CodeFlow Analytics over the past two years and discuss what prompted them to use CodeFlow Ana-lytics, how they have used it, and what the impact has been. Fur-ther, we survey research that has been enabled by using the Code-Flow Analytics platform. We provide a series of lessons learned from this experience to help others embarking on a task of building an analytics platform in an enterprise setting.","2160-1852;2160-1860","978-0-7695-5594","10.1109/MSR.2015.25","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7180079","","Measurement;Interviews;Databases;Software;Servers;Computational modeling;Data mining","data mining;program diagnostics","code review analytics platform;tool-based code review;Microsoft;data mining;CodeFlow analytics;design decisions;enterprise setting;analytics platform","","5","29","","","","","","IEEE","IEEE Conferences"
"Do code review practices impact design quality? A case study of the Qt, VTK, and ITK projects","R. Morales; S. McIntosh; F. Khomh","SWAT, Polytechnique Montr&#x00E9;al, Canada; School of Computing, Queen's University, Canada; SWAT, Polytechnique Montr&#x00E9;al, Canada","2015 IEEE 22nd International Conference on Software Analysis, Evolution, and Reengineering (SANER)","","2015","","","171","180","Code review is the process of having other team members examine changes to a software system in order to evaluate its technical content and quality. A lightweight variant of this practice, often referred to as Modern Code Review (MCR), is widely adopted by software organizations today. Previous studies have established a relation between the practice of code review and the occurrence of post-release bugs. While the prior work studies the impact of code review practices on software release quality, it is still unclear what impact code review practices have on software design quality. Therefore, using the occurrence of 7 different types of anti-patterns (i.e., poor solutions to design and implementation problems) as a proxy for software design quality, we set out to investigate the relationship between code review practices and software design quality. Through a case study of the Qt, VTK and ITK open source projects, we find that software components with low review coverage or low review participation are often more prone to the occurrence of anti-patterns than those components with more active code review practices.","1534-5351","978-1-4799-8469","10.1109/SANER.2015.7081827","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7081827","","Software systems;Measurement;Analytical models;Software design;Complexity theory;Correlation","object-oriented programming;software quality","code review practice;software design quality;Qt project;VTK project;ITK project;software system;modern code review;post-release bugs;software release quality;open source project;software components","","22","42","","","","","","IEEE","IEEE Conferences"
"Code review: Veni, ViDI, vici","Y. Tymchuk; A. Mocci; M. Lanza","REVEAL @ Faculty of Informatics - University of Lugano, Switzerland; REVEAL @ Faculty of Informatics - University of Lugano, Switzerland; REVEAL @ Faculty of Informatics - University of Lugano, Switzerland","2015 IEEE 22nd International Conference on Software Analysis, Evolution, and Reengineering (SANER)","","2015","","","151","160","Modern software development sees code review as a crucial part of the process, because not only does it facilitate the sharing of knowledge about the system at hand, but it may also lead to the early detection of defects, ultimately improving the quality of the produced software. Although supported by numerous approaches and tools, code review is still in its infancy, and indeed researchers have pointed out a number of shortcomings in the state of the art. We present a critical analysis of the state of the art of code review tools and techniques, extracting a set of desired features that code review tools should possess. We then present our vision and initial implementation of a novel code review approach named Visual Design Inspection (ViDI), illustrated through a set of usage scenarios. ViDI is based on a combination of visualization techniques, design heuristics, and static code analysis techniques.","1534-5351","978-1-4799-8469","10.1109/SANER.2015.7081825","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7081825","","Feature extraction;Visualization;Birds;Software quality;Navigation;Inspection","program diagnostics;program visualisation;software quality","software development;knowledge sharing;defect detection;software quality;code review tools;code review techniques;visual design inspection;ViDI;visualization techniques;design heuristics;static code analysis technique","","1","24","","","","","","IEEE","IEEE Conferences"
"ICICLE: Intelligent code inspection in a C language environment","V. Sembugamoorthy; L. Brothers","Bellcore, Piscataway, NJ, USA; Bellcore, Piscataway, NJ, USA","Proceedings., Fourteenth Annual International Computer Software and Applications Conference","","1990","","","146","154","Attention is given to ICICLE (intelligent code inspection in a C language environment), an intelligent assistant that augments manual code inspection by providing a rule-based static-debugging tool, hypertext-based browsers for referring to various kinds of knowledge associated with code inspection (e.g., the application domain knowledge and the knowledge of the programming environment), a powerful human interface for preparing comments on the code under inspection, and a CSCW (computer-supported cooperative work) platform for conducting code inspection meetings. ICICLE has been prototyped on UNIX workstations using a commercial multi-paradigm expert system shell and a window package for implementing CSCW. The initial prototype has been significantly enhanced based on the feedback from extensive videotaped usability testing sessions which used a real-world application. It is currently being used for live code inspection by an initial user organization. The goals, the approach, the architecture, the main components, the usability testing, and the future directions of ICICLE are described.<<ETX>>","","0-8186-2054","10.1109/CMPSAC.1990.139343","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=139343","","Inspection;Prototypes;Usability;Testing;Application software;Programming environments;Humans;Computer interfaces;Collaborative work;Workstations","C language;expert systems;groupware;hypermedia;program debugging;software tools;user interfaces","C language environment;ICICLE;intelligent code inspection;intelligent assistant;rule-based static-debugging tool;hypertext-based browsers;application domain knowledge;human interface;CSCW;computer-supported cooperative work;UNIX workstations;multi-paradigm expert system shell;usability testing sessions","","4","20","","","","","","IEEE","IEEE Conferences"
"When Testing Meets Code Review: Why and How Developers Review Tests","D. Spadini; M. Aniche; M. Storey; M. Bruntink; A. Bacchelli","NA; NA; NA; NA; NA","2018 IEEE/ACM 40th International Conference on Software Engineering (ICSE)","","2018","","","677","687","Automated testing is considered an essential process for ensuring software quality. However, writing and maintaining high-quality test code is challenging and frequently considered of secondary importance. For production code, many open source and industrial software projects employ code review, a well-established software quality practice, but the question remains whether and how code review is also used for ensuring the quality of test code. The aim of this research is to answer this question and to increase our understanding of what developers think and do when it comes to reviewing test code. We conducted both quantitative and qualitative methods to analyze more than 300,000 code reviews, and interviewed 12 developers about how they review test files. This work resulted in an overview of current code reviewing practices, a set of identified obstacles limiting the review of test code, and a set of issues that developers would like to see improved in code review tools. The study reveals that reviewing test files is very different from reviewing production files, and that the navigation within the review itself is one of the main issues developers currently face. Based on our findings, we propose a series of recommendations and suggestions for the design of tools and future research.","1558-1225","978-1-4503-5638-1978-1-5386-5293","","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453136","software testing;automated testing;code review;Gerrit","Production;Computer bugs;Testing;Tools;Software quality;Measurement","program testing;software quality","developer review tests;code review tools;current code reviewing practices;review test files;software quality practice;production code;high-quality test code;automated testing","","","","","","","","","IEEE","IEEE Conferences"
"Exploring the usability and effectiveness of interactive annotation and code review for the detection of security vulnerabilities","T. Thomas","Department of Software and Information Systems, University of North Carolina at Charlotte, 28223, USA","2015 IEEE Symposium on Visual Languages and Human-Centric Computing (VL/HCC)","","2015","","","295","296","According to a recent IBM study, the average cost for a stolen record raised 9% to $145 in 2014. Since millions of credit card records are stolen every year, the cost can easily run into billions of dollars. Consequently, application security is a very important concern during the development of applications today. Resolving security problems later in the development process is very time consuming and expensive. Therefore, it is favorable to detect and resolve security vulnerabilities as soon as possible during the development process. By using a technique called static analysis, it is possible to partially overcome this problem. Static analysis tools examine source code statically (when not running), and attempt to detect security vulnerabilities. Unfortunately, however, static analysis tools generate very large amounts of false positives. In order for static analysis tools to be effective, extraordinarily complex custom rules must be written for the tool. This must be done by a security expert for every application the tool runs on. To make matters worse, communicating information about complex vulnerabilities to application developers presents a unique challenge in and of itself. If the developer does not understand why a certain line is flagged as potentially vulnerable and is not provided with detailed information, it will be far more difficult for him or her to resolve the problem. Consequently, static analysis tools are seldom used.","","978-1-4673-7457-6978-1-4673-7456","10.1109/VLHCC.2015.7357234","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7357234","","","feature extraction;program diagnostics;security of data;software reviews;source code (software)","interactive annotation;source code review;security vulnerability detection;static analysis","","","10","","","","","","IEEE","IEEE Conferences"
"Applying source code analysis techniques: A case study for a large mission-critical software system","H. Haralambiev; S. Boychev; D. Lilov; K. Kraichev","Applied Research and Development Center, Musala Soft, Sofia, Bulgaria; Applied Research and Development Center, Musala Soft, Sofia, Bulgaria; Applied Research and Development Center, Musala Soft, Sofia, Bulgaria; Applied Research and Development Center, Musala Soft, Sofia, Bulgaria","2011 IEEE EUROCON - International Conference on Computer as a Tool","","2011","","","1","2","Source code analysis has been and still is extensively researched topic with various applications to the modern software industry. In this paper we share our experience in applying various source code analysis techniques for assessing the quality of and detecting potential defects in a large mission-critical software system. The case study is about the maintenance of a software system of a Bulgarian government agency. The system has been developed by a third-party software vendor over a period of four years. The development produced over 4 million LOC using more than 20 technologies. Musala Soft won a tender for maintaining this system in 2008. Although the system was operational, there were various issues that were known to its users. So, a decision was made to assess the system's quality with various source code analysis tools. The expectation was that the findings will reveal some of the problems' cause, allowing us to correct the issues and thus improve the quality and focus on functional enhancements. Musala Soft had already established a special unit - Applied Research and Development Center - dealing with research and advancements in the area of software system analysis. Thus, a natural next step was for this unit to use the know-how and in-house developed tools to do the assessment. The team used various techniques that had been subject to intense research, more precisely: software metrics, code clone detection, defect and “code smells” detection through flow-sensitive and points-to analysis, software visualization and graph drawing. In addition to the open-source and free commercial tools, the team used internally developed ones that complement or improve what was available. The internally developed Smart Source Analyzer platform that was used is focused on several analysis areas: source code modeling, allowing easy navigation through the code elements and relations for different programming languages; quality audit through software metrics by aggregating various metrics into a more meaningful quality characteristic (e.g. “maintainability”); source code pattern recognition - to detect various security issues and “code smells”. The produced results presented information about both the structure of the system and its quality. As the analysis was executed in the beginning of the maintenance tenure, it was vital for the team members to quickly grasp the architecture and the business logic. On the other hand, it was important to review the detected quality problems as this guided the team to quick solutions for the existing issues and also highlighted areas that would impede future improvements. The tool IPlasma and its System Complexity View (Fig. 1) revealed where the business logic is concentrated, which are the most important and which are the most complex elements of the system. The analysis with our internal metrics framework (Fig. 2) pointed out places that need refactoring because the code is hard to modify on request or testing is practically impossible. The code clone detection tools showed places where copy and paste programming has been applied. PMD, Find Bugs and Klockwork Solo tools were used to detect various “code smells” (Fig. 3). There were a number of occurrences that were indeed bugs in the system. Although these results were productive for the successful execution of the project, there were some challenges that should be addressed in the future through more extensive research. The two aspects we consider the most important are usability and integration. As most of the tools require very deep understanding of the underlying analysis, the whole process requires tight cooperation between the analysis team and the maintenance team. For example, most of the metrics tools available provide specific values for a given metric without any indication what the value means and what is the threshold. Our internal metrics framework aggregates the metrics into meaningful quality characteristics, which solves the issue partially. However, the user still often wonders about the justification behind the meaning of the given quality characteristic. There is a need for an explanation system - one, which could point out the source code elements and explain why they are considered good or bad. The integration aspect is considered important because such analysis should be performed continuously. In our experience, the analysis is usually performed subsequent to an important event - in this case: beginning of maintenance tenure. Some quality assurance practices should be developed and then adopted by the development teams so that the implementation quality is checked continuously. This should cover various activities and instruments, such as the integrated development environment, the code review process, automated builds, etc. In conclusion, we think that implementation quality audit and management is a vital activity that should be integrated into the software development process and the tools that support it should be usable by the development team members without much knowledge of the underlying analysis. In this paper we presented a case study that showed the benefits of such a process.","","978-1-4244-7487-5978-1-4244-7486-8978-1-4244-7485","10.1109/EUROCON.2011.5929241","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5929241","source code analysis;software maintenance;case study;software metrics;implementation quality","Maintenance engineering;Software systems;Cloning;Software metrics;Research and development","DP industry;pattern recognition;public domain software;security of data;software maintenance;software metrics;software quality;software tools;source coding","source code analysis;software industry;mission critical software system;software system maintenance;Bulgarian government agency;third party software vendor;applied research and development center;software metrics;code clone detection;code smells detection;software visualization;graph drawing;open source tool;smart source analyzer;programming language;source code pattern recognition;security issue;business logic;system complexity;IPlasma;PMD;findbug tool;klockwork solo tool;quality characteristic;quality assurance;implementation quality audit;software development","","","","","","","","","IEEE","IEEE Conferences"
"The Impact of Design and Code Reviews on Software Quality: An Empirical Study Based on PSP Data","C. F. Kemerer; M. C. Paulk","University of Pittsburgh, Pittsburgh; Carnegie Mellon University, Pittsburgh","IEEE Transactions on Software Engineering","","2009","35","4","534","550","This research investigates the effect of review rate on defect removal effectiveness and the quality of software products, while controlling for a number of potential confounding factors. Two data sets of 371 and 246 programs, respectively, from a personal software process (PSP) approach were analyzed using both regression and mixed models. Review activities in the PSP process are those steps performed by the developer in a traditional inspection process. The results show that the PSP review rate is a significant factor affecting defect removal effectiveness, even after accounting for developer ability and other significant process variables. The recommended review rate of 200 LOC/hour or less was found to be an effective rate for individual reviews, identifying nearly two-thirds of the defects in design reviews and more than half of the defects in code reviews.","0098-5589;1939-3520;2326-3881","","10.1109/TSE.2009.27","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4815279","Code reviews;design reviews;inspections;software process;software quality;defects;software measurement;mixed models;personal software process (PSP).","Software quality;Inspection;Business continuity;Software performance;Computer Society;Lab-on-a-chip;Software design;Software measurement;Costs;Job shop scheduling","program debugging;program testing;regression analysis;software metrics;software process improvement;software quality","design review impact;code review impact;software product quality;empirical study;PSP review rate;personal software process improvement approach;defect removal effectiveness;regression model;mixed model;inspection process;software measurement;business chain reaction","","39","55","","","","","","IEEE","IEEE Journals & Magazines"
"Teaching the process of code review","T. Stalhane; C. Kutay; H. Al-Kilidar; R. Jeffery","Norwegian Univ. of Sci. & Technol., Norway; NA; NA; NA","2004 Australian Software Engineering Conference. Proceedings.","","2004","","","271","278","Behavioural theory predicts that interventions that improve individual reviewers' expertise also improve the performance of the group in Software Development Technical Reviews (SDTR) [C. Sauer et al.,(2000)]. This includes improvements both in individual's expertise in the review process, as well as their ability to find defects and distinguish true defects from false positives. We present findings from University training in these skills using authentic problems. The first year the course was run it was designed around actual code review sessions, the second year this was expanded to enable students to develop and trial their own generic process for document reviews. This report considers the values and shortcomings of the teaching program from an extensive analysis of the defect detection in the first year, when students were involved in a review process that was set up for them, and student feedback from the second year when students developed and analysed their own process.","","0-7695-2089","10.1109/ASWEC.2004.1290480","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1290480","","Education;Inspection;Australia;Programming;Computer science;Feedback;Meetings;Java;Software engineering;Information analysis","formal verification;training;teaching;educational courses;educational institutions","behavioural theory;software development;technical reviews;University training;authentic problem;document review;teaching;defect detection analysis;code review","","2","19","","","","","","IEEE","IEEE Conferences"
"Who should review this change?: Putting text and file location analyses together for more accurate recommendations","X. Xia; D. Lo; X. Wang; X. Yang","College of Computer Science and Technology, Zhejiang University, Hangzhou, China; School of Information Systems, Singapore Management University, Singapore; College of Computer Science and Technology, Zhejiang University, Hangzhou, China; College of Computer Science and Technology, Zhejiang University, Hangzhou, China","2015 IEEE International Conference on Software Maintenance and Evolution (ICSME)","","2015","","","261","270","Software code review is a process of developers inspecting new code changes made by others, to evaluate their quality and identify and fix defects, before integrating them to the main branch of a version control system. Modern Code Review (MCR), a lightweight and tool-based variant of conventional code review, is widely adopted in both open source and proprietary software projects. One challenge that impacts MCR is the assignment of appropriate developers to review a code change. Considering that there could be hundreds of potential code reviewers in a software project, picking suitable reviewers is not a straightforward task. A prior study by Thongtanunam et al. showed that the difficulty in selecting suitable reviewers may delay the review process by an average of 12 days. In this paper, to address the challenge of assigning suitable reviewers to changes, we propose a hybrid and incremental approach Tie which utilizes the advantages of both Text mIning and a filE location-based approach. To do this, Tie integrates an incremental text mining model which analyzes the textual contents in a review request, and a similarity model which measures the similarity of changed file paths and reviewed file paths. We perform a large-scale experiment on four open source projects, namely Android, OpenStack, QT, and LibreOffice, containing a total of 42,045 reviews. The experimental results show that on average Tie can achieve top-1, top-5, and top-10 accuracies, and Mean Reciprocal Rank (MRR) of 0.52, 0.79, 0.85, and 0.64 for the four projects, which improves the state-of-the-art approach RevFinder, proposed by Thongtanunam et al., by 61%, 23%, 8%, and 37%, respectively.","","978-1-4673-7532-0978-1-4673-7531","10.1109/ICSM.2015.7332472","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7332472","Modern Code Review;Recommendation System;Text Mining;Path Similarity","Text mining;Software;Computational modeling;Feature extraction;Analytical models;Accuracy;Control systems","configuration management;data mining;public domain software;text analysis","software code review;modern code review;MCR;open source;software project;filE location-based approach;TIE;text mining model;textual content analysis;Android;OpenStack;QT;LibreOffice;mean reciprocal rank;MRR;version control system","","13","36","","","","","","IEEE","IEEE Conferences"
"A tool for authoring programs that automatically distribute feedback to novice programmers","M. Ichinco; Y. Dosouto; C. Kelleher","Dept. of Computer Science and Engineering Washington University in St. Louis St. Louis, MO, USA; School of Computing and Information Sciences Florida International University Miami, FL, USA; Dept. of Computer Science and Engineering Washington University in St. Louis St. Louis, MO, USA","2014 IEEE Symposium on Visual Languages and Human-Centric Computing (VL/HCC)","","2014","","","207","208","One way to provide feedback to independent novice programmers is by leveraging experienced programmers as code reviewers. To provide this feedback at a large scale, experienced programmers can author heuristic programs, or rules, that automatically determine whether a novice program should receive certain feedback. This work presents the lessons learned from designing a tool to enable rule authoring.","1943-6092;1943-6106","978-1-4799-4035","10.1109/VLHCC.2014.6883058","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6883058","crowdsourcing;code review;novice programming","Educational institutions;Programming;Testing;Programming environments;Syntactics;Standards;Documentation","authoring systems;computer science education;programming","authoring program tool;automatic feedback distribution;novice programmers;code reviewers;experienced programmers;heuristic programs","","","3","","","","","","IEEE","IEEE Conferences"
"Interactive Code Review for Systematic Changes","T. Zhang; M. Song; J. Pinedo; M. Kim","NA; NA; NA; NA","2015 IEEE/ACM 37th IEEE International Conference on Software Engineering","","2015","1","","111","122","Developers often inspect a diff patch during peer code reviews. Diff patches show low-level program differences per file without summarizing systematic changes -- similar, related changes to multiple contexts. We present Critics, an interactive approach for inspecting systematic changes. When a developer specifies code change within a diff patch, Critics allows developers to customize the change template by iteratively generalizing change content and context. By matching a generalized template against the codebase, it summarizes similar changes and detects potential mistakes. We evaluated Critics using two methods. First, we conducted a user study at Salesforce.com, where professional engineers used Critics to investigate diff patches authored by their own team. After using Critics, all six participants indicated that they would like Critics to be integrated into their current code review environment. This also attests to the fact that Critics scales to an industry-scale project and can be easily adopted by professional engineers. Second, we conducted a user study where twelve participants reviewed diff patches using Critics and Eclipse diff. The results show that human subjects using Critics answer questions about systematic changes 47.3% more correctly with 31.9% saving in time during code review tasks, in comparison to the baseline use of Eclipse diff. These results show that Critics should improve developer productivity in inspecting systematic changes during peer code reviews.","0270-5257;1558-1225","978-1-4799-1934","10.1109/ICSE.2015.33","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194566","","Systematics;Context;Switches;Interviews;Software;Syntactics;Data mining","software engineering;software reviews;source code (software)","peer code review;software development;systematic change;interactive code review;Critics","","17","44","","","","","","IEEE","IEEE Conferences"
"Reducing human effort and improving quality in peer code reviews using automatic static analysis and reviewer recommendation","V. Balachandran","VMware, Bangalore, India","2013 35th International Conference on Software Engineering (ICSE)","","2013","","","931","940","Peer code review is a cost-effective software defect detection technique. Tool assisted code review is a form of peer code review, which can improve both quality and quantity of reviews. However, there is a significant amount of human effort involved even in tool based code reviews. Using static analysis tools, it is possible to reduce the human effort by automating the checks for coding standard violations and common defect patterns. Towards this goal, we propose a tool called Review Bot for the integration of automatic static analysis with the code review process. Review Bot uses output of multiple static analysis tools to publish reviews automatically. Through a user study, we show that integrating static analysis tools with code review process can improve the quality of code review. The developer feedback for a subset of comments from automatic reviews shows that the developers agree to fix 93% of all the automatically generated comments. There is only 14.71% of all the accepted comments which need improvements in terms of priority, comment message, etc. Another problem with tool assisted code review is the assignment of appropriate reviewers. Review Bot solves this problem by generating reviewer recommendations based on change history of source code lines. Our experimental results show that the recommendation accuracy is in the range of 60%-92%, which is significantly better than a comparable method based on file change history.","0270-5257;1558-1225","978-1-4673-3076-3978-1-4673-3073","10.1109/ICSE.2013.6606642","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6606642","","Encoding;Standards;Java;History;Software;Algorithm design and analysis;Inspection","program diagnostics;program testing;software engineering","quality improvement;peer code review;automatic static analysis;reviewer recommendation;cost-effective software defect detection technique;tool assisted code review;static analysis tools;coding standard violation checking automation;defect pattern;Review Bot tool;developer feedback;comment message;source code line change history;file change history","","36","24","","","","","","IEEE","IEEE Conferences"
"Modern Code Review: A Case Study at Google","C. Sadowski; E. Söderberg; L. Church; M. Sipko; A. Bacchelli","NA; NA; NA; NA; NA","2018 IEEE/ACM 40th International Conference on Software Engineering: Software Engineering in Practice Track (ICSE-SEIP)","","2017","","","181","190","Employing lightweight, tool-based code review of code changes (aka modern code review) has become the norm for a wide variety of open-source and industrial systems. In this paper, we make an exploratory investigation of modern code review at Google. Google introduced code review early on and evolved it over the years; our study sheds light on why Google introduced this practice and analyzes its current status, after the process has been refined through decades of code changes and millions of code reviews. By means of 12 interviews, a survey with 44 respondents, and the analysis of review logs for 9 million reviewed changes, we investigate motivations behind code review at Google, current practices, and developers' satisfaction and challenges.","","978-1-4503-5659-6978-1-5386-6360","","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8449249","code review;developer tools;developer workflow;human factors;interviews;reviewer recommendation systems","Google;Tools;Inspection;Interviews;Software;Birds;Companies","","","","","44","","","","","","IEEE","IEEE Conferences"
"Diggit: Automated code review via software repository mining","R. Chatley; L. Jones","Imperial College London, 180 Queen's Gate, London, UK; GoCardless Ltd, 338-346 Goswell Road, London, UK","2018 IEEE 25th International Conference on Software Analysis, Evolution and Reengineering (SANER)","","2018","","","567","571","We present Diggit, a tool to automatically generate code review comments, offering design guidance on prospective changes, based on insights gained from mining historical changes in source code repositories. We describe how the tool was built and tuned for use in practice as we integrated Diggit into the working processes of an industrial development team. We focus on the developer experience, the constraints that had to be met in adapting academic research to produce a tool that was useful to developers, and the effectiveness of the results in practice.","","978-1-5386-4969-5978-1-5386-4970","10.1109/SANER.2018.8330261","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8330261","software maintenance;data mining","Tools;Market research;Complexity theory;Data mining;History;Software;Feathers","data mining;program compilers;software development management;software maintenance;software quality;source code (software);team working","source code repositories;industrial development team;Diggit;automated code review;code review comments;design guidance;software repository mining;historical changes mining","","","17","","","","","","IEEE","IEEE Conferences"
"Comparing Pre Commit Reviews and Post Commit Reviews Using Process Simulation","T. Baum; F. Kortum; K. Schneider; A. Brack; J. Schauder","NA; NA; NA; NA; NA","2016 IEEE/ACM International Conference on Software and System Processes (ICSSP)","","2016","","","26","35","Code review in practice is often performed change-based, i.e. using the code changes belonging to a task to determine which code to review. In previous studies, it was found that two variations of this process are used in industry: Pre commit review (review-then-commit) and post commit review (commit-then-review). The choice for one of these variants has implications not only for practitioners deciding on a code review process to use, but also for the development of review tools and for experimentation with review processes. In some situations, a specific variant is clearly preferable due to the nature of the development process or team. In other situations, there are conflicting opinions, and both variants have proponents arguing for their method of choice. So we asked: Are there practically relevant performance differences between pre commit and post commit reviews, and how are these differences influenced by contextual factors? To assess this question, we designed a parametric discrete event simulation model of certain agile development processes. We validated this model with practitioner's feedback and in part also with empirical data from industry. Our analysis of the simulation results indicates that the best choice does depend on the context, but also that there are many situations with no practically relevant difference between both choices. We identified the main influencing factors and underlying effects and condensed our findings into heuristic rules.","","978-1-4503-4188-2978-1-5090-2244","10.1109/ICSSP.2016.012","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7831532","Code review;Pre Commit Review;Post Commit Review;Agile Software Development;Discrete Event Simulation","Unified modeling language;Software;Data models;Context;Software engineering;Discrete event simulation","discrete event simulation;software prototyping;software reviews;source code (software)","precommit reviews;post commit reviews;process simulation;change-based code review;review-then-commit;commit-then-review;review tools;practitioner feedback;agile development processes;parametric discrete event simulation model","","","25","","","","","","IEEE","IEEE Conferences"
"The 9 quadrant model for code reviews","R. P. Nandivada; A. Chandra; S. Dutta; G. Keeni","Tata Consultancy Services, Hyderabad, India; NA; NA; NA","Proceedings First Asia-Pacific Conference on Quality Software","","2000","","","188","193","Discusses a decision-making model which can be used to determine the efficiency of a code review process. This model is based on statistical techniques such as control charts. The model has nine quadrants, each of which depicts a range of values of the cost and yield of a code review. The efficiency of the code review in detecting defects is determined by taking inputs from past data, in terms of the costs and yields of those code reviews. This estimate also provides an in-process decision-making tool. Other tools can be used effectively, in conjunction with this model, to plan for code reviews and to forecast the number of defects that could be expected in the reviews. This model can be successfully used to decide what the next step of the operational process should be. The decisions taken using this model help to reduce the number of defects present in the software delivered to the customer.","","0-7695-0825","10.1109/APAQ.2000.883792","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=883792","","Costs;Decision making;Testing;Control charts;Size measurement;Predictive models;Code standards;Scattering parameters;Performance evaluation","software quality;statistical analysis","9-quadrant model;code review process efficiency;decision-making model;software defect detection;statistical techniques;control charts;cost;yield;past data;in-process decision-making tool;code review planning;defect number forecasting","","1","3","","","","","","IEEE","IEEE Conferences"
"The development and evaluation of three diverse techniques for object-oriented code inspection","A. Dunsmore; M. Roper; M. Wood","Abbey Mill Bus. Centre, Formedix, Paisley, UK; NA; NA","IEEE Transactions on Software Engineering","","2003","29","8","677","686","We describe the development and evaluation of a rigorous approach aimed at the effective and efficient inspection of object-oriented (OO) code. Since the time that inspections were developed they have been shown to be powerful defect detection strategies. However, little research has been done to investigate their application to OO systems, which have very different structural and execution models compared to procedural systems. This suggests that inspection techniques may not be currently being deployed to their best effect in the context of large-scale OO systems. Work to date has revealed three significant issues that need to be addressed - the identification of chunks of code to be inspected, the order in which the code is read, and the resolution of frequent nonlocal references. Three techniques are developed with the aim of addressing these issues: one based on a checklist, one focused on constructing abstract specifications, and the last centered on the route that a use case takes through a system. The three approaches are evaluated empirically and, in this instance, it is suggested that the checklist is the most effective approach, but that the other techniques also have potential strengths. For the best results in a practical situation, a combination of techniques is recommended, one of which should focus specifically on the characteristics of OO.","0098-5589;1939-3520;2326-3881","","10.1109/TSE.2003.1223643","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1223643","","Inspection;Computer Society;Application software;Object oriented modeling;Power system modeling;Large-scale systems;Industrial control;Testing;Encapsulation;Libraries","inspection;software reviews;object-oriented programming;formal specification;software performance evaluation;software quality;program testing","software inspection technique;software quality evaluation;object-oriented code inspection;OO system;defect detection strategy;code chunk identification;nonlocal reference resolution;checklist technique;code review;abstract specification;use case technique;empirical study","","28","20","","","","","","IEEE","IEEE Journals & Magazines"
"Assessing MCR Discussion Usefulness Using Semantic Similarity","T. Pangsakulyanont; P. Thongtanunam; D. Port; H. Iida","NA; NA; NA; NA","2014 6th International Workshop on Empirical Software Engineering in Practice","","2014","","","49","54","Modern Code Review (MCR) is an informal practice whereby reviewers virtually discuss proposed changes by adding comments through a code review tool or mailing list. It has received much research attention due to its perceived cost-effectiveness and popularity with industrial and OSS projects. Recent studies indicate there is a positive relationship between the number of review comments and code quality. However, little research exists investigating how such discussion impacts software quality. The concern is that the informality of MCR encourages a focus on trivial, tangential, or unrelated issues. Indeed, we have observed that such comments are quite frequent and may even constitute the majority. We conjecture that an effective MCR actually depends on having a substantive quantity of comments that directly impact a proposed change (or are ""useful""). To investigate this, a necessary first step requires distinguishing review comments that are useful to a proposed change from those that are not. For a large OSS projects such as our Qt case study, manual assessment of the over 72,000 comments is a daunting task. We propose to utilize semantic similarity as a practical, cost efficient, and empirically assurable approach for assisting with the manual usefulness assessment of MCR comments. Our case study results indicate that our approach can classify comments with an average F-measure score of 0.73 and reduce comment usefulness assessment effort by about 77%.","","978-1-4799-6666","10.1109/IWESEP.2014.11","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6976022","Modern Code Review;Software Quality;Text Mining","Semantics;Manuals;Software quality;Training data;Training;Standards;Data models","data mining;semantic networks;software quality","MCR discussion usefulness;semantic similarity;modern code review;code review tool;mailing list;cost effectiveness;OSS projects;code quality;software quality;MCR comments;F-measure score;comment usefulness assessment","","7","10","","","","","","IEEE","IEEE Conferences"
"Interactively Decomposing Composite Changes to Support Code Review and Regression Testing","B. Guo; M. Song","NA; NA","2017 IEEE 41st Annual Computer Software and Applications Conference (COMPSAC)","","2017","1","","118","127","Developers often address multiple development issues to make composite code changes, as opposed to atomic changes that address one single issue. Investigating and testing such code changes is a tedious and error-prone process for developers. To address the problem, this paper presents a technique, called CHGCUTTER, for (1) interactively decomposing composite changes into atomic changes, (2) building related change subsets using program dependence relationships without syntactic violation, and (3) safely selecting only related test cases from the test suite to reduce the time to conduct regression testing. In the evaluation, CHGCUTTER analyzes 28 composite changes in four open source projects. It identifies related change subsets with 95.7% accuracy, and it selects test cases affected by these changes with 89.0% accuracy. Our results show that CHGCUTTER should help developers effectively inspect changes and validate modified applications during development.","0730-3157","978-1-5386-0367-3978-1-5386-0368","10.1109/COMPSAC.2017.153","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8029599","Code review;regression testing;software evolution;maintenance","Paints;Software;Testing;Syntactics;Bars;Control systems;Buildings","program testing;public domain software;regression analysis;software maintenance;source code (software)","code review;regression testing;composite code changes;atomic changes;CHGCUTTER;software development;open source projects;program dependence relationships","","","38","","","","","","IEEE","IEEE Conferences"
"Does the modern code inspection have value?","H. Siy; L. Votta","Lucent Technol., Naperville, IL, USA; NA","Proceedings IEEE International Conference on Software Maintenance. ICSM 2001","","2001","","","281","289","For years, it was believed that the value of inspections is in finding and fixing defects early in the development process. Otherwise, the cost to find and fix them later is much higher However in examining code inspection data, we are finding that inspections are beneficial for an additional reason. They make the code easier to understand and change. An analysis of data from a recent code inspection experiment shows that 60% of all issues raised in the code inspections are not problems that could have been uncovered by latter phases of testing or field usage because they have little or nothing to do with the visible execution behavior of the software. Rather they improve the maintainability of the code by making the code conform to coding standards, minimizing redundancies, improving language proficiency, improving safety and portability, and raising the quality of the documentation. We conclude that even if advances in software technology have diminished the value of inspections as a defect detection tool, in most cases, it continues to be of value as a maintenance tool.","1063-6773","0-7695-1189","10.1109/ICSM.2001.972741","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=972741","","Inspection;Costs;Data analysis;Code standards;Safety;Documentation;Automatic testing;Investments;Software testing;Instruments","software maintenance;program debugging;software portability","software code inspection;visible execution behavior;software maintainability;language proficiency;safety;software portability;software technology","","20","18","","","","","","IEEE","IEEE Conferences"
"A case study on machine learning model for code review expert system in software engineering","M. Madera; R. Tomoń","Rzeszów University of Technology, al. Powstańców Warszawy 12, 35-959 Rzeszów, Poland; SoftSystem Sp. z o. o. ul. Leszka Czarnego 6a, 35-615 Rzeszów, Poland","2017 Federated Conference on Computer Science and Information Systems (FedCSIS)","","2017","","","1357","1363","Code review is a key tool for quality assurance in software development. It is intended to find coding mistakes overlooked during development phase and lower risk of bugs in final product. In large and complex projects accurate code review is a challenging task. As code review depends on individual reviewer predisposition there is certain margin of source code changes that is not checked as it should. In this paper we propose machine learning approach for pointing project artifacts that are significantly at risk of failure. Planning and adjusting quality assurance (QA) activities could strongly benefit from accurate estimation of software areas endangered by defects. Extended code review could be directed there. The proposed approach has been evaluated for feasibility on large medical software project. Significant work was done to extract features from heterogeneous production data, leading to good predictive model. Our preliminary research results were considered worthy of implementation in the company where the research has been conducted, thus opening the opportunities for the continuation of the studies.","","978-83-946253-7-5978-83-946253-8-2978-1-5090-4414","10.15439/2017F536","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8104731","","Software;Testing;Measurement;Companies;Encoding;Predictive models","expert systems;learning (artificial intelligence);program debugging;quality assurance;software maintenance;software quality;source code (software)","expert system;machine learning;source code;code review;software development;quality assurance;software engineering;medical software project;project artifacts","","","18","","","","","","IEEE","IEEE Conferences"
"A tool and case study for specification-based program review","F. Nagoya; Shaoying Liu; Yuting Chen","Dept. of Comput. Sci., Hosei Univ., Tokyo, Japan; Dept. of Comput. Sci., Hosei Univ., Tokyo, Japan; Dept. of Comput. Sci., Hosei Univ., Tokyo, Japan","29th Annual International Computer Software and Applications Conference (COMPSAC'05)","","2005","1","","375","380 Vol. 2","Effective tool support is crucial for successfully applying software review techniques in practice. In this paper, we describe the design and implementation of a software tool to support an approach to reviewing programs on the basis of their formal specifications. The approach was initially proposed in our previous publication to improve the rigor, repeatability, and effectiveness of existing code review methods. We also present a case study in which we reviewed an ATM system to assess the performance of the review approach when used with the software tool. The results of the case study show that the approach is effective in detecting errors in programs and the tool is helpful in enhancing the efficiency of the review process.","0730-3157;0730-3157","0-7695-2413","10.1109/COMPSAC.2005.36","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1510054","Rigorous review;formal specifications;inspection;verification","Computer aided software engineering;Software tools;Formal specifications;Inspection;Software systems;Computer science;Large-scale systems;Computer industry;Educational technology;Costs","software reviews;formal specification;program verification;software tools;banking","specification-based program review;tool support;software review;software tool;formal specification;code review;ATM system;program error detection;inspection;program verification","","1","21","","","","","","IEEE","IEEE Conferences"
"Efficient Translation and Execution Method for Automated Parallel Processing System by Using Valgrind","H. Obuchi; K. Ootsu; T. Ohkawa; T. Yokota","NA; NA; NA; NA","2015 Third International Symposium on Computing and Networking (CANDAR)","","2015","","","607","609","Recently, multicore processors are very common existence. Thread-level parallel processing is inevitable to fully utilize the performance of multicore processors. In order to full utilization of high performance of multicore processors without reference of source program codes, we are now developing a software system for automated parallel processing that can parallelize directly program binary codes. Our system is built on Valgrind, a dynamic binary instrumentation framework, and parallelizes the binary code of loops within the target program to run the parallelized binary codes on multicore processor for performance improvement. The guest program on Valgrind is translated and executed per basic block basis. Although this feature is preferable for the instrumentation of the code inspection for target program, it is not suitable for parallelizing loop codes that consist of multiple basic blocks, since this causes the huge runtime overhead by wasteful processes between blocks. To solve this problem, in this paper, we present a method to reduce the runtime overhead by merging the basic blocks within the target loop and by translating entire codes at a time. Furthermore, we discuss the methods of thread control to reduce the runtime overheads. To investigate the most efficient method of thread control, we examine several combinations of thread creation and CPU affinity. Evaluation results show that translating multiple basic blocks within a program loop at a time can allow us to achieve about 2.3 times performance improvement as compared to the original execution on Valgrind.","2379-1896","978-1-4673-9797","10.1109/CANDAR.2015.109","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7425444","thread-level parallel processing;dynamic binary translation;automatic parallelization;runtime overhead;thread control","Instruction sets;Parallel processing;Multicore processing;Resource management;Runtime;Binary codes","multiprocessing systems;parallel processing;program control structures","translation method;execution method;automated parallel processing system;Valgrind;multicore processors;thread-level parallel processing;program binary codes;dynamic binary instrumentation framework;loops binary code;parallelized binary codes;code inspection instrumentation;runtime overhead reduction;basic blocks;thread control;thread creation;CPU affinity;program loop","","","6","","","","","","IEEE","IEEE Conferences"
"A reflective practice of automated and manual code reviews for a studio project","Jun-Suk Oh; Ho-Jin Choi","KT Operations Support Syst. Lab, Inf. & Commun. Univ., Deajeon, South Korea; NA","Fourth Annual ACIS International Conference on Computer and Information Science (ICIS'05)","","2005","","","37","42","In this paper, the target of code review is project management system (PMS), developed by a studio project in a software engineering master's program, and the focus is on finding defects not only in view of development standards, i.e., design rule and naming rule, but also in view of quality attributes of PMS, i.e., performance and security. From the review results, a few lessons are learned. First, defects which had not been found in the test stage of PMS development could be detected in this code review. These are hidden defects that affect system quality and that are difficult to find in the test. If the defects found in this code review had been fixed before the test stage of PMS development, productivity and quality enhancement of the project would have been improved. Second, manual review takes much longer than an automated one. In this code review, general check items were checked by automation tool, while project-specific ones were checked by manual method. If project-specific check items could also be checked by automation tool, code review and verification work after fixing the defects would be conducted very efficiently. Reflecting on this idea, an evolution model of code review is studied, which eventually seeks fully automated review as an optimized code review.","","0-7695-2296","10.1109/ICIS.2005.17","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1515372","","Inspection;Software engineering;Security;Testing;Automation;Project management;Code standards;Software standards;Standards development;Communication standards","project management;software development management;program verification;software quality;software standards;software performance evaluation;computer science education","automated code review;manual code review;studio project;project management system;software engineering;development standard;design rule;naming rule;system quality;PMS development;PMS productivity;quality enhancement;automation tool;project-specific check item;verification work","","3","7","","","","","","IEEE","IEEE Conferences"
"Review on Code Examination Proficient System in Software Engineering by Using Machine Learning Approach","N. Ayesha; N. G. Yethiraj","Abbas Khan College For Women, Bangalore, Dept. of Computer Science, Bharathiar University, Coimbatore, India; Dept of Computer Science, Maharani's Science College for Women, Bengaluru, India","2018 International Conference on Inventive Research in Computing Applications (ICIRCA)","","2018","","","324","327","The major aim of this paper is to develop code examination proficient system using machine learning algorithm in software engineering. 1. To explore the existing techniques and challenges in code review proficient system. 2. To provide effectual code review proficient system using Support Vector Machine (SVM) classification. 3. To evaluate the performance of the proposed technique using precision, accuracy, sensitivity and specificity parameters.","","978-1-5386-2456-2978-1-5386-2457","10.1109/ICIRCA.2018.8597382","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8597382","Machine Learning;Support Vector Machine (SVM);Software Engineering;WEKA","Software;Support vector machines;Encoding;Measurement;Software engineering;Predictive models;Machine learning","learning (artificial intelligence);software engineering;support vector machines","code examination proficient system;machine learning algorithm;software engineering;effectual code review proficient system;support vector machine classification;machine learning approach","","","14","","","","","","IEEE","IEEE Conferences"
"A process for performing security code reviews","M. A. Howard","Security Eng., Microsoft, Redmond, WA, USA","IEEE Security & Privacy","","2006","4","4","74","79","No one really likes reviewing source code for security vulnerabilities; its slow, tedious, and mind-numbingly boring. Yet, code review is a critical component of shipping secure software to customers. Neglecting it isn't an option","1540-7993;1558-4046","","10.1109/MSP.2006.84","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1668009","code review;security vulnerabilities;secure code","Computer security;Privacy;Computer bugs;Java;History;Data security;Wildlife;Software tools;Data analysis;Performance analysis","program debugging;program diagnostics;security of data","security code reviews;security vulnerabilities","","20","8","","","","","","IEEE","IEEE Journals & Magazines"
"Multi-Perspective Visualization to Assist Code Change Review","C. Wang; X. Xie; P. Liang; J. Xuan","NA; NA; NA; NA","2017 24th Asia-Pacific Software Engineering Conference (APSEC)","","2017","","","564","569","Change-based code review plays an important role in open-source project development. Due to the large amount of human involvement and tight time schedule, tools that can facilitate this activity would be of great help. Current tools mainly focus on difference extraction, code style examination, static analysis, comment and discussion, etc. However, there is little support to change impact analysis for code change review. In this paper, we serve this purpose by providing a change review assistance tool, namely, MultiViewer, for the most popular OSS GitHub. We define metrics to characterize code changes from multiple perspectives. Specifically, these metrics mine coupling relations among related files in the changes, as well as estimate the change effort, risk and impact. Such information is visualized by MultiViewer in two formats. We demonstrate the helpfulness of MultiViewer by showing its ability as indicators to some important project features with real-life case studies.","","978-1-5386-3681-7978-1-5386-3682","10.1109/APSEC.2017.66","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8305982","code review;change impact analysis;visualization;GitHub","Couplings;Computer bugs;Measurement;Tools;Visualization;Color;Correlation","data visualisation;program diagnostics;program visualisation;public domain software;software quality","MultiViewer;multiperspective visualization;assist code change review;code review;open-source project development;code style examination;static analysis;change review assistance tool;OSS GitHub;change-based code review;agile software development;software quality assurance","","","22","","","","","","IEEE","IEEE Conferences"
"Contemporary Peer Review in Action: Lessons from Open Source Development","P. Rigby; B. Cleary; F. Painchaud; M. Storey; D. German","Concordia University, Montreal, Canada; University of Victoria, Canada; Department of National Defence, Canada; University of Victoria, Canada; University of Victoria, Canada","IEEE Software","","2012","29","6","56","61","Do you use software peer reviews? Are you happy with your current code review practices? Even though formal inspection is recognized as one of the most effective ways to improve software quality, many software organizations struggle to effectively implement a formal inspection regime. Open source projects use an agile peer review process-based on asynchronous, frequent, incremental reviews that are carried out by invested codevelopers-that contrasts with heavyweight inspection processes. The authors describe lessons from the OSS process that transfer to proprietary software development. They also present a selection of popular tools that support lightweight, collaborative, code review processes and nonintrusive metric collection.","0740-7459;1937-4194","","10.1109/MS.2012.24","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6148202","software quality;software peer review;inspection;agile development;open source software development","Software quality;Agile manufacturing;Programming;Electronic mail;Software engineering;Software development","DP industry;formal verification;inspection;public domain software;software quality;software reviews","contemporary peer review;open source development;software peer reviews;code review practices;software quality;software organizations;formal inspection regime;open source projects;agile peer review process;invested codevelopers;heavyweight inspection processes;OSS process;proprietary software development;lightweight review process;collaborative review process;code review process;nonintrusive metric collection","","35","15","","","","","","IEEE","IEEE Journals & Magazines"
"A study on improving static analysis tools: Why are we not using them?","B. Johnson","Department of Computer Science, North Carolina State University, Raleigh, USA","2012 34th International Conference on Software Engineering (ICSE)","","2012","","","1607","1609","Using static analysis tools for automating code inspections can be beneficial for software engineers. Despite the benefits of using static analysis tools, research suggests that these tools are underused. In this research, we propose to investigate why developers are not widely using static analysis tools and how current tools could potentially be improved to increase usage.","1558-1225;0270-5257;0270-5257","978-1-4673-1067-3978-1-4673-1066-6978-1-4673-1065","10.1109/ICSE.2012.6227228","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6227228","static analysis;tool development;tool evaluation","Interviews;Computer bugs;Software;Analytical models;Industries;Encoding;Programming","program diagnostics;software tools","static analysis tool;code inspection automation;software engineers","","1","12","","","","","","IEEE","IEEE Conferences"
"Further investigations into the development and evaluation of reading techniques for object-oriented code inspection","A. Dunsmore; M. Roper; M. Wood","Dept. of Comput. & Inf. Sci., Strathclyde Univ., Glasgow, UK; Dept. of Comput. & Inf. Sci., Strathclyde Univ., Glasgow, UK; Dept. of Comput. & Inf. Sci., Strathclyde Univ., Glasgow, UK","Proceedings of the 24th International Conference on Software Engineering. ICSE 2002","","2002","","","47","57","Describes the development and experimental evaluation of a rigorous approach for effective object-oriented (OO) code inspection. Since their development, inspections have been shown to be powerful defect detection strategies but little research has been done to investigate their application to OO systems, which have very different structural and execution models compared to procedural systems. Previous investigations have demonstrated that the delocalised nature of OO software - the resolution of frequent non-local references and the incongruous relationship between its static and dynamic representations - are primary inhibitors to its effective inspection. The experiment investigates a set of three complementary code-reading techniques devised specifically to address these problems: one based on a checklist adapted to address the identified problems of OO inspections, one focused on the systematic construction of abstract specifications, and the last one centered on the dynamic slice that a use case takes through a system. The analysis shows that there is a significant difference in the number of defects found between the three reading techniques. The checklist-based technique emerges as the most effective approach, but the other techniques also have noticeable strengths, and so, for the best results in a practical situation, a combination of techniques is recommended.","","1-58113-472","10.1145/581348.581349","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1007955","","Inspection;Permission;Application software;Object oriented modeling;Power system modeling;Inhibitors;Industrial control;Testing;Java;Encapsulation","object-oriented programming;inspection;software engineering;program diagnostics","code-reading techniques;object-oriented code inspection;defect detection strategies;structural models;execution models;delocalised software;nonlocal reference resolution;static representation;dynamic representation;check list;abstract specifications;use-case dynamic slice","","12","19","","","","","","IEEE","IEEE Conferences"
"Managing code inspection information","J. Barnard; A. Price","AT&T Bell Labs., Denver, CO, USA; NA","IEEE Software","","1994","11","2","59","69","Inspection data is difficult to gather and interpret. At AT&T Bell Laboratories, the authors have defined nine key metrics that software project managers can use to plan, monitor, and improve inspections. Graphs of these metrics expose problems early and can help managers evaluate the inspection process itself. The nine metrics are: total noncomment lines of source code inspected in thousands (KLOC); average lines of code inspected; average preparation rate; average inspection rate; average effort per KLOC; average effort per fault detected; average faults detected per KLOC; percentage of reinspections; defect-removal efficiency.<<ETX>>","0740-7459;1937-4194","","10.1109/52.268958","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=268958","","Information management;Inspection;Fault detection;Software testing;Software measurement","software metrics;software reliability;inspection;project management","code inspection information;AT&T Bell Laboratories;metrics;software project managers;inspection process;total noncomment lines;source code;preparation rate;inspection rate;effort per fault;reinspections;defect-removal efficiency;software inspection","","35","9","","","","","","IEEE","IEEE Journals & Magazines"
"The Real World Software Process","J. M. Hogan; G. Smith; R. Thomas","Centre for Inf. Technol. Innovation, Queensland Univ. of Technol., Brisbane, Qld., Australia; Centre for Inf. Technol. Innovation, Queensland Univ. of Technol., Brisbane, Qld., Australia; Centre for Inf. Technol. Innovation, Queensland Univ. of Technol., Brisbane, Qld., Australia","Ninth Asia-Pacific Software Engineering Conference, 2002.","","2002","","","366","375","The industry-wide demand for rapid development in concert with greater process maturity has seen many software development firms adopt tightly structured iterative processes. While a number of commercial vendors offer suitable process infrastructure and tool support, the cost of licensing, configuration and staff training may be prohibitive for the small and medium size enterprises (SMEs) which dominate the Asia-Pacific software industry. This work addresses these problems through the introduction of the Real World Software Process (RWSP), a freely available, Web-based iterative scheme designed specifically for small teams and organisations. RWSP provides a detailed process description, high quality document templates - including code review and inspection guidelines - and the integrated tutorial support necessary for successful usage by inexperienced developers and teams. In particular it is intended that the process be readily usable by software houses which at present do not follow a formal process, and that the free RWSP process infrastructure should be a vehicle for improving industry standards.","1530-1362","0-7695-1850","10.1109/APSEC.2002.1183006","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1183006","","Computer industry;Industrial training;Programming;Costs;Licenses;Software tools;Inspection;Guidelines;Vehicles;Software standards","software standards;Internet;software houses;software prototyping","Real World Software Process;process maturity;rapid development;software development firms;tightly structured iterative processes;small and medium size enterprises;Asia-Pacific software industry;Web-based iterative scheme;small teams;small organisations;high quality document templates;process description;code review;inspection guidelines;integrated tutorial support;software houses;industry standards","","2","11","","","","","","IEEE","IEEE Conferences"
"VulDigger: A Just-in-Time and Cost-Aware Tool for Digging Vulnerability-Contributing Changes","L. Yang; X. Li; Y. Yu","NA; NA; NA","GLOBECOM 2017 - 2017 IEEE Global Communications Conference","","2017","","","1","7","It has been widely adopted to minimize the maintenance cost by predicting potential vulnerabilities before code audits in academia and industry. Most previous research dedicated to file/component level vulnerability prediction models is coarse- grained and may suffer from cost-prohibitive and impractical security testing activities. In this paper, we focus on a cost- aware vulnerability prediction model and present a just-in-time change-level code review tool called VulDigger to dig suspicious ones from a sea of code changes. Our contributions benefit from the case study of Mozilla Firefox by constructing a large-scale vulnerability-contributing changes (VCCs) dataset in a semi-automatic fashion. We then further manifest a classification tool with a mixture of established and new metrics derived from both software defect prediction and vulnerability prediction. Consequently, the precision of such tool is extremely promising (i.e., 92%) for an effort-aware software team. We also examine the return on investment by training a regression model to locate most skeptical changes with fewer lines to inspect. Our findings suggest that such model is capable of pinpointing 31% of all VCCs with only 20% of the effort it would take to audit all changes (i.e., 55% better than random predictor). Our outputs can assist as an early step of continuous security inspections as it provides immediate feedback once developers submit changes to their code base.","","978-1-5090-5019-2978-1-5090-5020","10.1109/GLOCOM.2017.8254428","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8254428","","Tools;Predictive models;Security;Measurement;Software;Computer bugs;Complexity theory","pattern classification;program diagnostics;program testing;public domain software;regression analysis;security of data;software quality","code audits;file/component level vulnerability prediction models;impractical security testing activities;just-in-time change-level code review tool;VulDigger;code changes;large-scale vulnerability-contributing changes dataset;cost-prohibitive security testing activities;cost-aware vulnerability prediction model;Mozilla Firefox;VCC;continuous security inspections;maintenance cost;code base;skeptical changes;regression model;effort-aware software team;software defect prediction;classification tool;semiautomatic fashion","","","25","","","","","","IEEE","IEEE Conferences"
"The Secret Life of Patches: A Firefox Case Study","O. Baysal; O. Kononenko; R. Holmes; M. W. Godfrey","NA; NA; NA; NA","2012 19th Working Conference on Reverse Engineering","","2012","","","447","455","The goal of the code review process is to assess the quality of source code modifications (submitted as patches) before they are committed to a project's version control repository. This process is particularly important in open source projects to ensure the quality of contributions submitted by the community, however, the review process can promote or discourage these contributions. In this paper, we study the patch lifecycle of the Mozilla Fire fox project. The model of a patch lifecycle was extracted from both the qualitative evidence of the individual processes (interviews and discussions with developers), and the quantitative assessment of the Mozilla process and practice. We contrast the lifecycle of a patch in pre- and post-rapid release development. A quantitative comparison showed that while the patch lifecycle remains mostly unchanged after switching to rapid release, the patches submitted by casual contributors are disproportionately more likely to be abandoned compared to core contributors. This suggests that patches from casual developers should receive extra care to both ensure quality and encourage future community contributions.","2375-5369;1095-1350","978-0-7695-4891-3978-1-4673-4536","10.1109/WCRE.2012.54","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6385140","Open source software;code review;patch lifecycle","Communities;Computer bugs;Process control;Switches;Open source software;Linux;Educational institutions","online front-ends;public domain software;software quality","patch lifecycle;Firefox case study;code review process;source code modification quality assessment;version control repository;open source projects;contribution quality;Mozilla Firefox project;pre rapid release development;post-rapid release development","","15","15","","","","","","IEEE","IEEE Conferences"
"Reviewing Career Paths of the OpenStack Developers","P. v. Wesel; B. Lin; G. Robles; A. Serebrenik","NA; NA; NA; NA","2017 IEEE International Conference on Software Maintenance and Evolution (ICSME)","","2017","","","544","548","Career perspectives are known to motivate software engineers. However, so far, career perspectives have been mostly studied within traditional software development companies. In our work we take a complementary approach and study career paths of open source developers, focusing on their advancement through the code review hierarchy, from developers to reviewers and further to core reviewers.To gain understanding of code review career paths we conduct an exploratory case study of the OpenStack community. Based on the case study we have publicized anonymized research data and formulated four hypotheses pertaining to career paths of contributors in modern multi-company open source projects. We conjecture that(i) developers and reviewers are separate subpopulations with little movement between them, (ii-a) the turnover of the core reviewers is high and rapid, (ii-b) companies are interested in having core reviewers among their staff, and (iii) being a core reviewer is beneficial for career.Validity of those hypotheses in other multi-company open source projects should be investigated in the follow-up studies.","","978-1-5386-0992-7978-1-5386-0993","10.1109/ICSME.2017.25","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8094459","OpenStack;career;code review;open source software","Engineering profession;Software;Companies;Couplings;Databases;Focusing;Bibliographies","human factors;personnel;public domain software;software engineering","software development companies;multicompany open source projects;code review career paths;code review hierarchy;open source developers;software engineers;career perspectives;OpenStack developers","","1","31","","","","","","IEEE","IEEE Conferences"
"CRISTA: A tool to support code comprehension based on visualization and reading technique","D. Porto; M. Mendonca; S. Fabbri","Federal University of São Carlos - Brazil; University of Salvador - Brazil; Federal University of São Carlos - Brazil","2009 IEEE 17th International Conference on Program Comprehension","","2009","","","285","286","This paper presents a tool named CRISTA that supports code comprehension through the application of stepwise abstraction. It uses a visual metaphor to represent the code and supports essential tasks for code reading, inspection and documentation. As code comprehension is time consuming, a tool can greatly improve such activity.","1092-8138","978-1-4244-3998-0978-1-4244-3997","10.1109/ICPC.2009.5090060","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5090060","","Visualization;Inspection;Documentation;Java;Reverse engineering;Switches;Software maintenance;Libraries;Software engineering;Programming profession","program testing;program visualisation;reverse engineering;software maintenance;system documentation","code comprehension;reading technique;visualization technique;stepwise abstraction;code inspection;code documentation;software maintenance","","","4","","","","","","IEEE","IEEE Conferences"
"Partitioning Composite Code Changes to Facilitate Code Review","Y. Tao; S. Kim","NA; NA","2015 IEEE/ACM 12th Working Conference on Mining Software Repositories","","2015","","","180","190","Developers expend significant effort on reviewing source code changes. Hence, the comprehensibility of code changes directly affects development productivity. Our prior study has suggested that composite code changes, which mix multiple development issues together, are typically difficult to review. Unfortunately, our manual inspection of 453 open source code changes reveals a non-trivial occurrence (up to 29%) of such composite changes. In this paper, we propose a heuristic-based approach to automatically partition composite changes, such that each sub-change in the partition is more cohesive and self-contained. Our quantitative and qualitative evaluation results are promising in demonstrating the potential benefits of our approach for facilitating code review of composite code changes.","2160-1852;2160-1860","978-0-7695-5594","10.1109/MSR.2015.24","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7180078","","Software;Manuals;Pattern matching;Force;Inspection;Libraries;Cloning","public domain software;software maintenance;source code (software)","partitioning composite code changes;code review;source code changes;open source code","","11","35","","","","","","IEEE","IEEE Conferences"
"Empirical Metadata Maintenance in Source Code Development Process","K. Rastocny; M. Bielikova","NA; NA","2015 4th Eastern European Regional Conference on the Engineering of Computer Based Systems","","2015","","","25","31","A management of software development process is a crucial part of the software engineering, from which the success of software projects is dependent. This management mostly relays upon quality and freshness of software metrics, especially empirical software metrics. But empirical software metrics are sensitive to source code modifications and also to developers' activities. In this paper we proposed approach for a maintenance of empirical metadata stored in information tags. The approach covers main maintenance actions - creating missing, repairing invalidated and removing unrepairable information tags. The maintenance is provided via tagging rules executed after matching predefined templates in a stream of developers' actions. We also introduces a set of information tags for supporting software development process and we describe their utilization in teaching a subject Team project.","","978-1-4673-7967","10.1109/ECBS-EERC.2015.13","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7275222","information tag;metadata management;empirical metadata;developers' activities;software metrics;code review","Tagging;Software metrics;Software;Maintenance engineering;Semantics;Generators;Resource description framework","meta data;software development management;software maintenance;software metrics;software quality","source code development process;empirical metadata maintenance;software development process management;software engineering;software metrics;maintenance actions;unrepairable information tags;tagging rules;subject team project","","","20","","","","","","IEEE","IEEE Conferences"
"Automatically-retargetable model-driven tools for embedded code inspection in SoCs","M. R. d. O. Schultz; A. K. I. Mendonca; F. G. Carvalho; O. J. V. Furtado; L. C. V. Santos","Computer Science Department, Federal University of Santa Catarina, Florianópolis, Brazil; Computer Science Department, Federal University of Santa Catarina, Florianópolis, Brazil; Computer Science Department, Federal University of Santa Catarina, Florianópolis, Brazil; Computer Science Department, Federal University of Santa Catarina, Florianópolis, Brazil; Computer Science Department, Federal University of Santa Catarina, Florianópolis, Brazil","2007 50th Midwest Symposium on Circuits and Systems","","2007","","","245","248","SoC design asks for tools to inspect embedded code and to pinpoint its bugs. Since design exploration may require that the code execute in distinct candidate processors, inspection tools must be retargeted. Besides, the time-to-market pressure makes automatic retargeting mandatory. This can be accomplished through tool generation from a formal model of each target processor, written in some architecture description language (ADL). This work extends a binary utility generator based upon the ArchC ADL by providing a technique for automatically retargeting disassemblers and debuggers. For experimental validation, we relied on the well-known MiBench and Dalton benchmarks. The results obtained from our retargeted tools and those from native tools were compared for distinct RISC and CISC architectures (i8051, MIPS, SPARC and PowerPC).","1548-3746;1558-3899","978-1-4244-1175-7978-1-4244-1176","10.1109/MWSCAS.2007.4488580","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4488580","","Inspection;Assembly;Embedded software;Debugging;Computer bugs;Time to market;Architecture description languages;Reduced instruction set computing;Software tools;VLIW","hardware description languages;logic CAD;system-on-chip","automatically-retargetable model-driven tools;embedded code inspection;SoC design;design exploration;distinct candidate processors;automatic retargeting;architecture description language;binary utility generator;ArchC ADL;automatically retargeting disassemblers;automatically retargeting debuggers","","3","14","","","","","","IEEE","IEEE Conferences"
"In methods we trust?","L. Hohmann","SmartPatents Inc., USA","Computer","","1997","30","10","119","121","The degree to which you trust your environment-including co-workers, software tools and systems-has a dramatic impact on the performance of your entire software development team. If you can't trust someone during a code review, what are the chances the code review will be any good? I've become increasingly aware of another aspect of trust: the trust of a method. A method is a disciplined approach to problem solving that produces one or more well-defined outcomes. There appear to be two philosophies when it comes to trust and methods. One camp soundly rejects methods as a basis for trust: the only valid approach to problem solving is to identify specific problems systematically in their environment and solve these problems, one by one. The other camp takes the opposite approach, performing every process step by preparing all of the models (and other outcomes) defined by their method. The question is not whether you build software according to a process, but whether you trust the process you use. Do you trust your development process to generate accurate schedules? Do you trust it to generate high-quality, easily maintainable source code? Do you trust that your process will generate highly usable systems?.","0018-9162;1558-0814","","10.1109/2.625340","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=625340","","Software development","software engineering;professional aspects;philosophical aspects","software development methods;object-oriented methods;CASE tools;trust;co-workers;software tools;software development team performance;code review;problem solving;well-defined outcomes;philosophies;software development process;schedules;maintainable source code;usable systems","","1","","","","","","","IEEE","IEEE Journals & Magazines"
"In search of theory and tools to support code inspections","T. L. Rodgers; D. R. Vogel; T. Purdin; B. Saints","Arizona Univ., Tucson, AZ, USA; NA; NA; NA","Proceedings of the Thirty-First Hawaii International Conference on System Sciences","","1998","3","","370","378 vol.3","This paper proposes a research agenda and tool development methodology to support software code inspections. Research suggests promise and opportunity for a practical, people-oriented, and cognitively-based code inspection research approach. To provide theoretical and practical foundations, this paper identifies research assumptions, pitfalls and potentials. It also proposes a theoretical causal model. Finally, the paper presents and analyzes results from a pilot study. Research contributions include: linking tasks, technology, and levels of maturity (using a slightly modified capability maturity model); and positing that, given process maturity and reviewer proficiency profiles, management can better allocate resources (program coders and reviewers matched by motivation, code selection, supporting documentation, and review tools/processes).","","0-8186-8255","10.1109/HICSS.1998.656306","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=656306","","Inspection;Software tools;Software maintenance;Capability maturity model;Joining processes;Resource management;Technology management;Programming;Software engineering;Productivity","program diagnostics","software code inspection tools;research;tool development methodology;people-oriented inspection;cognitive-based code inspection;theoretical causal model;process maturity;reviewer proficiency profiles;resource allocation;code selection;documentation","","2","12","","","","","","IEEE","IEEE Conferences"
"Review participation in modern code review: An empirical study of the Android, Qt, and OpenStack projects (journal-first abstract)","P. Thongtanunam; S. McIntosh; A. E. Hassan; H. Iida","The University of Adelaide, McGill University, Queen's University, Nara Institute of Science and Technology; The University of Adelaide, McGill University, Queen's University, Nara Institute of Science and Technology; The University of Adelaide, McGill University, Queen's University, Nara Institute of Science and Technology; The University of Adelaide, McGill University, Queen's University, Nara Institute of Science and Technology","2018 IEEE 25th International Conference on Software Analysis, Evolution and Reengineering (SANER)","","2018","","","475","475","This paper empirically investigates the factors influence review participation in the MCR process. Through a case study of the Android, Qt, and OpenStack open source projects, we find that the amount of review participation in the past is a significant indicator of patches that will suffer from poor review participation. Moreover, the description length of a patch and the purpose of introducing new features also share a relationship with the likelihood of receiving poor review participation. This paper is an extended abstract of a paper published in the Empirical Software Engineering journal. The original paper is communicated by Jeffrey C. Carver.","","978-1-5386-4969-5978-1-5386-4970","10.1109/SANER.2018.8330241","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8330241","","","","","","","","","","","","","IEEE","IEEE Conferences"
"A Practical Analytical Approach to Increase Confidence in PLD-Based Systems Safety Analysis","A. V. da Silva Neto; L. F. Vismari; R. A. V. Gimenes; D. B. Sesso; J. R. de Almeida; P. S. Cugnasca; J. B. Camargo","Escola Politécnica da Universidade de São Paulo, São Paulo, Brazil; Escola Politécnica da Universidade de São Paulo, São Paulo, Brazil; Escola Politécnica da Universidade de São Paulo, São Paulo, Brazil; Escola Politécnica da Universidade de São Paulo, São Paulo, Brazil; Escola Politécnica da Universidade de São Paulo, São Paulo, Brazil; Escola Politécnica da Universidade de São Paulo, São Paulo, Brazil; Escola Politécnica da Universidade de São Paulo, São Paulo, Brazil","IEEE Systems Journal","","2018","12","4","3473","3484","The use of programmable logic devices (PLDs) in safety-critical systems has meaningfully increased over the past years, driven by advantages such as reduced development costs and time-to-market. Despite such increasing use, current standards that support the development of safety-critical systems have still not appropriately addressed how to certificate PLD-based systems. Recent bibliography on the use of PLDs in safety-critical systems has not filled this gap as well, reinforcing the need for a safety analysis methodology for PLD-based safety-critical systems. This paper proposes an extension of the practical analytical approach presented in 2015 by Vismari et al., inserting the safety analysis of PLDs into a broader system safety analysis process. The PLD safety analysis is based on the code inspection of the hardware description source code. It checks for inappropriate coding practices and aids in minimizing the exposure of the system to an unsafe state due to an inadequate PLD design. A case study based on the authors' experience by applying the proposed approach in real independent safety analysis projects of safety-critical systems, together with its results, is then presented. Based on such results, the proposed approach is deemed appropriate for the safety analysis of PLD-based safety critical systems, supporting its use in a system certification context.","1932-8184;1937-9234;2373-7816","","10.1109/JSYST.2017.2726178","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7987771","Certification;field programmable gate arrays;inspection;programmable logic devices (PLDs);risk analysis;safety","Safety;Hardware;Field programmable gate arrays;Software;IEC Standards;ISO Standards","programmable logic devices;safety-critical software;source coding","practical analytical approach;certificate PLD-based systems;PLD-based safety-critical systems;broader system safety analysis process;PLD safety analysis;independent safety analysis projects;system certification context;programmable logic devices;code inspection;hardware description source code","","","31","","","","","","IEEE","IEEE Journals & Magazines"
"Estimating the Required Code Inspection Team Size","E. Kantorowitz; T. Kuflik; A. Raginsky","NA; NA; NA","IEEE International Conference on Software-Science, Technology & Engineering (SwSTE'07)","","2007","","","104","115","Code inspection is considered an efficient method for detecting faults in software code documents. The number of faults not detected by inspection should be small. Several methods have been suggested for estimating the number of undetected faults. These methods include the fault injection method that is considered to be quite laborious, capture recapture methods that avoid the problems of code injection and the Detection Profile Method for cases where capture recapture methods do not provide sufficient accuracy. The Kantorowitz estimator is based on a probabilistic model of the inspection process and enables the estimating the number of inspectors required to detect a specified fraction of all the faults of a document as well as the number of undetected faults. This estimator has proven to be satisfactory in inspection of user requirements documents. The experiments reported in this study suggest that it is also useful for code inspection.","","0-7695-3021-4978-0-7695-3021","10.1109/SwSTE.2007.18","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4384090","","Inspection;Fault detection;Chromium;State estimation;Computer science;Educational institutions;Management information systems;Industrial engineering;Conference management;Technology management","","","","1","37","","","","","","IEEE","IEEE Conferences"
"Confusion Detection in Code Reviews","F. Ebert; F. Castor; N. Novielli; A. Serebrenik","NA; NA; NA; NA","2017 IEEE International Conference on Software Maintenance and Evolution (ICSME)","","2017","","","549","553","Code reviews are an important mechanism for assuring quality of source code changes. Reviewers can either add general comments pertaining to the entire change or pinpoint concerns or shortcomings about a specific part of the change using inline comments. Recent studies show that reviewers often do not understand the change being reviewed and its context.Our ultimate goal is to identify the factors that confuse code reviewers and understand how confusion impacts the efficiency and effectiveness of code review(er)s. As the first step towards this goal we focus on the identification of confusion in developers' comments. Based on an existing theoretical framework categorizing expressions of confusion, we manually classify 800 comments from code reviews of the Android project. We observe that confusion can be reasonably well-identified by humans: raters achieve moderate agreement (Fleiss' kappa 0.59 for the general comments and 0.49 for the inline ones). Then, for each kind of comment we build a series of automatic classifiers that, depending on the goals of the further analysis, can be trained to achieve high precision (0.875 for the general comments and 0.615 for the inline ones), high recall (0.944 for the general comments and 0.988 for the inline ones), or substantial precision and recall (0.696 and 0.542 for the general comments and 0.434 and 0.583 for the inline ones, respectively). These results motivate further research on the impact of confusion on the code review process. Moreover, other researchers can employ the proposed classifiers to analyze confusion in other contexts where software development-related discussions occur, such as mailing lists.","","978-1-5386-0992-7978-1-5386-0993","10.1109/ICSME.2017.40","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8094460","code review;confusion;machine learning","Androids;Humanoid robots;Uncertainty;Software;Labeling;Training;Manuals","Android (operating system);human factors;pattern classification;program testing;software quality","confusion detection;source code changes;inline comments;code review process;Android project;automatic classifiers;precision value;recall value","","4","42","","","","","","IEEE","IEEE Conferences"
"Applying Security Assurance Techniques to a Mobile Phone Application: An Initial Approach","P. Krishnan; S. Hafner; A. Zeiser","NA; NA; NA","2011 IEEE Fourth International Conference on Software Testing, Verification and Validation Workshops","","2011","","","545","552","As users download applications to their mobile phones, security is a critical issue. In this paper we present a process for the security assurance of applications. It uses existing vulnerability databases and application development guidelines to identify potential security issues. The identified issues are then validated using a variety of techniques including black-box testing, unit testing code inspection and static analysis. This process is illustrated using an application for the Android platform.","","978-0-7695-4345-1978-1-4577-0019","10.1109/ICSTW.2011.10","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5954462","Android;Assurance;Security;QA process","Security;Guidelines;Testing;Androids;Mobile handsets;Databases;Humanoid robots","database management systems;mobile computing;mobile radio;operating systems (computers);program diagnostics;program testing;telecommunication security","security assurance techniques;mobile phone application;vulnerability databases;application development guidelines;security issues;black-box testing;unit testing code inspection;static analysis;Android platform","","","28","","","","","","IEEE","IEEE Conferences"
"Impact of user interface generation on maintenance","T. Cerny; V. Chalupa; M. J. Donahoo","Dept. Computer Science and Engineering, Czech Technical University, Charles Square 13, Prague, Czech Republic; Dept. Software Engineering, Czech Technical University, Charles Square 13, Prague, Czech Republic; Dept. Computer Science, Baylor University, Waco, TX, USA","2012 IEEE International Conference on Computer Science and Automation Engineering (CSAE)","","2012","2","","621","625","User interface development and maintenance is one of the most time consuming parts of software application development. User interfaces provide numerous graphical visualizations of user data, these are often influenced by multiple factors such as available interface elements, data constraints, layouts, user operating devices or user rights. The complexity of the development and maintenance raises from duplicated and restated information. Duplication occurs multiple times in the application, for example data model already contains data constraints and these are restated in the interface. Not only information but also decisions are duplicated when an interface element is selected and bound to a particular data field. Machine driven code-inspection and its transformation to user interface brings the way to address complex efforts related to user interface. In this paper we present code-inspection approach to automate user interface development and maintenance, we also provide a case study that compares the approach with manual development.","","978-1-4673-0089-6978-1-4673-0088-9978-1-4673-0087","10.1109/CSAE.2012.6272847","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6272847","Maintenance;Code-inspection;UI generation","Unified modeling language;Maintenance engineering;Data models;Manuals;Electronic mail;Human computer interaction","data visualisation;graphical user interfaces;inspection;software maintenance;user interface management systems","user interface generation;software application development;graphical user data visualization;duplication;interface element;machine driven code inspection;user interface development;user interface maintenance","","1","18","","","","","","IEEE","IEEE Conferences"
"A Socio-Psychological Approach to Improve Student Participation and Review Quality in Peer Code Reviews","P. Agarwal; C. D. Hundhausen","NA; NA","2010 IEEE Symposium on Visual Languages and Human-Centric Computing","","2010","","","263","264","Modern day computing jobs are increasingly emphasizing on soft skills such as design, collaboration and communication skills in addition to programming skills. Having students participate in peer reviews is one possible way to develop such soft skills. However, we have observed that low student participation and low review quality can impede the educational value of the peer review process. To address this issue and improve student learning in computer programming courses, we propose to implement and evaluate social comparisons - a method suggested by socio-psychological research.","1943-6106;1943-6092","978-1-4244-8485","10.1109/VLHCC.2010.50","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5635258","","Book reviews;Programming profession;Algorithm design and analysis;Communities;Encoding","computer science education;educational courses;programming;psychology;social sciences","computing job;soft skill;design skill;collaboration skill;communication skill;programming skill;peer code review;student participation;review quality;educational value;student learning;computer programming course;social comparison;socio-psychological research","","","5","","","","","","IEEE","IEEE Conferences"
"Expectations, outcomes, and challenges of modern code review","A. Bacchelli; C. Bird","REVEAL @ Faculty of Informatics, University of Lugano, Switzerland; Microsoft Research, Redmond, Washington, USA","2013 35th International Conference on Software Engineering (ICSE)","","2013","","","712","721","Code review is a common software engineering practice employed both in open source and industrial contexts. Review today is less formal and more “lightweight” than the code inspections performed and studied in the 70s and 80s. We empirically explore the motivations, challenges, and outcomes of tool-based code reviews. We observed, interviewed, and surveyed developers and managers and manually classified hundreds of review comments across diverse teams at Microsoft. Our study reveals that while finding defects remains the main motivation for review, reviews are less about defects than expected and instead provide additional benefits such as knowledge transfer, increased team awareness, and creation of alternative solutions to problems. Moreover, we find that code and change understanding is the key aspect of code reviewing and that developers employ a wide range of mechanisms to meet their understanding needs, most of which are not met by current tools. We provide recommendations for practitioners and researchers.","0270-5257;1558-1225","978-1-4673-3076-3978-1-4673-3073","10.1109/ICSE.2013.6606617","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6606617","","Interviews;Inspection;Software;Context;Sorting;Guidelines;Knowledge transfer","software development management;software quality","software engineering practice;open source;industrial contexts;tool-based code reviews;Microsoft;knowledge transfer;team awareness","","99","40","","","","","","IEEE","IEEE Conferences"
"A hybrid approach to code reviewer recommendation with collaborative filtering","Z. Xia; H. Sun; J. Jiang; X. Wang; X. Liu","State Key Laboratory of Software Development Environment, School of Computer Science and Engineering, Beihang University, Beijing, China 100191; State Key Laboratory of Software Development Environment, School of Computer Science and Engineering, Beihang University, Beijing, China 100191; State Key Laboratory of Software Development Environment, School of Computer Science and Engineering, Beihang University, Beijing, China 100191; State Key Laboratory of Software Development Environment, School of Computer Science and Engineering, Beihang University, Beijing, China 100191; State Key Laboratory of Software Development Environment, School of Computer Science and Engineering, Beihang University, Beijing, China 100191","2017 6th International Workshop on Software Mining (SoftwareMining)","","2017","","","24","31","Code review is known to be of paramount importance for software quality assurance. However, finding a reviewer for certain code can be very challenging in Modern Code Review environment due to the difficulty of learning the expertise and availability of candidate reviewers. To tackle this problem, existing efforts mainly concern how to model a reviewer's expertise with the review history, and making recommendation based on how well a reviewer's expertise can meet the requirement of a review task. Nonetheless, as there are both explicit and implicit relations in data that affect whether a reviewer is suitable for a given task, merely modeling review expertise with explicit relations often fails to achieve expected recommendation accuracy. To that end, we propose a recommendation algorithm that takes implicit relations into account. Furthermore, we utilize a hybrid approach that combines latent factor models and neighborhood methods to capture implicit relations. Finally, we have conducted extensive experiments by comparing with the state-of-the-art methods using the data of 5 popular GitHub projects. The results demonstrate that our approach outperforms the comparing methods for all top-k recommendations and reaches a 15.3% precision promotion in top-1 recommendation.","","978-1-5386-1389-4978-1-5386-1390","10.1109/SOFTWAREMINING.2017.8100850","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8100850","Code reviewer;collaborative filtering;github","Algorithm design and analysis;Collaboration;Data models;Feature extraction;Filtering;Software","collaborative filtering;recommender systems;software quality","modern code review environment;review history;candidate reviewers;software quality assurance;code reviewer recommendation;hybrid approach;recommendation algorithm;recommendation accuracy","","1","30","","","","","","IEEE","IEEE Conferences"
"Software certification - coding, code, and coders","K. Havelund; G. J. Holzmann","Laboratory for Reliable Software (LaRS), Jet Propulsion Laboratory, California Institute of Technology, 4800 Oak Grove Drive, Pasadena, 91109-8099, USA; Laboratory for Reliable Software (LaRS), Jet Propulsion Laboratory, California Institute of Technology, 4800 Oak Grove Drive, Pasadena, 91109-8099, USA","2011 Proceedings of the Ninth ACM International Conference on Embedded Software (EMSOFT)","","2011","","","205","210","We describe a certification approach for software development that has been adopted at our organization. JPL develops robotic spacecraft for the exploration of the solar system. The flight software that controls these spacecraft is considered to be mission critical. We argue that the goal of a software certification process cannot be the development of “perfect” software, i.e., software that can be formally proven to be correct under all imaginable and unimaginable circumstances. More realistically, the goal is to guarantee a software development process that is conducted by knowledgeable engineers, who follow generally accepted procedures to control known risks, while meeting agreed upon standards of workmanship. We target three specific issues that must be addressed in such a certification procedure: the coding process, the code that is developed, and the skills of the coders. The coding process is driven by standards. The code is mechanically checked against the standards with the help of state-of-the-art static source code analyzers. The coders, finally, are certified in on-site training courses that include formal exams.","","978-1-4503-0714-7978-1-4503-0714-7978-1-4503-0712","","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6064527","Coding standards;code review;static source code analysis;logic model checking;unit testing;safety- and mission-critical software.","Software;Encoding;Certification;Software reliability;Programming;Standards","program testing;program verification;software reliability","software certification;coding process;coder;software development process;static source code analyzer","","","11","","","","","","IEEE","IEEE Conferences"
"Applying Continuous Code Reviews in Airport Operations Software","M. Bernhart; S. Strobl; A. Mauczka; T. Grechenig","NA; NA; NA; NA","2012 12th International Conference on Quality Software","","2012","","","214","219","Code reviews are an integral part of the development of a dependable system such as for airport operations. It is commonly accepted that code reviews are an effective quality assurance technique even if a rigorous application is also a high cost factor. For large software systems a formal method may be inapplicable throughout the whole code base. In this study an airport operational database (AODB) is developed with the application of a more lightweight approach to code reviews. A continuous, distributed and change-based process is applied by the development team and evaluated in comparison to team walkthroughs (IEEE-1028) as a baseline method. The application showed to be highly useful, equally effective as the baseline, but more efficient especially for the preparation, execution and rework effort. The results show that continuous code reviews also support the understanding of the code base and the concept of collective ownership. Such processes may not completely substitute a more formal and effortful technique. Especially for reviewing critical design aspects or complex items a traditional approach is still more appropriate. The main outcome is that such lightweight code reviews may be used together with more formal approaches to ensure a high coverage and that the degree of formalism should be adopted to the criticality of the item under review.","2332-662X;1550-6002;1550-6002","978-1-4673-2857-9978-0-7695-4833","10.1109/QSIC.2012.61","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6319252","code review;continuous;inspection;code quality;IEEE-1028;aviation;agile","Software;Airports;Context;Communities;Quality assurance;Standards;Databases","airports;database management systems;formal specification;program diagnostics;quality assurance;software quality","continuous code reviews;airport operations software;dependable system;quality assurance technique;large software systems;formal method;whole code base;airport operational database;AODB;continuous process;distributed process;change-based process;IEEE-1028","","3","14","","","","","","IEEE","IEEE Conferences"
"Code Reviewing in the Trenches: Challenges and Best Practices","L. MacLeod; M. Greiler; M. Storey; C. Bird; J. Czerwonka","Microsoft; Microsoft; University of Victoria; Microsoft Research; Microsoft","IEEE Software","","2018","35","4","34","42","Code review has been widely adopted by and adapted to open source and industrial projects. Code review practices have undergone extensive research, with most studies relying on trace data from tool reviews, sometimes augmented by surveys and interviews. Several recent industrial research studies, along with blog posts and white papers, have revealed additional insights on code reviewing “from the trenches.” Unfortunately, the lessons learned about code reviewing are widely dispersed and poorly summarized by the existing literature. In particular, practitioners wishing to adopt or reflect on an existing or new code review process might have difficulty determining what challenges to expect and which best practices to adopt for their development context. Building on the existing literature, this article adds insights from a recent large-scale study of Microsoft developers to summarize the challenges that code-change authors and reviewers face, suggest best code-reviewing practices, and discuss tradeoffs that practitioners should consider. This article is part of a theme issue on Process Improvement.","0740-7459;1937-4194","","10.1109/MS.2017.265100500","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7950877","peer review;social technologies;learning technologies;code inspection;code walkthroughs;testing;debugging;software engineering;software development","Encoding;Best practices;Interviews;Context awareness;Object recognition;Stakeholders","software quality;software reviews;source code (software)","tool reviews;code-change authors;code-reviewing practices;Microsoft developers;code-change reviewers","","1","11","","","","","","IEEE","IEEE Journals & Magazines"
"phpSAFE: A Security Analysis Tool for OOP Web Application Plugins","P. J. C. Nunes; J. Fonseca; M. Vieira","NA; NA; NA","2015 45th Annual IEEE/IFIP International Conference on Dependable Systems and Networks","","2015","","","299","306","There is nowadays an increasing pressure to develop complex Web applications at a fast pace. The vast majority is built using frameworks based on third-party server-side plugins that allow developers to easily add new features. However, as many plugin developers have limited programming skills, there is a spread of security vulnerabilities related to their use. Best practices advise the use of systematic code review for assure security, but free tools do not support OOP, which is how most Web applications are currently developed. To address this problem we propose phpSAFE, a static code analyzer that identifies vulnerabilities in PHP plugins developed using OOP. We evaluate phpSAFE against two well-known tools using 35 plugins for a widely used CMS. Results show that phpSAFE clearly outperforms other tools, and that plugins are being shipped with a considerable number of vulnerabilities, which tends to increase over time.","1530-0889;2158-3927","978-1-4799-8629-3978-1-4799-8628","10.1109/DSN.2015.16","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7266859","Static analysis;web application plugins;security;vulnerabilities","Security;Software;Databases;Arrays;Filtering;Context;Measurement","client-server systems;program diagnostics;security of data;Web services","CMS;PHP plugin vulnerability identification;static code analyzer;systematic code review;security vulnerabilities;third-party server-side plugins;OOP Web application plugins;security analysis tool;phpSAFE","","11","20","","","","","","IEEE","IEEE Conferences"
"Impact of Continuous Integration on Code Reviews","M. M. Rahman; C. K. Roy","NA; NA","2017 IEEE/ACM 14th International Conference on Mining Software Repositories (MSR)","","2017","","","499","502","Peer code review and continuous integration often interleave with each other in the modern software quality management. Although several studies investigate how non-technical factors (e.g., reviewer workload), developer participation and even patch size affect the code review process, the impact of continuous integration on code reviews is not yet properly understood. In this paper, we report an exploratory study using 578K automated build entries where we investigate the impact of automated builds on the code reviews. Our investigation suggests that successfully passed builds are more likely to encourage new code review participation in a pull request. Frequently built projects are found to be maintaining a steady level of reviewing activities over the years, which was quite missing from the rarely built projects. Experiments with 26,516 automated build entries reported that our proposed model can identify 64% of the builds that triggered new code reviews later.","","978-1-5386-1544-7978-1-5386-1545","10.1109/MSR.2017.39","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7962406","Automated build status;build frequency;code review quality;review participation","Correlation;Software quality;Manuals;Encoding;Standards;Frequency measurement","software management;software quality;software reviews","peer code review;continuous integration;software quality management;patch size;developer participation;nontechnical factors","","1","10","","","","","","IEEE","IEEE Conferences"
"Using complexity-tracking in software development","D. I. Heimann","Digital Equipment Corp., Boxborough, MA, USA","Annual Reliability and Maintainability Symposium 1995 Proceedings","","1995","","","433","438","CATS (Complexity Analysis and Tracking System) is a complexity-tracking system which uses the McCabe complexity analysis tool to construct and maintain an ongoing database of structural complexity values for a software system as it proceeds through its development and testing. Building on previous work which indicated a correlation between structural complexity and defect corrections, CATS allows for a tighter focus of code review efforts such as walkthroughs and inspections and aids in the design of regression, unit, and system tests. CATS has been implemented into the development and testing process for an operation-system software component denoted here as System A. The process for CATS implementation at System A involves two ongoing groups, the BIT (Build, Inspect, and Test) team and the development reams. The BIT team builds the source files, runs CATS, identifies modules for special attention in review and testing, uses the complexity information to design and execute test suites, and reports results to the development teams through a notes-files conference. The development teams use the information in their code efforts, and report their responses and experiences through replies in the notes-file. This creates a body of data, experience, and lessons-learned for use in further development. A CATS analysis has also been carried out for an operating-system facility in VMS (denoted as Facility B).","0149-144X","0-7803-2470","10.1109/RAMS.1995.513280","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=513280","","Programming;Cats;System testing;Software testing;Maintenance;Databases;Software systems;Buildings;Inspection;Voice mail","software engineering;software metrics;program testing","complexity-tracking;software development;CATS;Complexity Analysis and Tracking System;McCabe;complexity analysis tool;database;structural complexity values;testing;defect corrections;code review;walkthroughs;inspections;regression;test suites;operating system;VMS","","6","5","","","","","","IEEE","IEEE Conferences"
"Broadcast vs. Unicast Review Technology: Does It Matter?","F. Armstrong; F. Khomh; B. Adams","NA; NA; NA","2017 IEEE International Conference on Software Testing, Verification and Validation (ICST)","","2017","","","219","229","Code review is the process of having other team members examine changes to a software system in order to evaluate their technical content and quality. Over the years, multiple tools have been proposed to help software developers conduct and manage code reviews. Some software organizations have been migrating from broadcast review technology to a more advanced unicast review approach such as Jira, but it is unclear if these unicast review technology leads to better code reviews. This paper empirically studies review data of five Apache projects that switched from broadcast based code review to unicast based, to understand the impact of review technology on review effectiveness and quality. Results suggest that broadcast based review is twice faster than review done with unicast based review technology. However, unicast's review quality seems to be better than that of the broadcast based. Our findings suggest that the medium (i.e., broadcast or unicast) technology used for code reviews can relate to the effectiveness and quality of reviews activities.","","978-1-5090-6031-3978-1-5090-6032","10.1109/ICST.2017.27","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7927977","Code Review;Patches;Apache;Empirical Study;Medium;Bug-inducing Changes;Quality Assurance","Unicast;Broadcast technology;Electronic mail;Switches","software quality","code review;software system;software organizations;broadcast review technology;unicast review technology;Apache projects","","2","43","","","","","","IEEE","IEEE Conferences"
"Would static analysis tools help developers with code reviews?","S. Panichella; V. Arnaoudova; M. Di Penta; G. Antoniol","University of Zurich, Department of Informatics, Switzerland; Polytechnique Montr&#x00E9;al, Canada; Dept. of Engineering, University of Sannio, Italy; Polytechnique Montr&#x00E9;al, Canada","2015 IEEE 22nd International Conference on Software Analysis, Evolution, and Reengineering (SANER)","","2015","","","161","170","Code reviews have been conducted since decades in software projects, with the aim of improving code quality from many different points of view. During code reviews, developers are supported by checklists, coding standards and, possibly, by various kinds of static analysis tools. This paper investigates whether warnings highlighted by static analysis tools are taken care of during code reviews and, whether there are kinds of warnings that tend to be removed more than others. Results of a study conducted by mining the Gerrit repository of six Java open source projects indicate that the density of warnings only slightly vary after each review. The overall percentage of warnings removed during reviews is slightly higher than what previous studies found for the overall project evolution history. However, when looking (quantitatively and qualitatively) at specific categories of warnings, we found that during code reviews developers focus on certain kinds of problems. For such categories of warnings the removal percentage tend to be very high, often above 50% and sometimes up to 100%. Examples of those are warnings in the imports, regular expressions, and type resolution categories. In conclusion, while a broad warning detection might produce way too many false positives, enforcing the removal of certain warnings prior to the patch submission could reduce the amount of effort provided during the code review process.","1534-5351","978-1-4799-8469","10.1109/SANER.2015.7081826","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7081826","Code Review;Static Analysis;Mining Software Repositories;Empirical Study","Java;Software;Data mining;Encoding;Standards;Context;History","Java;project management;software management;software quality;software tools","static analysis tools;software projects;code quality;coding standards;Gerrit repository;Java open source projects;project evolution history;code reviews developers;broad warning detection;code review process;patch submission","","14","30","","","","","","IEEE","IEEE Conferences"
"Do Review Feedbacks Influence to a Contributor's Time Spent on OSS Projects?","T. Norikane; A. Ihara; K. Matsumoto","NA; NA; NA","2018 IEEE International Conference on Big Data, Cloud Computing, Data Science & Engineering (BCD)","","2018","","","109","113","Open Source Software (OSS) does not work without contributions from the community. In particular, long-term contributors (LTCs) (e.g., committer), defined as contributors who spend at least one year on OSS projects, play a crucial role in a project success because they would have permission to add (commit) code changes to a project's version control system, and to become a mentor for a beginner in OSS projects. However, contributors often leave a project before becoming a LTC because most contributors are volunteers. If contributors are motivated in their work in OSS projects, they might not leave the projects. In this study, we examine the phenomena involved in becoming a LTC in terms of motivation to continue in OSS projects. In particular, our target motivation is to understand what is involved in long-term contribution with other expert contributors. We study classifier to identify a LTC who will contribute patch submissions for more than one year based on collaboration in terms of the code review process. In detail, we analyze what review feedbacks encourage a contributor to continue with OSS project. Using a Qt project dataset, we build a prediction model to identify a LTC. We find that not only contributor's activities, but also a reviewer feedbacks, useful in identifying LTCs.","","978-1-5386-5605-1978-1-5386-5606","10.1109/BCD2018.2018.00028","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8530701","Open-Source-Software-Development;Long-term-contributors;Code-review-feedback","Measurement;Collaboration;Predictive models;Tools;Control systems;Databases;Information science","feedback;project management;public domain software;software engineering;software reviews","long-term contributors;project success;Qt project dataset;review feedbacks;OSS projects;open source software;LTCs;projects version control system;patch submissions;code review process","","","12","","","","","","IEEE","IEEE Conferences"
"InCode: Continuous Quality Assessment and Improvement","R. Marinescu; G. Ganea; I. Verebi","NA; NA; NA","2010 14th European Conference on Software Maintenance and Reengineering","","2010","","","274","275","While significant progress has been made over the last ten years in the research field of quality assessment, developers still can't take full advantage of the benefits of these new tools and technique. We believe that there at least two main causes for this lack of adoption: (i) the lack of integration in mainstream IDEs and (ii) the lack of support for a continuous (daily) usage of QA tools. In this context we created INCODE as an Eclipe plug in that would transform quality assessment and code inspections from a standalone activity, into a continuous, agile process, fully integrated in the development life-cycle. But INCODE not only assesses continuously the quality of Java systems, it also assists developers in taking restructuring decisions, and even supports them in triggering refactorings.","1534-5351","978-0-7695-4321-5978-1-61284-369","10.1109/CSMR.2010.44","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5714452","quality assessment;quality improvement","Measurement;Quality assessment;Inspection;Context;Java;Software systems;Computational modeling","Java;life cycle costing;software prototyping;software quality;software tools","InCode;continuous quality assessment;continuous quality improvement;IDE;QA tool;Eclipe plugin;code inspection;agile process;development life-cycle;Java system","","17","5","","","","","","IEEE","IEEE Conferences"
"Fix-it: An extensible code auto-fix component in Review Bot","V. Balachandran","VMware, Bangalore, India","2013 IEEE 13th International Working Conference on Source Code Analysis and Manipulation (SCAM)","","2013","","","167","172","Coding standard violations, defect patterns and non-conformance to best practices are abundant in checked-in source code. This often leads to unmaintainable code and potential bugs in later stages of software life cycle. It is important to detect and correct these issues early in the development cycle, when it is less expensive to fix. Even though static analysis techniques such as tool-assisted code review are effective in addressing this problem, there is significant amount of human effort involved in identifying the source code issues and fixing it. Review Bot is a tool designed to reduce the human effort and improve the quality in code reviews by generating automatic reviews using static analysis output. In this paper, we propose an extension to Review Bot- addition of a component called Fix-it for the auto-correction of various source code issues using Abstract Syntax Tree (AST) transformations. Fix-it uses built-in fixes to automatically fix various issues reported by the auto-reviewer component in Review Bot, thereby reducing the human effort to greater extent. Fix-it is designed to be highly extensible-users can add support for the detection of new defect patterns using XPath or XQuery and provide fixes for it based on AST transformations written in a high-level programming language. It allows the user to treat the AST as a DOM tree and run XQuery UPDATE expressions to perform AST transformations as part of a fix. Fix-it also includes a designer application which enables Review Bot administrators to design new defect patterns and fixes. The developer feedback on a stand-alone prototype indicates the possibility of significant human effort reduction in code reviews using Fix-it.","","978-1-4673-5739","10.1109/SCAM.2013.6648198","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6648198","","Standards;Encoding;Java;Conferences;XML;Abstracts","high level languages;human factors;program debugging;program diagnostics;software quality;software reviews;software tools;source coding;tree data structures","extensible code auto-fix component;coding standard violations;defect patterns;checked-in source code;unmaintainable code;software life cycle;static analysis techniques;tool-assisted code review;source code issues;code review quality;automatic review generation;static analysis output;abstract syntax tree transformations;AST transformations;Fix-it;auto-reviewer component;human effort;XPath;high-level programming language;DOM tree;XQuery UPDATE expressions;Review Bot administrators","","5","19","","","","","","IEEE","IEEE Conferences"
"An integrated approach to instruction in debugging computer programs","R. Chmiel; M. C. Loui","Dept. of Electr. & Comput. Eng., Illinois Univ., Urbana, IL, USA; Dept. of Electr. & Comput. Eng., Illinois Univ., Urbana, IL, USA","33rd Annual Frontiers in Education, 2003. FIE 2003.","","2003","3","","S4C","1","The purpose of this study is to demonstrate that formal training in debugging helps students develop skills in diagnosing and removing defects from computer programs. To accomplish this goal in an assembly language course, multiple activities were designed in order to enhance students' debugging skills. Students completed debugging exercises before developing the code for each programming assignment. Each set of exercises focused on the major topics covered in the assignment. Students also kept debugging logs as they worked on the assignments. In these logs, students recorded both the source of each defect and how the defect was corrected. Students reflected on their approach to each programming assignment and documented their code development and debugging experiences in a reflective memo. Last, for one programming assignment, students worked in teams of four. They identified defects collaboratively using code inspection. Students' responses to these activities have been positive and constructive.","0190-5848","0-7803-7961","10.1109/FIE.2003.1266016","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1266016","","Debugging;Computer aided instruction;Programming profession;Inspection;Collaborative work;Assembly;Curriculum development;Testing;Statistical analysis;Frequency","program debugging;computer science education;computer based training;educational courses;assembly language","debugging computer program instruction;debugging training;assembly language course;code review;curriculum development","","","12","","","","","","IEEE","IEEE Conferences"
"Java quality assurance by detecting code smells","E. van Emden; L. Moonen","CWI, Amsterdam, Netherlands; CWI, Amsterdam, Netherlands","Ninth Working Conference on Reverse Engineering, 2002. Proceedings.","","2002","","","97","106","Software inspection is a known technique for improving software quality. It involves carefully examining the code, the design, and the documentation of software and checking these for aspects that are known to be potentially problematic based on past experience. Code smells are a metaphor to describe patterns that are generally associated with bad design and bad programming practices. Originally, code smells are used to find the places in software that could benefit from refactoring. In this paper we investigate how the quality of code can be automatically assessed by checking for the presence of code smells and how this approach can contribute to automatic code inspection. We present an approach for the automatic detection and visualization of code smells and discuss how this approach can be used in the design of a software inspection tool. We illustrate the feasibility of our approach with the development of jCOSMO, a prototype code smell browser that detects and visualizes code smells in JAVA source code. Finally, we show how this tool was applied in a case study.","1095-1350","0-7695-1799","10.1109/WCRE.2002.1173068","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1173068","","Java;Quality assurance;Inspection;Software quality;Visualization;Documentation;Software design;Software tools;Software prototyping;Prototypes","Java;software quality;program visualisation","software quality;code smells;Java;refactoring;software inspection;quality assurance;automatic code inspection","","107","25","","","","","","IEEE","IEEE Conferences"
"Enhancing annotation visibility for software inspection","M. V. Stein; M. P. E. Heimdahl; J. T. Riedl","Metropolitan State (MN) Univ., USA; NA; NA","14th IEEE International Conference on Automated Software Engineering","","1999","","","243","246","Annotation of software artifacts is common in software development, and vital for software inspection. People viewing annotated artifacts encounter delocalization: they must understand various parts of an artifact (and their annotations) to understand the part they are viewing. We taxonomize delocalization within software systems into lateral delocalization (different items of the artifact within the same development phase), longitudinal delocalization (related items in different phases), and historical delocalization (successive versions of the same item). We report on a pilot study of code inspection with AnnoSpec, an inspection tool supporting visibility of laterally-delocalized annotations. Our results suggest that addressing delocalization may help people perform inspections more effectively.","","0-7695-0415","10.1109/ASE.1999.802288","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=802288","","Inspection;Software tools;Filters;Software systems;Filtering;Software engineering;Programming;Software testing;Roads;Terminology","program diagnostics;inspection;software tools","annotation visibility;software inspection;software artifacts;annotated artifacts;delocalization;software systems;lateral delocalization;development phase;longitudinal delocalization;historical delocalization;code inspection;AnnoSpec;inspection tool;laterally-delocalized annotations","","","12","","","","","","IEEE","IEEE Conferences"
"Trust, but Verify","M. Lesk","Rutgers University","IEEE Security & Privacy","","2014","12","6","94","96","Do you believe the software packages you buy and install are secure? Today that belief is largely a matter of faith. Could a third-party verification process, whether similar to Underwriters Laboratories or the US Food and Drug Administration, give us greater assurance of secure software?","1540-7993;1558-4046","","10.1109/MSP.2014.130","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7006407","software verification;security;code inspection","Computer security;Software design;Verification;Encoding;Software performance;Software reliability","program testing;program verification;security of data;software packages;trusted computing","software packages;third-party verification process;software security;software testing","","","8","","","","","","IEEE","IEEE Journals & Magazines"
"Computer-mediated group support, anonymity, and the software inspection process: an empirical investigation","P. Vitharana; K. Ramamurthy","Sch. of Manage., Syracuse Univ., NY, USA; NA","IEEE Transactions on Software Engineering","","2003","29","2","167","180","In software inspection, a key principle endorsed by Fagan (1986) is openness. However, scholars have recently questioned the efficacy of openness. For example, some argue that ego-involvement and personality conflicts that become more transparent due to openness might impede inspection. Still others point out that familiarity and (preexisting) relationships among inspection team members negatively affect the comprehensiveness in detection of defects. This brings up concerns if the openness as originally envisioned by Fagan may in fact lead to suboptimal outcomes. As the trend towards computer-based inspection continues, we believe that anonymity could play a positive role in overcoming some of the drawbacks noted in team-based inspection. Drawing upon the literature on software inspection and group support systems, this research proposes possible influences of group member anonymity on the outcome of computer-mediated software inspection and empirically examines the validity of the posited relationships in a set of controlled laboratory experiments. Two different inspection tasks with varying levels of software code complexity are employed. While both the control groups (i.e., teams without anonymity) and treatment groups (i.e., teams with support for anonymity) consume more or less the same time in performing the inspection tasks, the treatment groups are more effective in identifying the seeded errors in the more complex task. Treatment groups also express a more positive attitude toward both code inspection tasks. The findings of the study suggest a number of directions for future research.","0098-5589;1939-3520;2326-3881","","10.1109/TSE.2003.1178054","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1178054","","Collaborative software;Inspection;Software quality;Programming;Control systems;Impedance;Laboratories;Error correction;Software systems;Software tools","groupware;software quality;software development management;program testing;software process improvement;human factors","computer-mediated group support;anonymity;software inspection process;ego-involvement;personality conflicts;inspection team members;suboptimal outcomes;computer-based inspection;team-based inspection;software inspection;group support systems;group member anonymity;software code complexity;seeded errors;software quality assurance","","17","38","","","","","","IEEE","IEEE Journals & Magazines"
"Java code reviewer for verifying object-oriented design in class diagrams","K. Jinto; Y. Limpiyakorn","Department of Computer Engineering Chulalongkorn University Bangkok 10330, Thailand; Department of Computer Engineering Chulalongkorn University Bangkok 10330, Thailand","2010 2nd IEEE International Conference on Information Management and Engineering","","2010","","","471","475","Verification and Validation (V&amp;V) processes play an important role in quality control. The earlier defects are detected, the less rework incurs. According to the findings from literature, most of the defects occurred during the design and coding phases. Automatic detection of these defects would alleviate the problem. This research therefore invented an automatic code reviewer to examine Java source files against the object-oriented design described in UML class diagrams. Prior to the review process, the class diagrams are converted into XML format so that the information of classes and relations could be extracted and used to generate the review checklists. The code reviewer will then follow the checklist items to verify whether all defined classes exist in the code, the class structures with encapsulated methods and parameters are correctly implemented, all relations of associated classes are valid. Finally, the summary report will then be generated to notify the results.","","978-1-4244-5263-7978-1-4244-5265","10.1109/ICIME.2010.5477762","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5477762","code review;verification;class diagram","Java;Quality control;Unified modeling language;Software quality;Inspection;Logic programming;Programming profession;Design engineering;XML;Data mining","formal verification;Java;object-oriented programming;Unified Modeling Language;XML","Java code reviewer;object-oriented design;verification process;validation process;quality control;automatic detection;Java source files;UML class diagrams;XML format","","1","9","","","","","","IEEE","IEEE Conferences"
"An approach for collaborative code reviews using multi-touch technology","S. Müller; M. Würsch; T. Fritz; H. C. Gall","s.e.a.l. - software architecture and evolution lab, Department of Informatics, University of Zurich, Switzerland; s.e.a.l. - software architecture and evolution lab, Department of Informatics, University of Zurich, Switzerland; s.e.a.l. - software architecture and evolution lab, Department of Informatics, University of Zurich, Switzerland; s.e.a.l. - software architecture and evolution lab, Department of Informatics, University of Zurich, Switzerland","2012 5th International Workshop on Co-operative and Human Aspects of Software Engineering (CHASE)","","2012","","","93","99","Code reviews are an effective mechanism to improve software quality, but often fall short in the development of software. To improve the desirability and ease of code reviews, we introduce an approach that explores how multi-touch interfaces can support code reviews and can make them more collaborative. Our approach provides users with features to collaboratively find and investigate code smells, annotate source code and generate review reports using gesture recognition and a Microsoft Surface Table. In a preliminary evaluation, subjects generally liked the prototypical implementation of our approach for performing code review tasks.","","978-1-4673-1824-2978-1-4673-1823","10.1109/CHASE.2012.6223031","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6223031","Multi-touch;software metrics;code review;collaboration;code smell;gesture","Software metrics;Collaboration;Prototypes;Visualization;Data visualization;Surgery;Gesture recognition","gesture recognition;groupware;haptic interfaces;software quality;software reviews","collaborative code reviews;multitouch technology;software quality;software development;multitouch interfaces;code smells;gesture recognition;Microsoft Surface Table;prototypical implementation","","5","16","","","","","","IEEE","IEEE Conferences"
"Test software evaluation using data logging [missile testing]","W. Chou; J. L. Anderson","Corona Div., NSWC, Corona, CA, USA; Corona Div., NSWC, Corona, CA, USA","Proceedings AUTOTESTCON 2003. IEEE Systems Readiness Technology Conference.","","2003","","","652","657","As the missile technology and capability become increasingly sophisticated, the test system software has become more complex. Because of this, the degree of difficulty has also increased in the area of verification and validation of the test software. This paper proposes that a test software evaluation tool (TSET) be developed to use data logged during the execution of test programs, minimizing the traditional manual code review, to perform software evaluation.","1080-7725","0-7803-7837","10.1109/AUTEST.2003.1243646","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1243646","","Software testing;System testing;Missiles;Instruments;Corona;Software performance;Performance evaluation;Automatic testing;Firewire;System software","missiles;military computing;aerospace testing;automatic test software;program verification","automatic test systems;missile testing;test software evaluation tool;TSET;logged test program execution data;manual code review;data logging;missile technology;test system software;software verification;software validation","","","4","","","","","","IEEE","IEEE Conferences"
"ViDI: The Visual Design Inspector","Y. Tymchuk; A. Mocci; M. Lanza","NA; NA; NA","2015 IEEE/ACM 37th IEEE International Conference on Software Engineering","","2015","2","","653","656","We present ViDI (Visual Design Inspector), a novel code review tool which focuses on quality concerns and design inspection as its cornerstones. It leverages visualization techniques to represent the reviewed software and augments the visualization with the results of quality analysis tools. To effectively understand the contribution of a reviewer in terms of the impact of her changes on the overall system quality, ViDI supports the recording and further inspection of reviewing sessions. ViDI is an advanced prototype which we will soon release to the Pharo open-source community.","0270-5257;1558-1225","978-1-4799-1934","10.1109/ICSE.2015.215","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203035","Lugano","Visualization;Inspection;Quality assessment;Software systems;Software engineering;Birds","data visualisation;software quality;software reviews;software tools","ViDI;visual design inspector;code review tool;visualization technique;system quality","","1","11","","","","","","IEEE","IEEE Conferences"
"Meeting customer needs using participatory techniques","C. Wood","Dept. of Defence, DSTO, Canberra, ACT, Australia","Proceedings 1998 Australasian Computer Human Interaction Conference. OzCHI'98 (Cat. No.98EX234)","","1998","","","336","","I have used participatory design techniques on a number of projects, including the design of a GUI for a group meeting support system and the design of a multimodal information management tool. This technique has been used to scope functionality, produce a project plan, design the system, create and usability-test the user documentation, and facilitate best-practice principles in code review and software engineering. Using participatory methods has also facilitated team development and cohesion in a team that is geographically dispersed and consists of members from diverse backgrounds.","","0-8186-9206","10.1109/OZCHI.1998.732236","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=732236","","Usability;Graphical user interfaces;System testing;Electrical capacitance tomography;Design methodology;Object oriented methods;Iterative methods;Collaboration;Materials testing;System analysis and design","user centred design;graphical user interfaces;group decision support systems;planning;project management;testing;user manuals;human factors;software engineering","customer needs;participatory design techniques;GUI design;group meeting support system;multimodal information management tool;functionality scoping;project plan;system design;usability testing;user documentation;best-practice principles;code review;software engineering;team development;team cohesion;geographically dispersed team;diverse team member backgrounds","","","1","","","","","","IEEE","IEEE Conferences"
"An activity based learning: C programming","V. S. Handur; P. D. Kalwad; N. Yaligar; V. G. Garagad; M. K. Pawar","Dept. of Computer Science and Engineering, B.V. Bhoomaraddi College of Engineering and Technology, Hubballi, India; Dept. of Computer Science and Engineering, B.V. Bhoomaraddi College of Engineering and Technology, Hubballi, India; Dept. of Computer Science and Engineering, B.V. Bhoomaraddi College of Engineering and Technology, Hubballi, India; Dept. of Computer Science and Engineering, B.V. Bhoomaraddi College of Engineering and Technology, Hubballi, India; Dept. of Computer Science and Engineering, B.V. Bhoomaraddi College of Engineering and Technology, Hubballi, India","2015 IEEE 3rd International Conference on MOOCs, Innovation and Technology in Education (MITE)","","2015","","","310","314","Computers are the leading technology of the 21st century. Programming, the development of software is thus a fundamental activity in which many people are engaged worldwide. Therefore programming courses are included as a part of the curriculum. In these courses, students are primarily introduced to language features. Traditionally, the students practice by applying the acquired knowledge to solve some logically straightforward problems giving less scope for the programming skills. This paper focuses on application of coding standards, coding techniques, debugging, code review, refactoring, code optimization, test driven programming and pair programming based learning to master not only programming language features, but also an integrated approach to gain problem solving and programming skills. The subject is introduced as a first year course where the students are without any or with smaller amount of background or experience in computer programming. Taking this into consideration, activities like programming were designed. These activities enhanced the learning ability, problem solving skills programming skills and debugging skills.","","978-1-4673-6747-9978-1-4673-6746","10.1109/MITE.2015.7375336","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7375336","problem solving;programming skills;code optimization;Test driven programming;debugging;coding standards","Programming profession;Education;Encoding;Standards;Problem-solving;Debugging","C language;computer science education;educational courses;program debugging;software maintenance","activity-based learning;C programming course;software development;programming skills;coding standards;coding techniques;code review;refactoring;code optimization;test driven programming;pair programming based learning;programming language features;integrated approach;problem solving skills;computer programming;learning ability enhancement;debugging skills","","1","6","","","","","","IEEE","IEEE Conferences"
"Mutation-based exploration of a method for verifying concurrent Java components","B. Long; R. Duke; D. Goldson; P. Strooper; L. Wildman","Sch. of Inf. Technol. & Electr. Eng., Queensland Univ., Brisbane, Qld., Australia; Sch. of Inf. Technol. & Electr. Eng., Queensland Univ., Brisbane, Qld., Australia; Sch. of Inf. Technol. & Electr. Eng., Queensland Univ., Brisbane, Qld., Australia; Sch. of Inf. Technol. & Electr. Eng., Queensland Univ., Brisbane, Qld., Australia; Sch. of Inf. Technol. & Electr. Eng., Queensland Univ., Brisbane, Qld., Australia","18th International Parallel and Distributed Processing Symposium, 2004. Proceedings.","","2004","","","265","","Summary form only given. The Java programming language supports concurrency. Concurrent programs are harder to verify than their sequential counterparts due to their inherent nondeterminism and a number of specific concurrency problems such as interference and deadlock. In previous work, we proposed a method for verifying concurrent Java components based on a mix of code inspection, static analysis tools, and the ConAn testing tool. The method was derived from an analysis of concurrency failures in Java components, but was not applied in practice. In this paper, we explore the method by applying it to an implementation of the well-known readers-writers problem and a number of mutants of that implementation. We only apply it to a single, well-known example, and so we do not attempt to draw any general conclusions about the applicability or effectiveness of the method. However, the exploration does point out several strengths and weaknesses in the method, which enable us to fine-tune the method before we carry out a more formal evaluation on other, more realistic components.","","0-7695-2132","10.1109/IPDPS.2004.1303338","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1303338","","Java;Concurrent computing;Yarn;Australia;Interference;System recovery;Inspection;Testing;Failure analysis;Application software","Java;parallel programming;object-oriented programming;formal verification","mutation-based exploration;Java components;Java programming language;concurrent programs;code inspection;static analysis tools;readers-writers problem;formal evaluation","","7","30","","","","","","IEEE","IEEE Conferences"
"Code Comprehension Activities in Undergraduate Software Engineering Course - A Case Study","S. K. Sripada; Y. R. Reddy","NA; NA","2015 24th Australasian Software Engineering Conference","","2015","","","68","77","In industry, inspections, reviews, and refactoring are considered as necessary software engineering activities for enhancing quality of code. In academia, such activities are rarely taught and practiced at Undergraduate level due to various reasons like limited skill set, limited knowledge of the available tools, time constraints, project setting, project client availability, flexibility with Syllabus, etc. However, we argue that such activities are an essential part of introductory software engineering courses and can result in improvement of coding skills, knowledge of coding standard and compliance to the same, and peer communication within teams. We have studied the use of such activities in a sophomore level Software Engineering course consisting of more than 200 students working in teams on projects from start-ups and present our experiences, findings and challenges. We present the results of quantitative evaluation of the impact of code comprehension activities before and after each iteration of the team projects.","1530-0803","978-1-4673-9390","10.1109/ASWEC.2015.18","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7365795","Code Inspection;Code Reviews;Program Comprehension;Refactoring;Static Code Analysis;Textual Analysis","Measurement;Inspection;Software engineering;Software;Standards;Encoding;Writing","computer science education;educational courses;further education;software engineering","undergraduate software engineering course;code comprehension activities;introductory software engineering courses","","","23","","","","","","IEEE","IEEE Conferences"
"Introducing Circa: A dataflow-based language for live coding","A. Fischer","Shutterfly, USA","2013 1st International Workshop on Live Programming (LIVE)","","2013","","","5","8","In a live programming environment, the state of the running program is available during the editing process. An ideal live programming system should be able to harness the live program to offer improved abilities for code creation and manipulation. We introduce Circa, a language and platform designed to address this need. We argue in favor of a dataflow-based model of computation, and we show how this format enables useful methods of code inspection and manipulation. We present a framework based on the backpropogation algorithm that allows the user to manipulate their program by expressing a desire against the program's result. We discuss how these code editing abilities can combine to produce a highly effective environment.","","978-1-4673-6265","10.1109/LIVE.2013.6617339","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6617339","Live coding;dataflow programming","Runtime;Programming;Computational modeling;Visualization;Sprites (computer);Encoding;Mice","data flow analysis;encoding;inspection;parallel languages","Circa;dataflow-based language;live coding;live programming environment;running program;editing process;code inspection;code manipulation","","1","6","","","","","","IEEE","IEEE Conferences"
"A low noise 65nm 1.2V 7-bit 1GSPS CMOS folding A/D converter with a digital self-calibration technique","D. Choi; D. Kim; K. Cho; D. Kim; M. Song","Dongguk Univ-Seoul, Dept. of Semiconductor Science, Seoul 100715, South Korea; Dongguk Univ-Seoul, Dept. of Semiconductor Science, Seoul 100715, South Korea; Dongguk Univ-Seoul, Dept. of Semiconductor Science, Seoul 100715, South Korea; Dongguk Univ-Seoul, Dept. of Semiconductor Science, Seoul 100715, South Korea; Dongguk Univ-Seoul, Dept. of Semiconductor Science, Seoul 100715, South Korea","2010 International SoC Design Conference","","2010","","","194","197","In this paper, a 65nm 1.2V 7-bit 1GSPS A/D converter with a self-calibration technique is proposed. The A/D converter is based on a folding-interpolation structure whose folding rate is 2, interpolation rate is 8. An offset self-calibration circuit with a feedback loop and a recursive digital code inspection is described. The offset self-calibration circuit reduces the variation of the offset voltage, due to process mismatches, parasitic resistors, and parasitic capacitances. The chip has been fabricated with a 65nm 1-poly 6-metal CMOS technology. The effective chip area is 0.87mm<sup>2</sup> and the power consumption is about 110mW at 1.2V power supply. The measured SNDR is about 38.48dB when the input frequency is 250MHz at 1GHz sampling frequency. The measured SNDR is 3dB higher than the same ADC without any calibration.","","978-1-4244-8632-8978-1-4244-8633-5978-1-4244-8631","10.1109/SOCDC.2010.5682940","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5682940","A/D Converter;Folding;Interpolation;Self-Calibration","","analogue-digital conversion;CMOS integrated circuits;interpolation;resistors","1GSPS CMOS;A/D converter;digital self-calibration technique;folding-interpolation structure;offset self-calibration circuit;feedback loop;recursive digital code inspection;process mismatches;parasitic resistor;parasitic capacitance;SNDR;size 65 nm;voltage 1.2 V;power 110 mW;word length 7 bit;frequency 250 MHz;frequency 1 GHz","","","5","","","","","","IEEE","IEEE Conferences"
"A digitally self-calibrated low-noise 7-bit folding A/D converter","M. Kwon; D. Kim; D. Kim; J. Moon; M. Song","Dept. of Semiconductor Science, Dongguk university, Seoul, 100-715, Korea; Dept. of Semiconductor Science, Dongguk university, Seoul, 100-715, Korea; Dept. of Semiconductor Science, Dongguk university, Seoul, 100-715, Korea; Dept. of Semiconductor Science, Dongguk university, Seoul, 100-715, Korea; Dept. of Semiconductor Science, Dongguk university, Seoul, 100-715, Korea","23rd IEEE International SOC Conference","","2010","","","39","43","In this paper, a low noise 65nm 1.2V 7-bit 1GSPS A/D converter with a digitally self-calibrated technique is proposed. The A/D converter is based on a folding-interpolation structure whose folding rate is 2 and its interpolation rate is 8. A digitally self-calibrated technique with a feedback loop and a recursive digital code inspection is described. The circuit reduces the variation of the offset voltage, due to process mismatches, parasitic resistors, and parasitic capacitances. The chip has been fabricated with a 65nm 1-poly 6-metal CMOS technology. The effective chip area is 0.87mm2 and the power consumption is about 110mW with a 1.2V power supply. The measured SNDR is drastically improved in comparison with the same ADC without any calibration.","2164-1706;2164-1676","978-1-4244-6683-2978-1-4244-6682-5978-1-4244-6681","10.1109/SOCC.2010.5784637","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5784637","","Calibration;Preamplifiers;Interpolation;Clocks;Distortion measurement;Measurement uncertainty;Metals","analogue-digital conversion;calibration;capacitance;feedback;interpolation;low-power electronics;power supply circuits;recursive estimation;resistors","digitally self-calibrated low-noise folding A/D converter;1GSPS A/D converter;digitally self-calibrated technique;folding-interpolation structure;folding rate;interpolation rate;feedback loop;recursive digital code inspection;offset voltage;process mismatches;parasitic resistors;parasitic capacitances;1-poly 6-metal CMOS technology;power consumption;power supply;SNDR;ADC;word length 7 bit;voltage 1.2 V","","","7","","","","","","IEEE","IEEE Conferences"
"Integrated Formal Methods for Constructing Assurance Cases","C. Cârlan; T. A. Beyene; H. Ruess","NA; NA; NA","2016 IEEE International Symposium on Software Reliability Engineering Workshops (ISSREW)","","2016","","","221","228","The use of formal methods in verification activities is well established in various dedicated safety standards. Deficits in the verification process may have a negative impact on the confidence of verification results. Safety standards promote the use of integrated formal methods when a single method cannot achieve the verification objective without specifying how. In this paper, we take on the problem of using outputs from integrated formal methods as evidence in assurance cases, which are used in certification of safety-critical systems. We first present two workflows that employ integrated formal methods - code review workflow and code coverage workflow - corresponding to two of the most important activities of the verification phase. Then, we show how each workflow and the outputs from its integrated formal methods can be used in creating an assurance argument. These assurance arguments offer evidence for undeveloped goals identified in previous works from the field.","","978-1-5090-3601-1978-1-5090-3602","10.1109/ISSREW.2016.21","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7789404","assurance cases;integrated formal methods;confidence;testing;code coverage;assurance deficits;code review","Safety;Standards;Testing;Software;Encoding;Uncertainty;Employment","certification;formal verification;safety-critical software;software reviews","assurance case construction;integrated formal methods;certification;safety-critical systems;code review workflow;code coverage workflow;verification phase;assurance argument","","1","","","","","","","IEEE","IEEE Conferences"
"Tailoring a COTS group support system for software requirements inspection","M. Halling; P. Grunbacher; S. Biffl","Inst. for SW Technol., Vienna Univ. of Technol., Austria; NA; NA","Proceedings 16th Annual International Conference on Automated Software Engineering (ASE 2001)","","2001","","","201","208","The inspection of early life-cycle artifacts such as requirement documents promises great benefits. However, research demonstrates that the inspection process is complex and expensive and that tool support would be highly desirable. Existing inspection tools focus largely on the inspection of source code. We have therefore devised groupware support for inspecting requirements. Based on our experience with adopting a group support system (GSS) for requirements negotiation, we decided to tailor this commercial GSS to support inspection of requirements. The paper discusses our concept of a Groupware-supported Requirements Inspection Process (GRIP) and shows that tailoring a COTS GSS works well to automate this process.","1938-4300","0-7695-1426","10.1109/ASE.2001.989806","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=989806","","Collaborative software;Costs;Software systems;Inspection;Collaborative work;Software tools;Automation;Software engineering;Yarn;Performance evaluation","groupware;formal specification;software tools;inspection;program verification","COTS group support system;software requirements inspection;early life-cycle artifact inspection;requirement documents;inspection process;tool support;inspection tools;source code inspection;groupware support;group support system;requirements negotiation;commercial GSS;Groupware supported Requirements Inspection Process;GRIP;COTS GSS;computer-supported cooperative work","","11","23","","","","","","IEEE","IEEE Conferences"
"Software Analytics: Challenges and Opportunities","L. Guerrouj; O. Baysal; D. Lo; F. Khomh","NA; NA; NA; NA","2016 IEEE/ACM 38th International Conference on Software Engineering Companion (ICSE-C)","","2016","","","902","903","Nowadays, software development projects produce a large number of software artifacts including source code, execution traces, end-user feedback, as well as informal documentation such as developers' discussions, change logs, StackOverflow, and code reviews. Such data embeds rich and significant knowledge about software projects, their quality and services, as well as the dynamics of software development. Most often, this data is not organized, stored, and presented in a way that is immediately useful to software developers and project managers to support their decisions. To help developers and managers understand their projects, how they evolve, as well as support them during their decision-making process, software analytics -- use of analysis, data, and systematic reasoning for making decisions -- has become an emerging field of modern data analysis. While results obtained from analytics-based solutions suggested so far are promising, there are still several challenges associated with the adoption of software analytics into software development processes, as well as the development and integration of analytics tools in practical settings. We therefore propose a tutorial on software analytics. The tutorial will start with an introduction of software analytics. Next, we will discuss the main challenges and opportunities associated with software analytics based on the examples from our own research. These examples will cover a range of topics leveraging software analytics. The topics include mobile apps quality, code review process and its quality, analytics for the software engineering Twitter space, as well as the use of analytics to solve scheduling problems in the cloud.","","978-1-4503-4205-6978-1-5090-2245","","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7883436","Software Analytics;Challenges;Opportunities","Software;Software engineering;Tutorials;Data mining;Mobile communication;Twitter;Conferences","data analysis;software development management","software development processes;cloud scheduling problems;software engineering Twitter space analytics;code quality;code review process;mobile apps quality;data analysis;software analytics","","","","","","","","","IEEE","IEEE Conferences"
"An RFID and sensor web-enabled smart electric power equipment inspection system","D. Li; N. Chen; C. Xiao; J. Gong","State Key Laboratory for Information Engineering in Surveying, Mapping and Remote Sensing, Wuhan University, 129 Luoyu Road, Wuhan 430079, China; State Key Laboratory for Information Engineering in Surveying, Mapping and Remote Sensing, Wuhan University, 129 Luoyu Road, Wuhan 430079, China; State Key Laboratory for Information Engineering in Surveying, Mapping and Remote Sensing, Wuhan University, 129 Luoyu Road, Wuhan 430079, China; State Key Laboratory for Information Engineering in Surveying, Mapping and Remote Sensing, Wuhan University, 129 Luoyu Road, Wuhan 430079, China","2017 25th International Conference on Geoinformatics","","2017","","","1","4","People's daily lives depend on the power supply almost uninterruptedly in contemporary society, and the safe operation of power system is an important basis to ensure the safety and stability of industrial production and people's lives. Thus, inspection is necessary to ensure the safe operation of power facilities. Nowadays, there are three main kinds of inspection methods: traditional manual inspection, two-dimensional code inspection and inspection robot. However, each of the existing inspection method has its own disadvantages such as low efficiency, contact inspections and so on. Therefore, it makes sense to design a system to improve the efficiency and intelligence level, what is this paper does. The system in this paper has two main advantages RFID and multi-sensors, and the first realized a contactless and uniquely identified inspection, the second achieve all-day and real-time environmental monitoring. Above all, the system can realize a contactless, more comprehensive and effective inspection.","2161-0258","978-1-5386-2266-7978-1-5386-2267","10.1109/GEOINFORMATICS.2017.8090921","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8090921","smart inspection;Radio Frequncey Identification (RFID);Sensor Web;WebGIS;smart city","Inspection;Radiofrequency identification;Smart cities;Service-oriented architecture","inspection;power apparatus;radiofrequency identification;sensor fusion","manual inspection;inspection method;sensor web-enabled smart electric power equipment inspection system;real-time environmental monitoring;contactless inspection;uniquely identified inspection;contactless identified inspection;multisensors;intelligence level;contact inspections;inspection robot;two-dimensional code inspection;inspection methods;power facilities;industrial production;stability;power system;power supply","","","11","","","","","","IEEE","IEEE Conferences"
"Extracting artifact lifecycle models from metadata history","O. Baysal; O. Kononenko; R. Holmes; M. W. Godfrey","David R. Cheriton School of Computer Science, University of Waterloo, Canada; David R. Cheriton School of Computer Science, University of Waterloo, Canada; David R. Cheriton School of Computer Science, University of Waterloo, Canada; David R. Cheriton School of Computer Science, University of Waterloo, Canada","2013 1st International Workshop on Data Analysis Patterns in Software Engineering (DAPSE)","","2013","","","17","19","Software developers and managers make decisions based on the understanding they have of their software systems. This understanding is both built up experientially and through investigating various software development artifacts. While artifacts can be investigated individually, being able to summarize characteristics about a set of development artifacts can be useful. In this paper we propose lifecycle models as an effective way to gain an understanding of certain development artifacts. Lifecycle models capture the dynamic nature of how various development artifacts change over time in a graphical form that can be easily understood and communicated. Lifecycle models enables reasoning of the underlying processes and dynamics of the artifacts being analyzed. In this paper we describe how lifecycle models can be generated and demonstrate how they can be applied to the code review process of a development project.","","978-1-4673-6296","10.1109/DAPSE.2013.6603803","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6603803","","Data models;History;Software;Time measurement;Educational institutions;Control systems;Data mining","meta data;software engineering","artifact lifecycle model extraction;metadata history;software systems;software development artifacts;code review process;software development project","","","2","","","","","","IEEE","IEEE Conferences"
"Which review feedback did long-term contributors get on OSS projects?","T. Norikane; A. Ihara; K. Matsumoto","Graduate School of Information Science, Nara Institute of Science and Technology, JAPAN; Graduate School of Information Science, Nara Institute of Science and Technology, JAPAN; Graduate School of Information Science, Nara Institute of Science and Technology, JAPAN","2017 IEEE 24th International Conference on Software Analysis, Evolution and Reengineering (SANER)","","2017","","","571","572","Open Source Software (OSS) cannot exist without contributions from the community. In particular, long-term contributors (LTCs) (e.g., committer), defined as contributors who spend at least one year on OSS projects, play crucial role in a project success because they would have permission to add (commit) code changes to a project's version control system, and to become a mentor for a beginner in OSS projects. However, contributors often leave a project before becoming a LTC because most contributors are volunteers. If contributors are motivated in their work in OSS projects, they might not leave the projects. In this study, we examine the phenomena involved in becoming a LTC in terms of motivation to continue in OSS projects. In particular, our target motivation is to understand what is involved in long-term contribution with other expert contributors. We study classifier to identify a LTC who will contribute patch submissions for more than one year based on collaboration in terms of the code review process. In detail, we analyze what review feedbacks encourage a contributor to continue with OSS project. Using a Qt project dataset, we understand review feedback which affected contribution period of the developer.","","978-1-5090-5501-2978-1-5090-5502","10.1109/SANER.2017.7884682","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7884682","","Software engineering;Collaboration;Open source software;Control systems;Databases;Documentation","configuration management;public domain software","open source software;long-term contributors;OSS projects;commit code changes;project version control system;LTC;patch submissions;code review process;review feedbacks;Qt project dataset","","","8","","","","","","IEEE","IEEE Conferences"
"Security Engineering Based on Structured Formal Reasoning","A. Fuchs; C. Rudolph","NA; NA","2012 ASE/IEEE International Conference on BioMedical Computing (BioMedCom)","","2012","","","145","152","Security by Design and Secure Engineering are among the most pressing challenges in IT Security research and practice. Increased attacker potential and dependence on IT-Systems in economy and in critical infrastructures cause a higher demand in securely engineered systems and thus in new approaches and methodologies. This paper introduces a consistent methodology for designing secure systems during the specification phase. The Security Modeling Framework SeMF serves as basis for its security vocabulary. We extend SeMF by the concept of SeMF Building Blocks SeBBs as reasoning tool and provide a security design process utilizing them as refinement artifacts. This process guides the decision making during the system specification phase focused on the security aspects and integrates with refinement driven functional engineering processes. Our approach further results in a security design documentation and residual assumptions that can serve as a basis for risk assessment, code review, and organizational security means during deployment.","","978-1-4673-5495-0978-0-7695-4938","10.1109/BioMedCom.2012.30","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6516443","security by design;security engineering;formal methods;formal languages","","formal specification;functional programming;reasoning about programs;risk analysis;security of data","security engineering;structured formal reasoning;security by design;secure engineering;IT security research;attacker potential;IT system;economy;critical infrastructure;secure system design;Security Modeling Framework;security vocabulary;SeMF building blocks;SeBB;reasoning tool;refinement artifact;decision making;system specification;security aspect;refinement driven functional engineering process;security design documentation;residual assumption;risk assessment;code review;organizational security","","","29","","","","","","IEEE","IEEE Conferences"
"A New Framework of Security Vulnerabilities Detection in PHP Web Application","Z. Jingling; G. Rulin","NA; NA","2015 9th International Conference on Innovative Mobile and Internet Services in Ubiquitous Computing","","2015","","","271","276","Nowadays, Web applications provide us most of the Internet services, but also give birth to more and more new types of Internet applications. While, according to the developers' programming techniques and safety awareness, there are many kinds of Web application security flaws and vulnerabilities hiding in the program. So it is very important to improve their reliability and security. Usually people use code review based on static or dynamic analysis to detect security vulnerabilities, but each method has shortcomings that can't overcome easily which can result in a big number of false positives and omission. To address this issue, this paper proposed a new framework of detecting security vulnerabilities of PHP web application. In this framework, we combine dynamic and static analysis to make full use of the advantages of the two, greatly improve the efficiency of detection. An implementation based on this framework has also been completed and it will also be presented in the paper.","","978-1-4799-8873-0978-1-4799-8872","10.1109/IMIS.2015.42","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7284959","code audit;static analysis;dynamic analysis;PHP code review","Uniform resource locators;Security;Indexes;Testing;Data structures;Virtual machining","Internet;telecommunication security","security vulnerabilities detection;PHP Web application;Internet services;Internet applications;safety awareness;security flaws;code review;static analysis;dynamic analysis","","","12","","","","","","IEEE","IEEE Conferences"
"Empirical software evolvability - code smells and human evaluations","M. V. Mántylá","SoberIT, Department of Computer Science, School of Science and Technology, Aalto University, P.O. Box 19210, FI-00760, Finland","2010 IEEE International Conference on Software Maintenance","","2010","","","1","6","Low software evolvability may increase costs of software development for over 30%. In practice, human evaluations and discoveries of software evolvability dictate the actions taken to improve the software evolvability, but the human side has often been ignored in prior research. This dissertation synopsis proposes a new group of code smells called the solution approach, which is based on a study of 563 evolvability issues found in industrial and student code reviews. Solution approach issues require re-thinking of the existing implementation rather than just reorganizing the code through refactoring. This work also contributes to the body of knowledge about software quality assurance practices by confirming that 75% of defects found in code reviews affect software evolvability rather than functionality. We also found evidence indicating that context-specific demographics, i.e., role in organization and code ownership, affect evolvability evaluations, but general demographics, i.e., work experience and education, do not.","1063-6773;1063-6773","978-1-4244-8629-8978-1-4244-8630-4978-1-4244-8628","10.1109/ICSM.2010.5609545","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5609545","Doctoral dissertation synopsis;code smells;empirical study;code review;human evaluation;software maintainability","Book reviews;Silicon;Software;Humans","program diagnostics;software performance evaluation;software prototyping;software quality","empirical software evolvability;code smells;human evaluations;software development;refactoring;software quality assurance","","1","19","","","","","","IEEE","IEEE Conferences"
"Machine vision in the tire industry","G. F. Blackwell","Allen-Bradley Co., Milwaukee, WI, USA","Forty-First Annual Conference of Electrical Engineering Problems in the Rubber and Plastics Industries","","1989","","","67","79","The author examines the use of machine vision as an intelligent sensor for the acquisition of process data and the ways in which the data can be assimilated into closed-loop control of the tire manufacturing process. He first describes how process data can be collected with vision sensors. Specific application examples are given. The various methods by which this process data can be integrated into an automatic control system for closed-loop feedback are discussed. Some of the application issues involved when vision sensor technology is used in the tire manufacturing environment are examined. Applications of machine vision in the tire industry can be classified as noncontact measurement, assembly verification, and product identification. Depending on the degree of process automation, the vision system can supply a simple accept/reject signal, actual results data, or an identification code. It is noted that the implementation of vision sensors has been somewhat hindered because of the harsh environment present in the tire manufacturing process. Techniques are available for dealing with these environmental concerns and must be incorporated into the system design from the beginning. It is concluded that the real benefit of machine vision is realized when the inspection data can be tied back into the machine control architecture for true automatic closed-loop process modification.<<ETX>>","","","10.1109/RAPCON.1989.47718","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=47718","","Machine vision;Tires;Manufacturing industries;Intelligent sensors;Automatic control;Manufacturing processes;Sensor phenomena and characterization;Feedback;Electrical equipment industry;Machinery production industries","closed loop systems;computer vision;inspection;manufacturing computer control;rubber industry","tyre industry;rubber industry;accept signal;reject signal;machine vision;closed-loop control;tire manufacturing process;vision sensors;automatic control system;identification code;inspection data","","","","","","","","","IEEE","IEEE Conferences"
"Adopting Code Reviews for Agile Software Development","M. Bernhart; A. Mauczka; T. Grechenig","NA; NA; NA","2010 Agile Conference","","2010","","","44","47","Code reviews have many benefits, most importantly to find bugs early in the development phase and to enforce coding standards. Still, it is widely accepted that formal code reviews are time-consuming and the practical applicability in agile development is controversial. This work presents a continuous differential-based method and tool for code reviews. By using a continuous approach to code reviews, the review overhead can be reduced and the effectiveness and applicability in agile environments shall be improved.","","978-1-4244-7731","10.1109/AGILE.2010.18","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5562809","Tools;Code design;Code tuning;Code reviews;Continuous","Book reviews;Inspection;Software;Programming;Software engineering;Java;USA Councils","program debugging;software development management;software prototyping;software tools","code review;agile software development;coding standards;agile development;continuous differential based method","","8","26","","","","","","IEEE","IEEE Conferences"
"An Empirical Study on Factors Impacting Bug Fixing Time","F. Zhang; F. Khomh; Y. Zou; A. E. Hassan","NA; NA; NA; NA","2012 19th Working Conference on Reverse Engineering","","2012","","","225","234","Fixing bugs is an important activity of the software development process. A typical process of bug fixing consists of the following steps: 1) a user files a bug report, 2) the bug is assigned to a developer, 3) the developer fixes the bug, 4) changed code is reviewed and verified, and 5) the bug is resolved. Many studies have investigated the process of bug fixing. However, to the best of our knowledge, none has explicitly analyzed the interval between bug assignment and the time when bug fixing starts. After a bug assignment, some developers will immediately start fixing the bug while others will start bug fixing after a long period. We are blind on developer's delays when fixing bugs. This paper explores such delays of developers through an empirical study on three open source software systems. We examine factors affecting bug fixing time along three dimensions: bug reports, source code involved in the fix, and code changes that are required to fix the bug. We further compare different factors by descriptive logistic regression models. Our results can help development teams better understand factors behind delays, and then improve bug fixing process.","2375-5369;1095-1350","978-0-7695-4891-3978-1-4673-4536","10.1109/WCRE.2012.32","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6385118","bug fixing process;change request;fixing time;empirical software engineering;bug report;mylyn","Delay;Computer bugs;Operating systems;Distributed Bragg reflectors;Logistics;History","program debugging;public domain software;regression analysis;software engineering","bug fixing time;software development process;bug report;code review;code verification;bug resolution;bug assignment;bug fixing;open source software system;source code;code change;descriptive logistic regression model","","18","21","","","","","","IEEE","IEEE Conferences"
"How Maintainability Issues of Android Apps Evolve","I. Malavolta; R. Verdecchia; B. Filipovic; M. Bruntink; P. Lago","NA; NA; NA; NA; NA","2018 IEEE International Conference on Software Maintenance and Evolution (ICSME)","","2018","","","334","344","Context. Android is the largest mobile platform today, with thousands of apps published and updated in the Google Play store everyday. Maintenance is an important factor in Android apps lifecycle, as it allows developers to constantly improve their apps and better tailor them to their user base. Goal. In this paper we investigate the evolution of various maintainability issues along the lifetime of Android apps. Method. We designed and conducted an empirical study on 434 GitHub repositories containing open, real (i.e., published in the Google Play store), and actively maintained Android apps. We statically analyzed 9,945 weekly snapshots of all apps for identifying their maintainability issues over time. We also identified maintainability hotspots along the lifetime of Android apps according to how their density of maintainability issues evolves over time. More than 2,000 GitHub commits belonging to identified hotspots have been manually categorized to understand the context in which maintainability hotspots occur. Results. Our results shed light on (i) how often various types of maintainability issues occur over the lifetime of Android apps, (ii) the evolution trends of the density of maintainability issues in Android apps, and (iii) an in-depth characterization of development activities related to maintainability hotspots. Together, these results can help Android developers in (i) better planning code refactoring sessions, (ii) better planning their code review sessions (e.g., steering the assignment of code reviews), and (iii) taking special care of their code quality when performing tasks belonging to activities highly correlated with maintainability issues. We also support researchers by objectively characterizing the state of the practice about maintainability of Android apps. Conclusions. Independently from the type of development activity, maintainability issues grow until they stabilize, but are never fully resolved.","2576-3148;1063-6773","978-1-5386-7870-1978-1-5386-7871","10.1109/ICSME.2018.00042","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8530041","Maintainability;Android;Empirical study","Google;Tools;Market research;Planning;Open source software;Computer bugs","Android (operating system);mobile computing;public domain software;software maintenance","maintainability issues;Google Play store;Android apps lifecycle;maintainability hotspots;GitHub repositories;Android developers;code refactoring sessions;code review sessions;code quality","","","46","","","","","","IEEE","IEEE Conferences"
"The Firefox Temporal Defect Dataset","M. Habayeb; A. Miranskyy; S. S. Murtaza; L. Buchanan; A. Bener","NA; NA; NA; NA; NA","2015 IEEE/ACM 12th Working Conference on Mining Software Repositories","","2015","","","498","501","The bug tracking repositories of software projects capture initial defect (bug) reports and the history of interactions among developers, testers, and customers. Extracting and mining information from these repositories is time consuming and daunting. Researchers have focused mostly on analyzing the frequency of the occurrence of defects and their attributes (e.g., The number of comments and lines of code changed, count of developers). However, the counting process eliminates information about the temporal alignment of events leading to changes in the attributes count. Software quality teams could plan and prioritize their work more efficiently if they were aware of these temporal sequences and knew their frequency of occurrence. In this paper, we introduce a novel dataset mined from the Fire fox bug repository (Bugzilla) which contains information about the temporal alignment of developer interactions. Our dataset covers eight years of data from the Fire fox project on activities throughout the project's lifecycle. Some of these activities have not been reported in frequency-based or other temporal datasets. The dataset we mined from the Fire fox project contains new activities, such as reporter experience, file exchange events, code-review process activities, and setting of milestones. We believe that this new dataset will improve analysis of bug reports and enable mining of temporal relationships so that practitioners can enhance their bug-fixing process.","2160-1852;2160-1860","978-0-7695-5594","10.1109/MSR.2015.73","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7180127","Bug repositories;Dataset;Temporal activities;Bug reports;Defect tracking","Data mining;Computer bugs;History;Software;Feature extraction;Communities;Software engineering","data mining;program debugging;project management;search engines","Firefox temporal defect dataset;bug tracking repositories;software projects;information mining;information extraction;frequency analysis;defect occurrence;defect attributes;code lines;developer count;temporal event alignment;attribute count;software quality teams;temporal sequences;occurrence frequency;Firefox bug repository;Bugzilla;developer interactions;project lifecycle;frequency-based activities;temporal datasets;reporter experience;file exchange events;code-review process activities;bug report analysis improvement;temporal relationship mining;bug-fixing process","","3","12","","","","","","IEEE","IEEE Conferences"
"Software inspections in practice","V. Savkin","CQG, USA","2009 5th Central and Eastern European Software Engineering Conference in Russia (CEE-SECR)","","2009","","","223","227","Software inspections are one of effective software engineering instrument for improving software quality. According to statistic information inspection effectiveness in finding defects is about 60% that is 2 times greater than testing effectiveness. But it's not too easy to achieve high stable effectiveness of the inspection process. This paper describes the experience of software inspection process usage in CQG company, where the process has been consistently applied for some years. There will be talking about the process specifics, supporting instruments, metrics and compliance control.","","978-1-4244-5665-9978-1-4244-5664","10.1109/CEE-SECR.2009.5501158","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5501158","software quality;software inspections;code review;metrics","Inspection","software engineering;statistical analysis","software inspections;software engineering instrument;software quality;statistic information inspection;instrument support;compliance control;metric control","","","","","","","","","IEEE","IEEE Conferences"
"Untangling Development Tasks with Software Developer's Activity","M. Konopka; P. Navrat","NA; NA","2015 IEEE/ACM 2nd International Workshop on Context for Software Development","","2015","","","13","14","A combination of several activities is required to solve a development task, but in the end, developer reports only part of it. It is difficult to understand whether all committed files were changed because of the reason in a given description. Software developers work on multiple tasks at once and often fail to distinguish them with separate commits because of their unknowingness, as well as of limitations of the current tools for source code versioning. Our idea is to address this problem with identification of software developer's activities from a stream of interaction data in real time. We attempt to identify situations when a developer has worked on multiple tasks, to prevent him from tangling them in a single commit, or to aid him to separate certain activities from the task, e.g., Floss refactoring.","","978-1-4673-7037","10.1109/CSD.2015.10","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7181499","Tangled change;composite change;developer activity;interaction data;task context;code change;code review","Software;Real-time systems;Context;Monitoring;Switches;Testing;Hidden Markov models","software engineering","software developers;source code versioning","","3","8","","","","","","IEEE","IEEE Conferences"
"Informing development decisions: From data to information","O. Baysal","David R. Cheriton School of Computer Science, University of Waterloo, ON, Canada","2013 35th International Conference on Software Engineering (ICSE)","","2013","","","1407","1410","Software engineers generate vast quantities of development artifacts such as source code, bug reports, test cases, usage logs, etc., as they create and maintain their projects. The information contained in these artifacts could provide valuable insights into the software quality and adoption, as well as development process. However, very little of it is available in the way that is immediately useful to various stakeholders. This research aims to extract and analyze data from software repositories to provide software practitioners with up-to-date and insightful information that can support informed decisions related to the business, management, design, or development of software systems. This data-centric decision-making is known as analytics. In particular, we demonstrate that by employing software development analytics, we can help developers make informed decisions around user adoption of a software project, code review process, as well as improve developers' awareness of their working context.","0270-5257;1558-1225","978-1-4673-3076-3978-1-4673-3073","10.1109/ICSE.2013.6606729","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6606729","","Data mining;Communities;Software systems;Market research;Open source software;Decision making","program diagnostics;program testing;project management;software development management;software quality","software development decision;software engineering;development artifacts;source code;bug reports;test cases;usage logs;software quality;software adoption;development process;software repository;informed decision;software system;data-centric decision-making;software development analytics;software project adoption;code review process;developer awareness improvement","","1","30","","","","","","IEEE","IEEE Conferences"
"Inking in the IDE: Experiences with Pen-based Design and Annotatio","B. Plimmer; J. Grundy; J. Hosking; R. Priest","University of Auckland, Private Bag 92019 Auckland, New Zealand; NA; NA; NA","Visual Languages and Human-Centric Computing (VL/HCC'06)","","2006","","","111","115","Hand-drawn designs and annotations are a common, human-centric approach frequently used during software design and code inspection. We describe our research experiences of adding support for hand-drawn design and annotation to three integrated development environments (IDEs): a software design tool; a user interface design tool; and a programming tool. The aim of this work is to provide users with more natural interaction techniques seamlessly integrated into their IDEs through the use of hand-drawn diagrams, layouts and code mark-ups","1943-6092;1943-6106","0-7695-2586","10.1109/VLHCC.2006.28","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1698771","","Software design;Unified modeling language;Collaborative work;Ink;Collaborative software;User interfaces;Computer science;Inspection;Keyboards;Web pages","programming environments;systems analysis","IDE;pen-based design;pen-based annotation;hand-drawn design;hand-drawn annotation;integrated development environments;software design tool;user interface design tool;programming tool","","3","21","","","","","","IEEE","IEEE Conferences"
"Fifteen principles of software engineering","A. M. Davis","Colorado Univ., Colorado Springs, CO, USA","IEEE Software","","1994","11","6","94","96","Because the product of software engineering is not physical, physical laws do not form a suitable foundation. Instead, software engineering has had to evolve its principles based solely on observations of thousands of projects. The following are probably the 15 most important principles: (1) make quality number one priority; (2) high-quality software is possible; (3) give products to customers early; (4) determine the problem before writing requirements; (5) evaluate design alternatives; (6) use an appropriate process model; (7) use different languages for different phases; (8) minimize intellectual distance; (9) put technique before tools; (10) get it right before you make it faster; (11) inspect code; (12) good management is more important than good technology; (13) people are the key to success; (14) follow hype with care; and (15) take responsibility. An additional 15 software engineering principles are also listed.<<ETX>>","0740-7459;1937-4194","","10.1109/52.329409","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=329409","","Software engineering;Software systems;Prototypes;Feedback;Books;Physics;Biology;Chemistry;Mathematics;Evolution (biology)","software engineering","software engineering principles;quality;early product delivery;requirements;design alternatives;process model;languages;intellectual distance;software techniques;software tools;execution speed;code inspection;management;people;hype;responsibility","","17","2","","","","","","IEEE","IEEE Journals & Magazines"
"A Search Based Context-Aware Approach for Understanding and Localizing the Fault via Weighted Call Graph","J. Tu; X. Xie; Y. Zhou; B. Xu; L. Chen","NA; NA; NA; NA; NA","2016 Third International Conference on Trustworthy Systems and their Applications (TSA)","","2016","","","64","72","Strictly speaking, fault localization includes assessing the code risk of being faulty and identifying the real fault. In practice, only highlighting some possible faulty statements is not helpful enough to reason the roots of the observed failures in a system. Programmers need to manually inspect the highlighted risky statements one by one, reading and understanding their contexts, in order to identify the real faulty ones. However, most related works have been focusing on risk assessment by simply ignoring the fault identification, which makes such techniques much less practical in real world. Therefore, in this paper, we propose a context-aware approach to assist fault comprehension and identification. Built on risk assessment results, our approach searches for the faults on Weighted Call Graph. In our approach the risky statements are re-ordered by function call chains, which can provide much richer information to understand the context and hence reduce the efforts in manual code inspection. Case studies with three open-source systems show that the proposed approach could help to improve the effectiveness of the whole fault localization process.","","978-1-5090-3539-7978-1-5090-3540","10.1109/TSA.2016.20","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7780227","Program comprehension;fault identification;fault localization;weighted call graph","Risk management;Fault diagnosis;Context;Navigation;Inspection;Testing;Debugging","graph theory;program debugging;public domain software;risk management","search based context-aware approach;weighted call graph;code risk assessment;risky statements;fault identification;fault comprehension;function call chains;open-source systems;software fault localization","","","37","","","","","","IEEE","IEEE Conferences"
"Static analysis for web service security - Tools &amp; techniques for a secure development life cycle","A. Masood; J. Java","Graduate School of Computer and Information Science, Nova Southeastern University, USA; Graduate School of Computer and Information Science, Nova Southeastern University, USA","2015 IEEE International Symposium on Technologies for Homeland Security (HST)","","2015","","","1","6","In this ubiquitous IoT (Internet of Things) era, web services have become a vital part of today's critical national and public sector infrastructure. With the industry wide adaptation of service-oriented architecture (SOA), web services have become an integral component of enterprise software eco-system, resulting in new security challenges. Web services are strategic components used by wide variety of organizations for information exchange on the internet scale. The public deployments of mission critical APIs opens up possibility of software bugs to be maliciously exploited. Therefore, vulnerability identification in web services through static as well as dynamic analysis is a thriving and interesting area of research in academia, national security and industry. Using OWASP (Open Web Application Security Project) web services guidelines, this paper discusses the challenges of existing standards, and reviews new techniques and tools to improve services security by detecting vulnerabilities. Recent vulnerabilities like Shellshock and Heartbleed has shifted the focus of risk assessment to the application layer, which for majority of organization means public facing web services and web/mobile applications. RESTFul services have now become the new service development paradigm normal; therefore SOAP centric standards such as XML Encryption, XML Signature, WS-Security, and WS-SecureConversation are nearly not as relevant. In this paper we provide an overview of the OWASP top 10 vulnerabilities for web services, and discuss the potential static code analysis techniques to discover these vulnerabilities. The paper reviews the security issues targeting web services, software/program verification and security development lifecycle.","","978-1-4799-1737-2978-1-4799-1736","10.1109/THS.2015.7225337","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7225337","Static Code Analysis;RESTFul API;SOA;Web Services;Cyber Security;Secure Design;Secure Software Development;SOAP;Source Code Analysis;Security Code Review;Static Analysis Tool;Service Oriented Architecture;Web Services Security;Web Application security;Penetration Testing","Simple object access protocol;XML;Testing;Computer crime;Cryptography","program diagnostics;program verification;security of data;Web services","Heartbleed;risk assessment;Web applications;mobile applications;RESTFul services;service development paradigm;SOAP centric standards;XML encryption;XML signature;WS-security;WS-SecureConversation;static code analysis;software verification;program verification;Shellshock;vulnerabilities detection;services security;Web services guidelines;Open Web Application Security Project;OWASP;national security and industry;dynamic analysis;vulnerability identification;software bugs;mission critical API;public deployments;Internet scale;information exchange;strategic components;security challenges;enterprise software ecosystem;service-oriented architecture;public sector infrastructure;critical national infrastructure;Internet of Things;ubiquitous IoT;secure development life cycle;Web service security","","4","23","","","","","","IEEE","IEEE Conferences"
"Fault-Prone Module Prediction Using a Prediction Model and Manual Inspection","N. Kasai; S. Morisaki; K. Matsumoto","NA; NA; NA","2013 20th Asia-Pacific Software Engineering Conference (APSEC)","","2013","1","","106","115","This paper proposes a fault-prone prediction approach that combines a fault-prone prediction model and manual inspection. Manual inspection is conducted by a predefined checklist that consists of questions and scoring procedures. The questions capture the fault signs or indications that are difficult to be captured by source code metrics used as input by prediction models. Our approach consists of two steps. In the first, the modules are prioritized by a fault-prone prediction model. In the second step, an inspector inspects and scores α percent of the prioritized modules. We conducted a case study of source code modules in commercial software that had been maintained and evolved over ten years and compared AUC (Area Under the Curve) values of Alberg Diagram among three prediction models: (A) support vector machines, (B) lines of code, and (C) random predictor with four prioritization orders. Our results indicated that the maximum AUC values under appropriate α and the coefficient of the inspection score were larger than the AUC values of the prediction models without manual inspection in each of the four combinations and the three models in our context. In two combinations, our approach increased the AUC values to 0.860 from 0.774 and 0.724. Our results also indicated that one of the combinations monotonically increased the AUC values with the numbers of manually inspected modules. This might lead to flexible inspection; the number of manually inspected modules has not been preliminary determined, and the inspectors can inspect as many modules as possible, depending on the available effort.","1530-1362;1530-1362","978-1-4799-2144-7978-1-4799-2143","10.1109/APSEC.2013.25","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6805396","source code inspection;code smell;hybrid faultprone","Predictive models;Inspection;Manuals;Measurement;Manganese;Libraries;Logistics","software fault tolerance;software quality;support vector machines","fault-prone module prediction;prediction model;manual inspection;fault-prone prediction approach;scoring procedures;source code metrics;source code modules;AUC value;area-under-the-curve;Alberg diagram;support vector machines;lines-of-code;random predictor;prioritization orders","","","32","","","","","","IEEE","IEEE Conferences"
"Design of a 7-bit 1GSPS folding-interpolation A/D converter with self-calibration technique","Y. Kim; Jungwon Jeon; K. Cho; D. Kim; J. Moon; M. Song","Dongguk Univ-Seoul, Dept. of Semiconductor Science, Seoul 100-715, South KOREA; Dongguk Univ-Seoul, Dept. of Semiconductor Science, Seoul 100-715, South KOREA; Dongguk Univ-Seoul, Dept. of Semiconductor Science, Seoul 100-715, South KOREA; Dongguk Univ-Seoul, Dept. of Semiconductor Science, Seoul 100-715, South KOREA; Dongguk Univ-Seoul, Dept. of Semiconductor Science, Seoul 100-715, South KOREA; Dongguk Univ-Seoul, Dept. of Semiconductor Science, Seoul 100-715, South KOREA","2010 17th IEEE International Conference on Electronics, Circuits and Systems","","2010","","","110","113","In this paper, a 65nm 1.2V 7-bit 1GSPS A/D converter with a self-calibration technique is proposed. The A/D converter is based on a folding-interpolation structure whose folding rate is 2, interpolation rate is 8. An offset self-calibration circuit with a feedback loop and a recursive digital code inspection is described. The offset self-calibration circuit reduces the variation of the offset voltage, due to process mismatches, parasitic resistors, and parasitic capacitances. The chip has been fabricated with a 65nm 1-poly 6-metal CMOS technology. The effective chip area is 0.87mm2 and the power consumption is about 110mW with a 1.2V power supply. The measured SNDR is about 38.48dB when the input frequency is 250MHz at 1GHz sampling frequency. The measured SNDR is 3dB higher than the same ADC without any calibration.","","978-1-4244-8157-6978-1-4244-8155-2978-1-4244-8156","10.1109/ICECS.2010.5724466","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5724466","7bit;ADC;Folding;Interpolation;Self-Calibration","Calibration;Degradation;Clocks","analogue-digital conversion;calibration;CMOS digital integrated circuits;interpolation","folding-interpolation A-D converter;self-calibration technique;offset self-calibration circuit;feedback loop;recursive digital code inspection;offset voltage variation;parasitic resistors;parasitic capacitances;CMOS technology;size 65 nm;voltage 1.2 V;frequency 250 MHz;frequency 1 GHz","","","7","","","","","","IEEE","IEEE Conferences"
"CORRECT: Code reviewer recommendation at GitHub for Vendasta technologies","M. M. Rahman; C. K. Roy; J. Redl; J. A. Collins","University of Saskatchewan, Canada; University of Saskatchewan, Canada; Vendasta Technologies, Canada; Google Inc., USA","2016 31st IEEE/ACM International Conference on Automated Software Engineering (ASE)","","2016","","","792","797","Peer code review locates common coding standard violations and simple logical errors in the early phases of software development, and thus, reduces overall cost. Unfortunately, at GitHub, identifying an appropriate code reviewer for a pull request is challenging given that reliable information for reviewer identification is often not readily available. In this paper, we propose a code reviewer recommendation tool-CORRECT-that considers not only the relevant cross-project work experience (e.g., external library experience) of a developer but also her experience in certain specialized technologies (e.g., Google App Engine) associated with a pull request for determining her expertise as a potential code reviewer. We design our tool using client-server architecture, and then package the solution as a Google Chrome plug-in. Once the developer initiates a new pull request at GitHub, our tool automatically analyzes the request, mines two relevant histories, and then returns a ranked list of appropriate code reviewers for the request within the browser's context. Demo: https://www.youtube.com/watch?v=rXU1wTD6QQ0.","","978-1-4503-3845-5978-1-5090-5571","","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582817","Code reviewer recommendation;cross-project experience;specialized technology experience;GitHub;pull request","History;Software;Libraries;Browsers;Collaboration;Authentication;Encoding","client-server systems;DP industry;Internet;recommender systems;software architecture;software reviews;software tools;source code (software)","CORRECT;code reviewer recommendation tool;GitHub;Vendasta Technologies;peer code review;software development;client-server architecture;Google Chrome plug-in","","","18","","","","","","IEEE","IEEE Conferences"
"EMERALD: a case study in enhancing software reliability","J. Hudepohl; W. Jones; B. Lague","Bell Canada, Canada; NA; NA","Proceedings The Eighth International Symposium on Software Reliability Engineering - Case Studies -","","1997","","","85","91","As software grows in both size and complexity, reliability becomes a critical issue, particularly in the area of telecommunications. This case study examines a tool and procedures developed at a large telecommunications company for software risk assessment. EMERALD (Enhanced Measurement for Early Risk Assessment of Latent Defects) has been applied at all stages of the software life-cycle to indicate risk of future software problems. The tool provides information used for decision support during design, code inspection, testing and maintenance. EMERALD has been instrumental in Nortel's efforts to increase efficiency, control costs, and enhance both product quality and customer satisfaction.","","0-8186-8221","10.1109/CSSRE.1997.637850","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=637850","","Computer aided software engineering;Software reliability;Risk management;Testing;Inspection;Software tools;Software measurement;Costs;Customer satisfaction;Fault diagnosis","software reliability;software tools;telecommunication computing;risk management;decision support systems;program testing;software maintenance;software quality","EMERALD;case study;software reliability;software size;software complexity;telecommunications software;software tool;large telecommunications company;software risk assessment;measurement;latent defects;software life-cycle;decision support system;system design;code inspection;software testing;software maintenance;Nortel;software costs;software quality;customer satisfaction","","8","5","","","","","","IEEE","IEEE Conferences"
"On the understanding of programs with continuous code reviews","M. Bernhart; T. Grechenig","Research Group for Industrial Software (INSO), Vienna University of Technology, Austria; Research Group for Industrial Software (INSO), Vienna University of Technology, Austria","2013 21st International Conference on Program Comprehension (ICPC)","","2013","","","192","198","Code reviews are a very effective, but effortful quality assurance technique. A major problem is to read and understand source-code that was produced by someone else. With different programming styles and complex interactions, understanding the code under review is the most expensive sub-task of a code review. As with many other modern software engineering practices, code reviews may be applied as a continuous process to reduce the effort and support the concept of collective ownership. This study evaluates the effect of a continuous code review process on the understandability and collective ownership of the code base. A group of 8 subjects performed a total of 114 code reviews within 18 months in an industrial context and conducted an expert evaluation according to this research question. This study concludes that there is a clear positive effect on the understandability and collective ownership of the code base with continuous code reviews, but also limiting factors and drawbacks for complex review tasks.","1092-8138","978-1-4673-3092","10.1109/ICPC.2013.6613847","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6613847","Code review;continuous;inspection;code quality;IEEE-1028;aviation;safety","Software;Context;Quality assurance;Airports;Coherence;Timing;Planning","programming;quality assurance;reverse engineering;software quality","program understanding;continuous code reviews;quality assurance technique;source-code understanding;programming styles;complex interactions;software engineering practices;collective ownership","","5","14","","","","","","IEEE","IEEE Conferences"
"The investigation of vulnerability test in application software","S. Sedaghat; F. Adibniya; M. Sarram","Undergraduate MS student of information technology engineering at Yazd University, Iran; computer engineering department at Yazd University, Iran; computer engineering department at Yazd University, Iran","2009 International Conference on the Current Trends in Information Technology (CTIT)","","2009","","","1","5","Security challenges of application software that are about 70 percent of monthly discovered vulnerability of this kind are one of the most important concerns of managers. In this article, after the introduction of brief application software vulnerability, the author intends to investigate the issue of software vulnerability test from two points. This issue is divided in to two groups of tests, during the software development and after software implementation in terms of the time of application. In the first method, it is believed that making essential changes in software security necessitate changes in the methods of software production. To provide security in this method, code review can be performed via static analysis tools. In the second method software scanners can be used. Finally by comparison, the positive and negative points of these methods are demonstrated. It should be mentioned that our view is forward the general concepts and detailed issues need another opportunity to be investigated.","2377-5327;2377-5335","978-1-4244-5757-1978-1-4244-5754-0978-1-4244-5756","10.1109/CTIT.2009.5423119","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5423119","Scanner;vulnerability;test;application software security;static analysis tool","Software testing;Application software;XML;Information security;Logic testing;Buffer overflow;Logic programming;Impedance;Information technology;Computer security","program diagnostics;program testing;security of data","software vulnerability test;application software;brief application software vulnerability;software development;software implementation;software security;static analysis tools;software scanners","","1","12","","","","","","IEEE","IEEE Conferences"
"Test Inspected Unit or Inspect Unit Tested Code?","A. Gupta; P. Jalote","Indian Institute of Technology Kanpur, India; Indian Institute of Technology Delhi, India","First International Symposium on Empirical Software Engineering and Measurement (ESEM 2007)","","2007","","","51","60","Code inspection and unit testing are two popular fault- detecting techniques at unit level. Organizations where inspections are done generally supplement it with unit testing, as both are complementary. A natural question is the order in which the two techniques should be exercised as this may impact the overall effectiveness and efficiency of the verification process. In this paper, we present a controlled experiment comparing the two execution-orders, namely, code inspection followed by unit testing (CI-UT) and unit testing followed by code inspection (UT-CI), performed by a group of fresh software engineers in a company. The subjects inspected program-units by traversing a set of usage scenarios and applied unit testing by writing JUnit tests for the same. Our results showed that unit testing can be more effective, as well as more efficient, if applied after code inspection whereas the later is unaffected of the execution- order. Overall results suggest that sequence CI-UT performs better than UT-CI in time-constrained situations.","1949-3770;1949-3789","0-7695-2886-4978-0-7695-2886","10.1109/ESEM.2007.52","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4343732","","Inspection;Automatic testing;Software testing;Performance evaluation;Writing;Fault diagnosis;System testing;Software engineering;Measurement units;Software measurement","fault diagnosis;inspection;program testing","inspect unit tested code;code inspection;fault-detection technique;software engineering;JUnit tests","","1","30","","","","","","IEEE","IEEE Conferences"
"Treating software quality as a first-class entity","Y. Tymchuk","REVEAL @ Faculty of Informatics - University of Lugano, Switzerland","2015 IEEE International Conference on Software Maintenance and Evolution (ICSME)","","2015","","","594","597","Quality is a crucial property of any software system and consists of many aspects. On the one hand, quality measures how well a piece of software satisfies its functional requirements. On the other hand, it captures how easy it is to understand, test and modify a software system. While functional requirements are provided by the product owner, maintainability of software is often underestimated. Currently software quality is either assessed by experts, or presented as a list of rule violations reported by some kind of static analyzer. Both these approaches are working with a sense of quality outside of the software itself.","","978-1-4673-7532-0978-1-4673-7531","10.1109/ICSM.2015.7332521","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7332521","","Software systems;Visualization;Software quality;Encoding;Measurement;Object oriented modeling","decision making;program diagnostics;software maintenance;software quality;software reviews","first-class entity;software system quality;functional requirements;software maintainability;static analyzer;quality aware tools;software development lifecycle;code review approach;reviewer decision making;software model;quality-aware IDE plugins","","1","28","","","","","","IEEE","IEEE Conferences"
"Low-Ada","B. A. Wichmann","NPL, Teddington, UK","IEE Colloquium on High Integrity Ada","","1991","","","7/1","7/4","Low-Ada combines the use of Ada with the method of low-level code review. The author discusses the properties which result from this combination. He describes: unassigned value access; types with discriminants; storage allocation and testing.<<ETX>>","","","","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=180768","","Ada;Program compilers;Software reliability","Ada;program compilers;software reliability","software reliability;low-level code review;unassigned value access;types with discriminants;storage allocation;testing","","","","","","","","","IET","IET Conferences"
"Comparing the Cost-Effectiveness of Statically Analysing and Model Checking Concurrent Java Components for Deadlocks","J. Ngui; P. Strooper; L. Wildman; M. Wojcicki","The University of Queensland, Australia; The University of Queensland, Australia; The University of Queensland, Australia; The University of Queensland, Australia","2007 Australian Software Engineering Conference (ASWEC'07)","","2007","","","223","232","Verifying concurrent Java programs is difficult due to the many possible interleavings of threads and a number of specific concurrency defects such as interference and deadlock. To verify concurrent Java components, the TestCon method combines code inspection, static analysis and dynamic analysis. The deadlock detection steps of TestCon include static analysis (using Jlint) that may result in false positives or false negatives; therefore code inspection is combined with Jlint, but inspection can be time-consuming and depends on the inspector's skills. In this paper, we evaluate the cost-effectiveness of the Java PathFinder 2 (JPF 2) model checker for the detection of deadlocks in the context of the TestCon method. The results of the study show that using JPF 2 can improve TestCon's effectiveness but a trade-off has to be made in terms of cost in the development of the driver and analysis of its output. General conclusions cannot be drawn since the study was exploratory and small-scale; however the observations highlight some of the strengths and weaknesses of using JPF 2 compared to static analysis and code inspection.","1530-0803","0-7695-2778","10.1109/ASWEC.2007.16","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4159675","","Java;System recovery;Testing;Inspection;Interleaved codes;Yarn;Concurrent computing;Interference;Context modeling;Costs","concurrency control;Java;multi-threading;program diagnostics;program verification","concurrent Java program verification;code inspection;static analysis;dynamic analysis;deadlock detection;Java PathFinder 2;model checking;multithreading","","3","29","","","","","","IEEE","IEEE Conferences"
"Does reviewer recommendation help developers?","V. Kovalenko; N. Tintarev; E. Pasynkov; C. Bird; A. Bacchelli","Software Technology, Technische Universiteit Delft, 2860 Delft, Zuid-Holland Netherlands (e-mail: v.v.kovalenko@tudelft.nl); Web Information Systems, Technische Universiteit Delft, 2860 Delft, Zuid-Holland Netherlands (e-mail: n.tintarev@tudelft.nl); Upsource team, JetBrains GmbH, Munich, Bayern Germany (e-mail: evgeny.pasynkov@jetbrains.com); Microsoft Research, Microsoft Corportation, Redmond, Washington United States 98052 (e-mail: cbird@microsoft.com); Department of Informatics, University of Zurich, Zürich, Zürich Switzerland (e-mail: bacchelli@ifi.uzh.ch)","IEEE Transactions on Software Engineering","","2018","PP","99","1","1","Selecting reviewers for code changes is a critical step for an efficient code review process. Recent studies propose automated reviewer recommendation algorithms to support developers in this task. However, the evaluation of recommendation algorithms, when done apart from their target systems and users (i.e. code review tools and change authors), leaves out important aspects: perception of recommendations, influence of recommendations on human choices, and their effect on user experience. This study is the first to evaluate a reviewer recommender in vivo. We compare historical reviewers and recommendations for over 21,000 code reviews performed with a deployed recommender in a company environment and set to measure the influence of recommendations on users' choices, along with other performance metrics. Having found no evidence of influence, we turn to the users of the recommender. Through interviews and a survey we find that, though perceived as relevant, reviewer recommendations rarely provide additional value for the respondents. We confirm this finding with a larger study at another company. The confirmation of this finding brings up a case for more user-centric approaches to designing and evaluating the recommenders. Finally, we investigate information needs of developers during reviewer selection and discuss promising directions for the next generation of reviewer recommendation tools.","0098-5589;1939-3520;2326-3881","","10.1109/TSE.2018.2868367","Schweizerischer Nationalfonds zur Forderung der Wissenschaftlichen Forschung; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453850","Code Review;Reviewer Recommendation;Empirical Software Engineering","Tools;Recommender systems;Companies;Measurement;Software;In vivo;Software engineering","","","","","","","","","","","IEEE","IEEE Early Access Articles"
"Using a case study to teach students about finding and fixing logic flaws in software","L. Simpkins; X. Yuan; H. Yu; K. Williams","Computer Science Department, North Carolina A&amp;T State University, Greensboro, NC, USA; Computer Science Department, North Carolina A&amp;T State University, Greensboro, NC, USA; Computer Science Department, North Carolina A&amp;T State University, Greensboro, NC, USA; Computer Science Department, North Carolina A&amp;T State University, Greensboro, NC, USA","2015 IEEE Frontiers in Education Conference (FIE)","","2015","","","1","7","An application logic flaw is a type of software vulnerability related to privilege manipulation or transaction control manipulation. They are often difficult to identify using automated scanners. A case study on the eCommerce merchant software Bigcommerce, integrated with PayPal Express as a third party payment collector, was created to teach students about this topic. Case studies provide students with a real-world context, and help them understand complex topics better than traditional teaching methods. However, the computer science field, especially computer security, does not have many case studies available. The case study on logic flaws in software was taught in Spring 2015, and the teaching experience is discussed.","","978-1-4799-8454","10.1109/FIE.2015.7344155","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7344155","software security;computing education;case study;application logic flaws;manual code review method","Testing;Software;Education;Manuals;Security;Computer science;Fault diagnosis","computer science education;program debugging;security of data;teaching","logic flaw fixing;application logic flaw;software vulnerability;transaction control manipulation;automated scanners;ecommerce merchant software;Bigcommerce;PayPal Express;student teaching;computer science field;computer security","","","40","","","","","","IEEE","IEEE Conferences"
"Graph Data Management of Evolving Dependency Graphs for Multi-versioned Codebases","O. Goonetilleke; D. Meibusch; B. Barham","NA; NA; NA","2017 IEEE International Conference on Software Maintenance and Evolution (ICSME)","","2017","","","574","583","Frappé is a code comprehension tool developed by Oracle Labs that extracts the code dependencies from a codebase and stores them in a graph database enabling advanced comprehension tasks. In addition to traditional text-based queries, such context-sensitive tools allow developers to express navigational queries of the form Does function X or something it calls write to global variable Y? providing more insight into the underlying codebases. Frappe captures the dependencies based on the most recent snapshot of the codebase.In this work we focus on the challenges associated with the management of multiple source code revisions, and investigate strategies to enable advanced code comprehension when the underlying codebase evolves over time. To find the deltas, we detail how entities can be resolved across versions, and propose a model for representing evolving dependency graphs. Our versioned graphs are built using snapshots of large codebases in the order of 13 million lines of code.We show growth and storage benefits of versioned graphs compared to independently storing individual snapshots. We also demonstrate how existing Frappe queries can be executed on versioned graphs and new queries can retrieve a history of changes in a function for a code review use case.","","978-1-5386-0992-7978-1-5386-0993","10.1109/ICSME.2017.54","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8094463","versioned codebase;evolving dependency graphs;graph database;entity resolution","Tools;Databases;Navigation;Buildings;Data mining;History","graph theory;query processing;software maintenance;software tools;text analysis","graph data management;code comprehension tool;Oracle Labs;code dependencies;graph database;comprehension tasks;context-sensitive tools;navigational queries;multiple source code revisions;versioned graphs;code review;Frappe queries;text-based queries","","","35","","","","","","IEEE","IEEE Conferences"
"Characteristics of Unmaintainable Source Code in Software Development by Multiple Organizations","R. Ishizuka; N. Tsuda; H. Washizaki; Y. Fukazawa; S. Sugimura; Y. Yasuda","NA; NA; NA; NA; NA; NA","2018 IEEE International Conference on Big Data, Cloud Computing, Data Science & Engineering (BCD)","","2018","","","49","54","In software development, there are numerous reasons why a development organization changes. These include cost reduction and retiring developers. Often the quality of software developed by multiple organizations is low, leading to problems such as difficulty in the evolution of source code. To detect factors indicating low evolvability of software, we focus two maintain-ability characteristics of software development: defect proneness and refactoring tendencies of the source code. We investigate the changes in the relationship of software metrics and the number of defects. Then we compare the results and editing tendencies for refactoring and evolving software in experiments using OpenOffice.org, which is developed by multiple companies, and a tool developed by outsourcing. Defects tend to concentrate on files that depend on many other files. Additionally, the code review confirms that refactoring before and after a development organization change is important for future developments.","","978-1-5386-5605-1978-1-5386-5606","10.1109/BCD2018.2018.00016","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8530691","software-metrics;software-quality;software-defects;organizational-change;outsourcing","Software;Tools;Software metrics;Complexity theory;Cloning;Companies","cost reduction;outsourcing;public domain software;software maintenance;software metrics;software quality;source code (software)","unmaintainable source code;cost reduction;software metrics;software evolution;software quality;source code evolution;software development maintainability characteristics;source code refactoring;source code defect proneness;OpenOffice.org;outsourcing","","","19","","","","","","IEEE","IEEE Conferences"
"Automated techniques and tools for program analysis: Survey","A. K. Ashish; J. Aghav","Department of Computer Engineering, College of Engineering, Pune, Pune - 411005; Department of Computer Engineering, College of Engineering, Pune, Pune - 411005","2013 Fourth International Conference on Computing, Communications and Networking Technologies (ICCCNT)","","2013","","","1","7","Dealing with program analysis for software development and the understanding of source code of software exhibit many research possibilities. The field of program analysis scrutinizes the approaches and techniques to analyze the properties of program including its analysis, flow, program development, algorithm, reverse engineering and other invisible features. The goal is to improve our understanding of inherently invisible and intangible software, particularly when dealing with large information spaces that characterize domains like software maintenance, reverse engineering, and collaborative development. The use of analytical methods to inspect and review source code to detect bugs has been a standard development practice. This process can be accomplished both manually and in an automated fashion. With automation, software tools provide assistance with the code review and inspection process. Program analysis includes Static and Dynamic program analysis. Static analysis techniques range from routine to more complex semantic analysis based structure.","","978-1-4799-3926-8978-1-4799-3925","10.1109/ICCCNT.2013.6726693","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6726693","","Abstracts;Software;Computer bugs;Algorithm design and analysis;Runtime;Optimization;Performance analysis","program diagnostics;software reviews;software tools;source code (software)","software development;source code;program development;reverse engineering;intangible software;invisible software;software maintenance;collaborative development;automated techniques;software tools;code review;inspection process;dynamic program analysis techniques;static program analysis techniques;complex semantic analysis based structure;bugs detection","","1","26","","","","","","IEEE","IEEE Conferences"
"Implementation of the Software Quality Ranks method in the legacy product development environment","L. Hribar; A. Burilovic; D. Huljenic","Ericsson Nikola Tesla R&D Center, Croatia; Ericsson Nikola Tesla R&D Center, Croatia; Ericsson Nikola Tesla R&D Center, Croatia","2009 10th International Conference on Telecommunications","","2009","","","141","145","Software quality ranks (SQR) is an important method to manage and improve software quality. Component software quality has a major influence in development project lead time and cost. SQR enables better management and visibility of the quality effort associated with the component implementation. It also provides a roadmap for continuous improvement leading to value add quality attributes like low maintenance, self optimizing software and short development lifecycles. SQR method focuses attention to prioritizing the quality investment on design component level through different quality assurance mechanisms (basic test, code review, desk checks, documentation and other actions). The resulting design delivery to verification phase will be more predictable quality software with shorter lead-time and time-to-market (TTM).","","978-953-184-130-6978-953-184-131","","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5206363","","Software quality;Product development;Quality management;Software maintenance;Time to market;Costs;Continuous improvement;Investments;Quality assurance;Testing","quality assurance;software development management;software quality","software quality ranks method;legacy product development;component software quality;design component level;quality assurance mechanisms","","1","16","","","","","","IEEE","IEEE Conferences"
"Measuring web service interfaces","H. M. Sneed","ANECON GmbH, Vienna, Austria","2010 12th IEEE International Symposium on Web Systems Evolution (WSE)","","2010","","","111","115","The following short paper describes a tool supported method for measuring web service interfaces. The goal is to assess the complexity and quality of these interfaces as well as to determine their size for estimating evolution and testing effort. Besides the metrics for quantity, quality and complexity, rules are defined for ensuring maintainability. In the end a tool - WSDAudit - is described which the author has developed for the static analysis of web service definitions. The WSDL schemas are automatically audited and measured for quality assurance and cost estimation. Work is underway to verify them against the BPEL procedures from which they are invoked.","1550-4441","978-1-4244-8637-3978-1-4244-8638","10.1109/WSE.2010.5623580","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5623580","web services;WSDL;metrics;rule checking;quality;complexity;sizing;static analysis;code inspection;interface rule checking","Complexity theory;Web services;Software;Business;Couplings;Size measurement","program diagnostics;software cost estimation;software maintenance;software metrics;software quality;user interfaces;Web services","Web service interface;interface complexity;interface quality;maintainability;WSDAudit;static analysis;WSDL schema auditing;quality assurance;cost estimation;BPEL procedure","","9","14","","","","","","IEEE","IEEE Conferences"
"The Impacts of Supporting Materials on Code Reading: A Controlled Experiment","G. Rong; H. Zhang; Q. Shan; G. Liu; D. Shao","NA; NA; NA; NA; NA","2015 Asia-Pacific Software Engineering Conference (APSEC)","","2015","","","88","95","Background: Code inspection has been accepted as an effective method to detect and remove defects and code reading is a critical step in code inspection. However, there are very limited empirical studies on the content and appropriate forms of the suitable software artifacts as the supporting materials, hence inspectors may not be well-supported with necessary knowledge to carry out code reading. Objective: This research aims to investigate the impact of different common supporting materials (i.e., comments vs. design documents) on code reading. Method: A relatively large-scale controlled experiment with 135 senior students was designed and executed to compare the impacts of different supporting materials on code reading. The subjects were randomly separated into three groups with different treatments, i.e, the comments, the design documents and the comments+design documents, respectively. Two metrics regarding the code reading performance (i.e., Effectiveness and Defect Detection Rate) were used to compare the different impacts derived from the two different types of supporting materials. Qualitative feedbacks were also collected using questionnaires for the final analysis. Results: The results indicate that students performed better when being provided with comments than comments+design documents. Also, the removal of design documents shows little impact on inspection effectiveness and may lead to an increase in defect detection rate. Conclusion: Comments may provide more help and value than design documents as supporting material in small to median sized code reading.","1530-1362","978-1-4673-9644","10.1109/APSEC.2015.39","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7467287","Code Reading;Supporting Materials;Design Documents;Code Comments","Inspection;Software;Elevators;Software engineering;Measurement;Context;Statistical analysis","inspection;program debugging;program diagnostics;program testing;software engineering;source code (software)","code inspection;software artifacts;defect detection rate;code reading performance;supporting materials;design documents","","","26","","","","","","IEEE","IEEE Conferences"
"Communication and organization: an empirical study of discussion in inspection meetings","C. B. Seaman; V. R. Basili","Inst. for Adv. Comput. Studies, Maryland Univ., College Park, MD, USA; NA","IEEE Transactions on Software Engineering","","1998","24","7","559","572","This paper describes an empirical study that addresses the issue of communication among members of a software development organization. In particular, data was collected concerning code inspections in one software development project. The question of interest is whether or not organizational structure (the network of relationships between developers) has an effect on the amount of effort expended on communication between developers. The independent variables in this study are various attributes of the organizational structure in which the inspection participants work. The dependent variables are measures of the communication effort expended in various parts of the code inspection process, focusing on the inspection meeting. Both quantitative and qualitative methods were used, including participant observation, structured interviews, generation of hypotheses from field notes, statistical tests of relationships, and interpretation of results with qualitative anecdotes. The study results show that past and present working relationships between inspection participants affect the amount of meeting time spent in different types of discussion, thus affecting the overall inspection meeting length. Reporting relationships and physical proximity also have an effect. The contribution of the study is a set of well-supported hypotheses for further investigation.","0098-5589;1939-3520;2326-3881","","10.1109/32.708569","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=708569","","Inspection;Programming;Productivity;Testing;Information processing;Context;Professional communication;Software engineering","software development management","inspection meetings;software development organization;software development project;organizational structure;inspection participants;communication effort;code inspection process","","33","21","","","","","","IEEE","IEEE Journals & Magazines"
"Can we influence students' attitudes about inspections? Can we measure a change in attitude?","D. Bailey; T. Conn; B. Hanks; L. Werner","Comput. Sci. Dept., California Univ., Santa Cruz, CA, USA; Comput. Sci. Dept., California Univ., Santa Cruz, CA, USA; Comput. Sci. Dept., California Univ., Santa Cruz, CA, USA; Comput. Sci. Dept., California Univ., Santa Cruz, CA, USA","Proceedings 16th Conference on Software Engineering Education and Training, 2003. (CSEE&T 2003).","","2003","","","260","267","As the software industry matures, new development technologies are invented and some of these technologies transition into best practices. Our role as university educators is to teach these best practices and change attitudes so that our students graduate as software engineers who believe in the use of these methodologies. One question that all software engineering educators have is 'can we measure whether our courses change attitudes about the use of these methodologies?' In this small case study, conventional techniques in psychology for attitude measurement are used to construct scales for measuring software engineering students' attitudes toward the code inspection process. The scales were applied in a pre-pilot survey, a pilot survey, a test survey, and then again in a larger test situation. Our test results suggest that our students improved their intellectual acceptance of code inspections after viewing an inspection video. Students emotionally accepted inspection only after practice. Our work shows that this line of research has the potential to help assess the impact of software engineering teaching methods and materials.","1093-0175","0-7695-1869","10.1109/CSEE.2003.1191385","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1191385","","Inspection;Best practices;Software engineering;Human factors;Software measurement;Programming;Psychology;Testing;Computer industry;Education","software engineering;computer science education;educational courses;human factors;teaching;psychology;DP industry;inspection","software industry;university educators;student attitudes;attitude change measurement;software engineering;university courses;psychology;code inspection process;pre-pilot survey;pilot survey;intellectual acceptance;inspection video;test survey;emotional aspects;teaching methods","","2","14","","","","","","IEEE","IEEE Conferences"
"Checking Java Bugs by Data Propagation Analysis","Z. L. Feng; T. Hong; H. M. Huan; K. X. Hui; J. Qi","NA; NA; NA; NA; NA","2011 First International Conference on Instrumentation, Measurement, Computer, Communication and Control","","2011","","","861","864","The objective of vulnerability analysis is to find out the unknown security holes in a system. Many software bugs, such as SQL injection, come from careless check of the input string. Finding these bugs out is very difficult without source code inspect. This paper gives a novel method to check the bugs in Java byte code based on points-to dataflow analysis, which is different to the common analysis techniques base on the vulnerability pattern check. It can be used as an assistant approach for security analysis of Java byte code.","","978-0-7695-4519","10.1109/IMCCC.2011.217","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6154243","Java bytecode;points-to dataflow;vulnerability analysis","Security;Java;Computer bugs;Analytical models;Software;Databases;Focusing","data analysis;Java;security of data","Java bugs checking;data propagation analysis;vulnerability analysis;security hole;software bug;SQL injection;Structured Query Languages;source code inspection;Java byte code;points-to dataflow analysis;vulnerability pattern check;security analysis","","","14","","","","","","IEEE","IEEE Conferences"
"Targeting Specific Customer Satisfactions Issues with ODC Analysis","R. Chillarege","NA","2012 IEEE 23rd International Symposium on Software Reliability Engineering Workshops","","2012","","","64","64","Often, the task of quality improvement is complicated by having defect backlogs and process gaps that seem too hard to tackle in a short period of time. This is particularly true of most development organizations that have performed root cause analysis or process assessments which identify long list of potential improvement opportunities. The list include identification of one or more of a variety of issues - such as architecture weaknesses, test coverage inadequacy, inadequate regression opportunity, weak code review or inadequacy of appropriate skills.","","978-1-4673-5048-8978-0-7695-4928","10.1109/ISSREW.2012.105","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6405419","","Customer satisfaction;Random access memory;Abstracts;Organizations;IEEE Potentials","customer satisfaction","defect backlog;process gap;development organization;root cause analysis;process assessment;customer satisfaction;ODC analysis","","","","","","","","","IEEE","IEEE Conferences"
"A modeling approach for estimating execution time of long-running scientific applications","S. M. Sadjadi; Shu Shimizu; J. Figueroa; R. Rangaswami; J. Delgado; H. Duran; X. J. Collazo-Mojica","Florida International University (FIU), Miami, USA; IBM Tokyo Research Laboratory, Japan; Florida International University (FIU), Miami, USA; Florida International University (FIU), Miami, USA; Florida International University (FIU), Miami, USA; University of Guadalajara, CUCEA, Mexico; University of Puerto Rico, Mayaguez Campus, Puerto Rico","2008 IEEE International Symposium on Parallel and Distributed Processing","","2008","","","1","8","In a grid computing environment, resources are shared among a large number of applications. Brokers and schedulers find matching resources and schedule the execution of the applications by monitoring dynamic resource availability and employing policies such as first- come-first-served and back-filling. To support applications with timeliness requirements in such an environment, brokering and scheduling algorithms must address an additional problem - they must be able to estimate the execution time of the application on the currently available resources. In this paper, we present a modeling approach to estimating the execution time of long-running scientific applications. The modeling approach we propose is generic; models can be constructed by merely observing the application execution ""externally"" without using intrusive techniques such as code inspection or instrumentation. The model is cross-platform; it enables prediction without the need for the application to be profiled first on the target hardware. To show the feasibility and effectiveness of this approach, we developed a resource usage model that estimates the execution time of a weather forecasting application in a multi-cluster grid computing environment. We validated the model through extensive benchmarking and profiling experiments and observed prediction errors that were within 10% of the measured values. Based on our initial experience, we believe that our approach can be used to model the execution time of other time-sensitive scientific applications; thereby, enabling the development of more intelligent brokering and scheduling algorithms.","1530-2075","978-1-4244-1693-6978-1-4244-1694","10.1109/IPDPS.2008.4536214","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4536214","","Predictive models;Grid computing;Processor scheduling;Dynamic scheduling;Scheduling algorithm;Monitoring;Availability;Inspection;Instruments;Hardware","geophysics computing;grid computing;resource allocation;weather forecasting","grid computing;dynamic resource availability;scheduling algorithms;brokering algorithms;resource usage model;weather forecasting","","13","23","","","","","","IEEE","IEEE Conferences"
"Demonstration of COSAK static analysis tools","D. DaCosta; C. Dahn; S. Mancoridis; V. Prevelakis","Dept. of Comput. Sci., Drexel Univ., Philadelphia, PA, USA; Dept. of Comput. Sci., Drexel Univ., Philadelphia, PA, USA; Dept. of Comput. Sci., Drexel Univ., Philadelphia, PA, USA; Dept. of Comput. Sci., Drexel Univ., Philadelphia, PA, USA","Proceedings DARPA Information Survivability Conference and Exposition","","2003","2","","7","9 vol.2","A software vulnerability is a fault in the specification, implementation, or configuration of a software system whose execution can violate an explicit or implicit security policy. Users typically focus on the functionality of software rather than its security posture. Hence, vulnerabilities often escape their attention until the software is exploited by specially written malicious code. Code auditing is one solution which has been tried with some success in systems such as the OpenBSD operating system. Code audits involve the review of source code by experts in search of vulnerabilities. These audits are reoccurring, namely each revision of the software requires reexamination, and expensive because code audits are labor intensive. Auditors would benefit from a tool which enables them to focus their attention on high-risk areas, thus reducing the amount of code that needs to be audited. The article shows how the tools developed at Drexel University can be used to direct the attention of code auditors to those components that have a high likelihood of being vulnerable.","","0-7695-1897","10.1109/DISCEX.2003.1194898","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1194898","","Open source software;Software systems;Computer science;Security;Software performance;Computer languages;Costs;Programming profession;Operating systems;Large-scale systems","program diagnostics;configuration management;auditing;security of data","COSAK static analysis tools;software vulnerability;software fault;software system;implicit security policy;security posture;malicious code;code auditing;OpenBSD operating system;source code review;high-risk areas;code auditors","","","4","","","","","","IEEE","IEEE Conferences"
"""Was My Contribution Fairly Reviewed?"" A Framework to Study the Perception of Fairness in Modern Code Reviews","D. German; G. Robles; G. Poo-Caamaño; X. Yang; H. Iida; K. Inoue","NA; NA; NA; NA; NA; NA","2018 IEEE/ACM 40th International Conference on Software Engineering (ICSE)","","2018","","","523","534","Modern code reviews improve the quality of software products. Although modern code reviews rely heavily on human interactions, little is known regarding whether they are performed fairly. Fairness plays a role in any process where decisions that affect others are made. When a system is perceived to be unfair, it affects negatively the productivity and motivation of its participants. In this paper, using fairness theory we create a framework that describes how fairness affects modern code reviews. To demonstrate its applicability, and the importance of fairness in code reviews, we conducted an em-pirical study that asked developers of a large industrial open source ecosystem (OpenStack) what their perceptions are regarding fairness in their code reviewing process. Our study shows that, in general, the code review process in OpenStack is perceived as fair; however, a significant portion of respondents perceive it as unfair. We also show that the variability in the way they prioritize code reviews signals a lack of consistency and the existence of bias (potentially increasing the perception of unfairness). The contributions of this paper are: (1) we propose a framework—based on fairness theory—for studying and managing social behaviour in modern code reviews, (2) we provide support for the framework through the results of a case study on a large industrial-backed open source project, (3) we present evidence that fairness is an issue in the code review process of a large open source ecosystem, and, (4) we present a set of guidelines for practitioners to address unfairness in modern code reviews.","1558-1225","978-1-4503-5638-1978-1-5386-5293","","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453118","Fairness;Software Development;Code Reviews;Open source software;human and social aspects;transparency","Process control;Organizations;Software reviews;Standards organizations;Guidelines;Ecosystems","","","","","79","","","","","","IEEE","IEEE Conferences"
"Software Development Analytics for Xen: Why and How","D. Izquierdo; J. Gonzalez-Barahona; L. Kurth; G. Robles","NA; NA; NA; NA","IEEE Software","","2018","PP","99","1","1","Xen is one of the most popular technologies for virtualization. It is produced and maintained by a software ecosystem with the participation of several large IT companies. Some years ago they decided to use software development analytics to better understand some problems they had with code review. Since them, they collect and publish several metrics, helping the ecosystem to be more self-aware of the functioning of their development processes. As a result, participants in the ecosystem can make informed decisions based on data, monitor the effects of those decisions, and in general improve the overall coordination.","0740-7459;1937-4194","","10.1109/MS.2018.290101357","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8409914","Software;Software Engineering;Software maintenance;Software management;Management of Computing and Information Systems;computing Mil;Software Engineering;metrics;measurement;process metrics","Companies;Ecosystems;Software;Measurement;Object recognition;Monitoring;Virtualization","","","","","","","","","","","IEEE","IEEE Early Access Articles"
"A Comparative Analysis of Three Replicated Experiments Comparing Inspection and Unit Testing","P. Runeson; A. Stefik; A. Andrews; S. Gronblom; I. Porres; S. Siebert","NA; NA; NA; NA; NA; NA","2011 Second International Workshop on Replication in Empirical Software Engineering Research","","2011","","","35","42","Code inspections and structural unit testing are two common defect detection methods in software development. This paper analyzes three replications of an experiment aimed at comparing which method finds more defects. The first two experiments use the same experimental design and materials, including the programs to be inspected or tested, while the third experiment replaces the programs with code for embedded systems. Participants are a mixture of graduate and undergraduate students. Our analysis shows that both the differences in the instrumentation and the between-experiment participants themselves were larger than the differences between inspection versus unit testing, especially in terms of the time to complete the tasks.","","978-0-7695-4674-2978-1-4673-0972","10.1109/RESER.2011.13","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6148335","formal experiments;replication;code inspection;unit testing","Testing;Inspection;Materials;Correlation;Educational institutions;Java;Radiation detectors","embedded systems;program testing","comparative analysis;replicated experiments;code inspections;structural unit testing;software development;embedded systems;undergraduate students","","","20","","","","","","IEEE","IEEE Conferences"
"A cognitive-based mechanism for constructing software inspection teams","J. Miller; Zhichao Yin","Dept. of Electr. & Comput. Eng., Alberta Univ., Edmonton, Alta., Canada; Dept. of Electr. & Comput. Eng., Alberta Univ., Edmonton, Alta., Canada","IEEE Transactions on Software Engineering","","2004","30","11","811","825","Software inspection is well-known as an effective means of defect detection. Nevertheless, recent research has suggested that the technique requires further development to optimize the inspection process. As the process is inherently group-based, one approach to improving performance is to attempt to minimize the commonality within the process and the group. This work proposes an approach to add diversity into the process by using a cognitively-based team selection mechanism. The paper argues that a team with diverse information processing strategies, as defined by the selection mechanism, maximize the number of different defects discovered.","0098-5589;1939-3520;2326-3881","","10.1109/TSE.2004.69","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1359772","Index Terms- Planning for SQA and V&amp;V;code inspections and walkthroughs;programming teams;software psychology.","Inspection;Costs;NIST;Information processing;Psychology;Computer bugs;Economic indicators;Investments;Testing;Personnel","program testing;program verification;cognition","cognitive-based mechanism;software inspection team;defect detection;code inspection;code walkthrough;programming team;software psychology","","22","42","","","","","","IEEE","IEEE Journals & Magazines"
"Patch Review Processes in Open Source Software Development Communities: A Comparative Case Study","J. Asundi; R. Jayant","University of Texas at Dallas, USA; University of Texas at Dallas, USA","2007 40th Annual Hawaii International Conference on System Sciences (HICSS'07)","","2007","","","166c","166c","In spite of the overwhelming success of free/open source software (F/OSS) like Apache and GNU/Linux, there is a limited understanding of the processes and methodologies that specify this form of software development. In this paper, we examine the process of patch reviews as a proxy for the extent of code-review in F/OSS projects. While existing descriptions of patch review processes are mostly narrative and based on individual experiences, we systematically analyze the email archives of five F/OSS projects to characterize this process. While doing so, we make a distinction between contributions (patches or review comments) by core members and casual contributors to grasp the role of core members in this process. Our results show that while the patch review processes are not exactly identical across various F/OSS projects, the core members across all projects play the vital role of gate-keepers to ensure a high level of review for submitted patches","1530-1605","0-7695-2755","10.1109/HICSS.2007.426","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4076712","","Open source software;Inspection;Conference management;Software development management;Management information systems;Linux;Programming;Data analysis;Costs;Art","project management;public domain software;software maintenance","patch review processes;open source software development communities;free software;Apache;GNU/Linux;F-OSS project code review","","20","26","","","","","","IEEE","IEEE Conferences"
"On the value of static analysis for fault detection in software","J. Zheng; L. Williams; N. Nagappan; W. Snipes; J. P. Hudepohl; M. A. Vouk","Dept. of Comput. Sci., North Carolina State Univ., Raleigh, NC, USA; Dept. of Comput. Sci., North Carolina State Univ., Raleigh, NC, USA; NA; NA; NA; NA","IEEE Transactions on Software Engineering","","2006","32","4","240","253","No single software fault-detection technique is capable of addressing all fault-detection concerns. Similarly to software reviews and testing, static analysis tools (or automated static analysis) can be used to remove defects prior to release of a software product. To determine to what extent automated static analysis can help in the economic production of a high-quality product, we have analyzed static analysis faults and test and customer-reported failures for three large-scale industrial software systems developed at Nortel Networks. The data indicate that automated static analysis is an affordable means of software fault detection. Using the orthogonal defect classification scheme, we found that automated static analysis is effective at identifying assignment and checking faults, allowing the later software production phases to focus on more complex, functional, and algorithmic faults. A majority of the defects found by automated static analysis appear to be produced by a few key types of programmer errors and some of these types have the potential to cause security vulnerabilities. Statistical analysis results indicate the number of automated static analysis faults can be effective for identifying problem modules. Our results indicate static analysis tools are complementary to other fault-detection techniques for the economic production of a high-quality software product.","0098-5589;1939-3520;2326-3881","","10.1109/TSE.2006.38","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1628970","Code inspections;walkthroughs.","Fault detection;Software tools;Failure analysis;Automatic testing;Software testing;Fault diagnosis;Production systems;System testing;Large-scale systems;Computer industry","program diagnostics;fault diagnosis;software quality","software fault-detection;static analysis tool;automated static analysis;Nortel Networks;orthogonal defect classification scheme;programmer error;security vulnerability;high-quality software product;code inspection;industrial software system","","94","40","","","","","","IEEE","IEEE Journals & Magazines"
"Toward Intelligent Software Defect Detection - Learning Software Defects by Example","M. J. Benson","NA","2011 IEEE 34th Software Engineering Workshop","","2011","","","138","142","Source code level software defect detection has gone from state of the art to a software engineering best practice. Automated code analysis tools streamline many of the aspects of formal code inspections but have the drawback of being difficult to construct and either prone to false positives or severely limited in the set of defects that can be detected. Machine learning technology provides the promise of learning software defects by example, easing construction of detectors and broadening the range of defects that can be found. Pinpointing software defects with the same level of granularity as prominent source code analysis tools distinguishes this research from past efforts, which focused on analyzing software engineering metrics data with granularity limited to that of a particular function rather than a line of code.","1550-6215;1550-6215","978-1-4673-0245-6978-0-7695-4627","10.1109/SEW.2011.26","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6146920","","Software;Presses;Measurement;Feature extraction;Software engineering;Machine learning;Training","learning (artificial intelligence);program diagnostics;software metrics","intelligent software defect detection;source code level software defect detection;automated code analysis tool;formal code inspection;machine learning;software engineering metrics","","1","22","","","","","","IEEE","IEEE Conferences"
"A computer hardware configuration expert system: Examination of its software reliability","N. Mori; S. Mori; A. Matsumoto","NTT, Yokosuha-Shi, Take, Japan; NTT, Yokosuha-Shi, Take, Japan; NTT, Yokosuha-Shi, Take, Japan","Proceedings of 9th IEEE Conference on Artificial Intelligence for Applications","","1993","","","306","311","Describes the implementation of an expert system called SCAT for a computer hardware configuration task. It assists system engineers in enumerating all the parts necessary to build a computer system and prepares the documents for succeeding tasks. The emphasis is placed on the software reliability metrics and the development management methodology employed in SCAT. To evaluate the software reliability of SCAT, a traditional metric was employed the number of faults detected at each stage of the test process was counted and compared with the standard value. By analyzing the fault data derived from two versions of SCAT, it was found that the code review for production rules was not as effective as it was for procedural languages. It was also found that there was a possibility that the number of faults embedded in production rules in the coding process was smaller than that in procedural languages.<<ETX>>","","0-8186-3840","10.1109/CAIA.1993.366595","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=366595","","Hardware;Expert systems;Software reliability;Production;Reliability engineering;Systems engineering and theory;Software development management;Fault detection;Software testing;Software standards","configuration management;expert systems;software reliability;software development management;software metrics;computer architecture","document preparation;fault detection;computer hardware configuration expert system;SCAT;software reliability metrics;development management methodology;code review;production rules;procedural languages","","","10","","","","","","IEEE","IEEE Conferences"
"Is Learning-to-Rank Cost-Effective in Recommending Relevant Files for Bug Localization?","F. Zhao; Y. Tang; Y. Yang; H. Lu; Y. Zhou; B. Xu","NA; NA; NA; NA; NA; NA","2015 IEEE International Conference on Software Quality, Reliability and Security","","2015","","","298","303","Software bug localization aiming to determine the locations needed to be fixed for a bug report is one of the most tedious and effort consuming activities in software debugging. Learning-to-rank (LR) is the state-of-the-art approach proposed by Ye et al. to recommending relevant files for bug localization. Ye et al.'s experimental results show that the LR approach significantly outperforms previous bug localization approaches in terms of ""precision"" and ""accuracy"". However, this evaluation does not take into account the influence of the size of the recommended files on the efficiency in detecting bugs. In practice, developers will generally spend more code inspection effort to detect bugs if larger files are recommended. In this paper, we use six large-scale open-source Java projects to evaluate the LR approach in the context of effort-aware bug localization. Our results, surprisingly, show that, when taking into account the code inspection effort to detect bugs, the LR approach is similar to or even worse than the standard VSM (Vector Space Model), a naïve IR-based bug localization approach.","","978-1-4673-7989-2978-1-4673-7988","10.1109/QRS.2015.49","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7272945","bug localization;bug reports;effort-aware;learning-to-rank;empirical study","Inspection;Computer bugs;Standards;Context;Measurement;Software;Information retrieval","information retrieval;Java;learning (artificial intelligence);program debugging;public domain software;vectors","learning-to-rank;software bug localization;software debugging;recommended files;open-source Java projects;VSM;vector space model;IR-based bug localization approach;information retrieval","","1","19","","","","","","IEEE","IEEE Conferences"
"Poster abstract: Formal analysis of fresenius infusion pump (FIP)","V. Sfyrla; S. Marcoux; C. Vittoria","Objet Direct 4 Avenue Doyen Louis Weil Grenoble, France; Fresenius Vial Le Grand Chemin Brezins, France; Fresenius Vial Le Grand Chemin Brezins, France","2013 ACM/IEEE International Conference on Cyber-Physical Systems (ICCPS)","","2013","","","253","253","Summary form only given. Today's medical devices are based on embedded architecture, with software used to control the underlying hardware. They are highly critical since errors in the software can endanger end users such as patients and medics. Medical devices should be designed and manufactured in such a way that when used, they perform as intended and they ensure a high level of safety. Current industrial practices are based on testing processes to check if the software meets the specifications and if it fulfills its purpose. However, testing does have several disadvantages that limit the reliability of this verification and validation process. Testing cannot guarantee that a device will function properly under all conditions and bugs can never be completely identified withing a program. Several attempts have already been made to provide standards for the formal verification of safety properties of medical devices, initiated by the Generic Infusion Pump project [2]. Our work is a collaboration between Objet Direct R&D and Fresenius [1]. Fresenius is a leading international health care group which produces and markets pharmaceuticals and medical devices. We aim to investigate innovative methods for software development, validation and verification. We study existing results provided amongst others by [3, 4] which we intend to extend by analyzing the Fresenius Infusion Pump (FIP) software. FIP automatizes the delivery process of fluid medical solution into patient's body. Its design is based on three layers. The highest level is the user interface and consists of three components, the administration protocol, the application system and the power management. The middle level consists of the pumping control components and the lowest level contains driver components such as Door, Watchdog, Optical Disk, Motor. FIP is modeled in UML (a total of 100 state machines) and the requirements are written in natural language. The implementation of the model is done in C++ with automatic code generation. For the V&V process, software testing checks if the implementation meets the requirements using fault scenarios written in UML. The main objective of this project is to use model-based design for migrating from software testing to formal based solution for verifying the Fresenius Infusion Pump. The goal is to use model checking technologies in order to verify requirements and eliminate bugs during the design process. Several faulty design patterns have already been identified to be caused by deadlocks, lost signal events, stack overflow, violation of real-time properties, incoherent behavior of UML state machines. We present and analyze the case study of the FIP's Motor component, a driver component of the lowest level. Its interest lies on the fact that while the Motor Control is stopped, the Motor Driver is still running. This faulty behavior was detected during the test checks and bug was partially corrected in code review.","","978-1-4503-1996","","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6604031","","Unified modeling language;Software;Testing;Safety;Computer bugs;Medical services;Pumps","biomedical equipment;embedded systems;health and safety;reliability","formal analysis;fresenius infusion pump;medical devices;embedded architecture;patient safety;industrial practices;testing processes;verification reliability;validation process;formal verification;safety property;Generic Infusion Pump project;C++ language;automatic code generation;UML model;faulty design patterns;FIP motor component","","","4","","","","","","IEEE","IEEE Conferences"
"Evaluating Software Inspection Cognition Levels Using Bloom's Taxonomy","D. A. McMeekin; B. R. von Konsky; E. Chang; D. J. A. Cooper","NA; NA; NA; NA","2009 22nd Conference on Software Engineering Education and Training","","2009","","","232","239","This paper reports on results from a pilot study that used Bloompsilas taxonomy to observe cognition levels during software inspections conducted by undergraduate computer science and software engineering students. Cognition levels associated with three different code inspection techniques were investigated. These were the ad hoc, abstraction driven, and checklist-based reading strategies. Higher cognition levels were observed when using inspection techniques that utilise a more structured reading process. This result highlights the importance of introducing novice programmers to structured code reading strategies. Findings suggest that teaching different software inspection techniques throughout software courses, beginning with structured techniques, is an excellent way to build a studentpsilas critical software reading and analysis skills.","1093-0175;2377-570X","978-1-4244-3431-2978-0-7695-3539","10.1109/CSEET.2009.15","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4812703","Bloom's taxonoomy;reading techniques;code inspections;program comprehension;cognition levels","Inspection;Cognition;Taxonomy;Writing;Open source software;Software engineering;Software maintenance;Application software;Natural languages;Ecosystems","computer aided instruction;computer science education;inference mechanisms;inspection;taxation","software inspection cognition levels;Bloom taxonomy;undergraduate computer science;software engineering students;code inspection techniques;checklist-based reading strategy;structured code reading strategies","","7","16","","","","","","IEEE","IEEE Conferences"
"Module Verifications for Function Block Based Safety-Related Industrial Control Systems","Z. Xia; Z. L. Jing; Z. X. Hao","NA; NA; NA","2012 International Conference on Computer Science and Electronics Engineering","","2012","2","","372","375","Safety-related system development is now standardized in some intimation standards such as IEC 61131, For safety-related industrial applications, we propose using Function Block concept to facilitate system specification and verification testing. Control loops are built from components taken from domain-specific function block libraries. Code inspection and testing are the two predominant quality assurance techniques. For highly dependable control applications, however, these techniques are not sufficient, in general. This paper suggests to augment testing with compositional, supported verification. The approach is based on a representation of IEC 61131-3 function blocks in higher-order logic. The verification task is separated into the a priori verification of library components and a separate proof of individual application programs.","","978-0-7695-4647-6978-1-4673-0689","10.1109/ICCSEE.2012.269","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6188042","Safety-critical control systems;dependable software;PLC programming;IEC 61131-3;modular verificationt","IEC standards;Semantics;Programming;Libraries;Automation;Automata;Input variables","control engineering computing;formal specification;formal verification;IEC standards;industrial control;manufacturing systems;production engineering computing;quality assurance;safety systems","module verification;function block based safety;safety-related industrial control system;IEC 61131 standard;function block concept;system specification;verification testing;control loop;domain-specific function block library;code inspection;code testing;quality assurance technique;higher-order logic","","","9","","","","","","IEEE","IEEE Conferences"
"Evaluating Software Product Metrics with Synthetic Defect Data","J. Stuckman; K. Wills; J. Purtilo","NA; NA; NA","2013 ACM / IEEE International Symposium on Empirical Software Engineering and Measurement","","2013","","","259","262","Source code metrics have been used in past research to predict software quality and focus tasks such as code inspection. A large number of metrics have been proposed and implemented in consumer metric software, however, a smaller, more manageable subset of these metrics may be just as suitable for accomplishing specific tasks as the whole. In this research, we introduce a mathematical model for software defect counts conditioned on product metrics, along with a method for generating synthetic defect data that chooses parameters for this model to match statistics observed in empirical bug datasets. We then show how these synthetic datasets, when combined with measurements from actual software systems, can be used to demonstrate how sets of metrics perform in various scenarios. Our preliminary results suggest that a small number of source code metrics conveys similar information as a larger set, while providing evidence for the independence of traditional software metric classifications such as size and coupling.","1949-3770;1949-3789","978-0-7695-5056","10.1109/ESEM.2013.38","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6681361","metrics;software;defect prediction;validation","Measurement;Mathematical model;Software;Data models;Predictive models;Complexity theory;Equations","pattern classification;software metrics;software quality","software product metrics;synthetic defect data;source code metrics;software quality;code inspection;consumer metric software;empirical bug datasets;software metric classifications","","2","10","","","","","","IEEE","IEEE Conferences"
"Why are Commits Being Reverted?: A Comparative Study of Industrial and Open Source Projects","J. Shimagaki; Y. Kamei; S. McIntosh; D. Pursehouse; N. Ubayashi","NA; NA; NA; NA; NA","2016 IEEE International Conference on Software Maintenance and Evolution (ICSME)","","2016","","","301","311","Software development is a cyclic process of integrating new features while introducing and fixing defects. During development, commits that modify source code files are uploaded to version control systems. Occasionally, these commits need to be reverted, i.e., the code changes need to be completely backed out of the software project. While one can often speculate about the purpose of reverted commits (e.g., the commit may have caused integration or build problems), little empirical evidence exists to substantiate such claims. The goal of this paper is to better understand why commits are reverted in large software systems. To that end, we quantitatively and qualitatively study two proprietary and four open source projects to measure: (1) the proportion of commits that are reverted, (2) the amount of time that commits that are eventually reverted linger within a codebase, and (3) the most frequent reasons why commits are reverted. Our results show that 1%-5% of the commits in the studied systems are reverted. Those commits that are eventually reverted linger within the studied codebases for 1-35 days (median). Furthermore, we identify 13 common reasons for reverting commits, and observe that the frequency of reverted commits of each reason varies broadly from project to project. A complementary qualitative analysis suggests that many reverted commits could have been avoided with better team communication and change awareness. Our findings made Sony Mobile's stakeholders aware that internally reverted commits can be reduced by paying more attention to their own changes. On the other hand, externally reverted commits could be minimized only if external stakeholders are involved to improve inter-company communication or requirements elicitation.","","978-1-5090-3806-0978-1-5090-3807","10.1109/ICSME.2016.83","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7816476","mining software repository;software evolution;code review;code inspections;revert","Mobile communication;Androids;Humanoid robots;Stakeholders;Software systems;Mobile handsets","project management;public domain software;software engineering;software management;source code (software)","industrial project;open source project;software development;source code;version control systems;software project;reverted commits;large software systems;qualitative analysis","","1","20","","","","","","IEEE","IEEE Conferences"
"On the Influence of Human Factors for Identifying Code Smells: A Multi-Trial Empirical Study","R. M. d. Mello; R. F. Oliveira; A. F. Garcia","NA; NA; NA","2017 ACM/IEEE International Symposium on Empirical Software Engineering and Measurement (ESEM)","","2017","","","68","77","Context: Code smells are symptoms in the source code that represent poor design choices. Professional developers often perceive several types of code smells as indicators of actual design problems. However, the identification of code smells involves multiple steps that are subjective in nature, requiring the engagement of humans. Human factors are likely to play a key role in the precise identification of code smells in industrial settings. Unfortunately, there is limited knowledge about the influence of human factors on smell identification. Goal: We aim at investigating whether the precision of smell identification is influenced by three key human factors, namely reviewer's professional background, reviewer's module knowledge and collaboration of reviewers during the task. We also aim at deriving recommendations for allocating human resources to smell identification tasks. Method: We performed 19 comparisons among different subsamples from two trials of a controlled experiment conducted in the context of an empirical study on code smell identification. One trial was conducted in industrial settings while the other had involved graduate students. The diversity of the samples allowed us to analyze the influence of the three factors in isolation and in conjunction. Results: We found that (i) reviewers' collaboration significantly increases the precision of smell identification, but (ii) some professional background is required from the reviewers to reach high precision. Surprisingly, we also found that: (iii) having previous knowledge of the reviewed module does not affect the precision of reviewers with higher professional background. However, this factor was influential on successful identification of more complex smells. Conclusion: We expect that our findings are helpful to support researchers in conducting proper experimental procedures in the future. Besides, they may also be useful for supporting project managers in allocating resources for smell identification tasks.","","978-1-5090-4039-1978-1-5090-4040","10.1109/ESEM.2017.13","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8170086","code smell identification;human factors;context;collaboration;code review;replication","Human factors;Collaboration;Tools;Software systems;Software measurement","human factors;software maintenance;software quality","code smells;multitrial empirical study;human factors;complex smells;code smell identification;smell identification tasks;human resources","","","27","","","","","","IEEE","IEEE Conferences"
"Towards automation of checklist-based code-reviews","F. Belli; R. Crisan","Dept. of Electr. & Electron. Eng., Paderborn Univ., Germany; NA","Proceedings of ISSRE '96: 7th International Symposium on Software Reliability Engineering","","1996","","","24","33","Different types of code-reviews (Fagan-style code-inspections, Parnas-like active design reviews and walkthroughs) have been found to be very useful in improving the quality of software. In many cases reviewers use checklists to guide their analysis during review sessions. However, valuable, checklist-based code-reviews have the principal shortcoming of their high costs due to lack of supporting tools enabling at least partial automation of typical multiple appearing rules. This paper describes an approach towards semi-automation of some steps of individual review processes based on checklists. The method proposed is interactive, i.e. reviewers will be enabled to actualize, extend, and check the consistency and redundancy of their checklists. The basic idea underlying the approach is the usage of a rule-based system, adapting concepts of the compiler theory and knowledge engineering, for acquisition and representation of knowledge about the program. Redundant and conflicting knowledge about the program under study is recognized and solved by means of an embedded truth maintenance system. As a result of fault diagnosis, rules for fault classification are used. Software reliability models are applied to validate the results of each review session. The approach has shown promising preliminary results in analyses of conventional C-programs developed in the automotive industry.","1071-9658","0-8186-7707","10.1109/ISSRE.1996.558687","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=558687","","Automation;Software quality;Costs;Redundancy;Knowledge based systems;Program processors;Knowledge engineering;Maintenance;Fault diagnosis;Software reliability","software quality","checklist-based code-reviews;code-inspection;active design reviews;walkthroughs;software quality;costs;software tools;multiple appearing rules;rule-based system;compiler theory;knowledge engineering;knowledge acquisition;knowledge representation;embedded truth maintenance system;fault diagnosis;fault classification;software reliability models;C-programs;automotive industry","","8","24","","","","","","IEEE","IEEE Conferences"
"Sentiment Identification for Collaborative, Geographically Dispersed, Cross-Functional Software Development Teams","A. Patwardhan","NA","2017 IEEE 3rd International Conference on Collaboration and Internet Computing (CIC)","","2017","","","20","26","The process of software development is a collaborative effort that may consist of various geographically dispersed teams. It involves extensive communication over emails, intra-company forums, blogs, surveys and code reviews. The high level of message and opinion exchange evokes positive and negative emotions regarding the software project delivery. This paper proposed techniques to identify the underlying emotion polarity across various collaborating teams by analyzing the communication during the software release cycle. It also evaluated whether there was a relation between emotion polarity and social factors and software artifacts such as gender, location of team, experience level, release duration, team size, code issue count and code review comments. The sentiment analysis was used to implement an emotion dashboard to measure the project success and emotional health across various cross-functional software development teams. 80% of the managers found the tool useful in improving the overall team morale and 70% managers found the dashboard useful for identifying the emotional health of the collaborating teams.","","978-1-5386-2565-1978-1-5386-2566","10.1109/CIC.2017.00014","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8181475","Sentiment Analysis;Team collaboration;Emotion mining;Emotion Aware Software Development Process and Monitoring","Software;Electronic mail;Sentiment analysis;Business;Feature extraction;Collaboration;Tools","project management;sentiment analysis;social aspects of automation;software development management;team working","sentiment identification;cross-functional software development teams;collaborative effort;geographically dispersed teams;software project delivery;software release cycle;emotion dashboard;team collaboration;sentiment analysis;emotion polarity;opinion exchange;team morale","","","22","","","","","","IEEE","IEEE Conferences"
"Can safety-critical software be flexible?","S. W. Fraser","Vantage Comput. Technol. Inc., Cary, NC, USA","Proceedings Fifth IEEE Workshop on Mobile Computing Systems and Applications","","2003","","","588","593","Safety-critical software systems follow rigorous software processes to ensure safety to human life. These rigorous processes have a tendency to limit how safety-critical software is written. In addition, automation tools and manual processes are used to inspect every path of execution flow of safety-critical software to ensure predictable behavior. As a result of these rigorous processes, safety-critical software is more expensive to develop and maintain. On the other hand, the primary goal of software stability is to separate the enduring technology portions of software from easily changeable domain portions of the software. By doing so, the software becomes more flexible and can evolve with less effort and cost. Enduring business themes (EBT) is the most written about software technique for developing stable software. The EBT technique is object-oriented and promotes use of interpreters, compilers, and rules engines, which replace readable code with translation of human readable input. In contrast, guidelines for the development of safety-critical software do not fully address the use of object-oriented languages, and lace a strong emphasis on code inspection to clearly identify all paths of execution as deterministic. Thus, software stability approaches appear to be at conflict with the rigorous practices required in safety-critical software systems. Can safety-critical software development embrace software stability concepts to allow the software to be easier to change and adapt? We think the safety-critical software can be made flexible; we show you how in this paper.","","0-7803-8242","10.1109/IRI.2003.1251470","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1251470","","Software safety;Software systems;Stability;Humans;Automation;Software tools;Software maintenance;Costs;Engines;Guidelines","safety-critical software","safety-critical software;software process;automation tools;manual process;execution flow;software stability;enduring business themes;EBT;readable input;object-oriented languages;software development;rules engine;program compiler;program interpreters","","1","15","","","","","","IEEE","IEEE Conferences"
"Transition-by-transition FSM traversal for reachability analysis in bounded model checking","M. D. Nguyen; D. Stoffel; M. Wedler; W. Kunz","Dept. of Electr. & Comput. Eng., Kaiserslautern Univ., Germany; Dept. of Electr. & Comput. Eng., Kaiserslautern Univ., Germany; Dept. of Electr. & Comput. Eng., Kaiserslautern Univ., Germany; Dept. of Electr. & Comput. Eng., Kaiserslautern Univ., Germany","ICCAD-2005. IEEE/ACM International Conference on Computer-Aided Design, 2005.","","2005","","","1068","1075","In bounded model checking (BMC)-based verification flows lack of reachability constraints often leads to false negatives. At present, it is daily practice of a verification engineer to identify the missing reachability constraints by manually inspecting the design code and by analyzing counterexamples. This, unfortunately, requires a lot of effort and is prone to errors. We propose an algorithm to determine reachability constraints automatically. The proposed approach applies to a design style where the operation of the design is controlled by a main FSM which can easily be extracted from the RTL description of the circuit. The algorithm decomposes and analyzes the state space of the circuit by considering transitions of the main FSM. Experimental results show that the proposed method can considerably reduce the manual work of verification engineers.","1092-3152;1558-2434","0-7803-9254","10.1109/ICCAD.2005.1560219","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1560219","","Reachability analysis;Counting circuits;Design engineering;Automatic control;Algorithm design and analysis;State-space methods;Sequential circuits;Equations;Protocols","formal verification;sequential circuits;state-space methods;finite state machines","reachability analysis;bounded model checking;verification flows;design code inspection;reachability constraints;FSM;RTL description;state space","","1","27","","","","","","IEEE","IEEE Conferences"
"Automating techniques for inspecting high assurance systems","M. S. Fisher; B. Cukic","NA; NA","Proceedings Sixth IEEE International Symposium on High Assurance Systems Engineering. Special Topic: Impact of Networking","","2001","","","117","126","Software inspections are an example of a validation technique for improving software product quality and reducing development time and cost. They are a peer-review process that have shown to decrease costs, decrease development time, and increase quality through a detailed examination of work-in-progress with the objective of identifying defects. In this paper, we report a methodology used for modeling the defects found during a code inspection. The Orthogonal Defect Classification (ODC) was used to categorize and make inferences that resulted in synthesized checklists that reflect the latest project experience and the rules most frequently broken during software development. We were then able to develop techniques that automatically used the checklists to search for defects in the source code. This automated defect detection technique will free up resources that can be used to look for more project specific issues.","1530-2059","0-7695-1275","10.1109/HASE.2001.966813","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=966813","","Inspection;Costs;NASA;Software quality;Software safety;Testing;Programming;Project management;Delay;Personnel","program testing;software engineering","software inspections;validation technique;software product quality;development time;development cost;peer-review process;orthogonal defect classification;synthesized checklists;software development;automated defect detection technique","","2","17","","","","","","IEEE","IEEE Conferences"
"Static Security Analysis Based on Input-Related Software Faults","C. Nagy; S. Mancoridis","NA; NA","2009 13th European Conference on Software Maintenance and Reengineering","","2009","","","37","46","It is important to focus on security aspects during the development cycle to deliver reliable software. However, locating security faults in complex systems is difficult and there are only a few effective automatic tools available to help developers. In this paper we present an approach to help developers locate vulnerabilities by marking parts of the source code that involve user input. We focus on input-related code, since an attacker can usually take advantage of vulnerabilities by passing malformed input to the application. The main contributions of this work are two metrics to help locate faults during a code review, and algorithms to locate buffer overflow and format string vulnerabilities in C source code. We implemented our approach as a plug in to the Grammatech CodeSurfer tool. We tested and validated our technique on open source projects and we found faults in software that includes Pidgin and cyrus-imapd.","1534-5351","978-1-4244-3755-9978-0-7695-3589","10.1109/CSMR.2009.51","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4812737","static analysis;security analysis","Data security;Buffer overflow;Software maintenance;Open source software;Software algorithms;Computer security;Software systems;Performance analysis;Fault diagnosis;Software engineering","program diagnostics;security of data;software metrics;software reliability","static security analysis;input-related software faults;reliable software;complex systems;software development;C source code;Grammatech CodeSurfer tool","","6","33","","","","","","IEEE","IEEE Conferences"
"Software Security; A Vulnerability Activity Revisit","M. A. Hadavi; H. Shirazi; H. M. Sangchi; V. S. Hamishagi","NA; NA; NA; NA","2008 Third International Conference on Availability, Reliability and Security","","2008","","","866","872","This paper attempts to introduce a method for developing secure software based on the vulnerabilities which are already known. In the proposed method, the most prevalent vulnerabilities are selected. For each vulnerability its location of appearance within the software development process, as well as methods of mitigation through design-level or implementation- level activities is discussed. Mapping vulnerabilities to design and implementation within software development process not only results to a better understanding of vulnerability emergence, but also allows countermeasures to be applied during initial steps of vulnerability creation, and thus better software security. This mapping shows that choosing a suitable programming language and enforcing the least privileges are the most vital design time decisions. Also, security code review and server side input validation are implementation-level activities assumed to cover most of the vulnerabilities.","","978-0-7695-3102","10.1109/ARES.2008.200","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4529435","software;security;Vulnerability;design;implementation;Activity","Programming;Application software;Open source software;Software engineering;Data security;Software design;Availability;Reliability engineering;Computer languages;Network servers","safety-critical software;security of data","software security;vulnerability-activity revisit;software development process;vulnerability emergence;vulnerability creation","","5","46","","","","","","IEEE","IEEE Conferences"
"A large-scale empirical study of just-in-time quality assurance","Y. Kamei; E. Shihab; B. Adams; A. E. Hassan; A. Mockus; A. Sinha; N. Ubayashi","Kyushu University, Fukuoka; Rochester Institute of Technology, Rochester; École Polytechnique de Montréal, Montréal; Queen's University, Kingston; Avaya Labs Research, Basking Ridge; Research In Motion, Waterloo; Kyushu University, Fukuoka","IEEE Transactions on Software Engineering","","2013","39","6","757","773","Defect prediction models are a well-known technique for identifying defect-prone files or packages such that practitioners can allocate their quality assurance efforts (e.g., testing and code reviews). However, once the critical files or packages have been identified, developers still need to spend considerable time drilling down to the functions or even code snippets that should be reviewed or tested. This makes the approach too time consuming and impractical for large software systems. Instead, we consider defect prediction models that focus on identifying defect-prone (“risky”) software changes instead of files or packages. We refer to this type of quality assurance activity as “Just-In-Time Quality Assurance,” because developers can review and test these risky changes while they are still fresh in their minds (i.e., at check-in time). To build a change risk model, we use a wide range of factors based on the characteristics of a software change, such as the number of added lines, and developer experience. A large-scale study of six open source and five commercial projects from multiple domains shows that our models can predict whether or not a change will lead to a defect with an average accuracy of 68 percent and an average recall of 64 percent. Furthermore, when considering the effort needed to review changes, we find that using only 20 percent of the effort it would take to inspect all changes, we can identify 35 percent of all defect-inducing changes. Our findings indicate that “Just-In-Time Quality Assurance” may provide an effort-reducing way to focus on the most risky changes and thus reduce the costs of developing high-quality software.","0098-5589;1939-3520;2326-3881","","10.1109/TSE.2012.70","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6341763","Maintenance;software metrics;mining software repositories;defect prediction;just-in-time prediction","Measurement;Quality assurance;Predictive models;Software;Entropy;Object oriented modeling;Accuracy","program testing;software maintenance;software metrics;software quality","just-in-time quality assurance;defect prediction models;defect-prone file identification;defect-prone package identification;software systems;risk model;open source projects;commercial projects;risky changes;cost reduction;defect-prone software change identification;software metrics;software repository mining;software quality assurance activities;source code inspection;unit testing","","77","63","","","","","","IEEE","IEEE Journals & Magazines"
"WAP: Understanding the Brain at Software Debugging","J. Duraes; H. Madeira; J. Castelhano; C. Duarte; M. C. Branco","NA; NA; NA; NA; NA","2016 IEEE 27th International Symposium on Software Reliability Engineering (ISSRE)","","2016","","","87","92","We propose that understanding functional patterns of activity in mapped brain regions associated with code comprehension tasks and, more specifically, to the activity of finding bugs in traditional code inspections could reveal useful insights to improve software reliability and to improve the software development process in general. This includes helping to select the best professionals for the debugging effort, improving the conditions for code inspections, and identify new directions to follow for training code reviewers. This paper presents an interdisciplinary study to analyze the brain activity during code inspection tasks using functional magnetic resonance imaging (fMRI), which is a well-established tool in cognitive neuroscience research. We used several programs where realistic bugs representing the most frequent types of software faults found in the field were injected. The code inspectors involved in the research include programmers with different levels of expertise and experience in real code reviews. The goal is to understand brain activity patterns associated with code comprehension tasks and, more specifically, the brain activity when the code reviewer identifies a bug in the code ('eureka' moment), which can be a true positive or a false positive. Our results confirmed that brain areas associated with language processing and mathematics are highly active during code reviewing and shows that there are specific brain activity patterns that can be related to the decision-making moment of suspicion/bug detection. Importantly, the activity at the anterior insula region that we find to play a relevant role in the process of identifying software bugs is positively correlated to the precision of bug detection by the inspectors. This finding provides a new perspective on the role of this region on error awareness and monitoring and of its potential predictive value in predicting the quality of bug removing.","2332-6549","978-1-4673-9002-6978-1-4673-9003","10.1109/ISSRE.2016.53","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7774510","software faults;ODC;software inspections;fRMI;cognitive neuroscience","Software;Computer bugs;Inspection;Brain;Magnetic resonance imaging;Software reliability;Neuroscience","biomedical MRI;program debugging;software engineering;software reliability","software debugging;WAP;activity functional patterns;brain regions;code comprehension tasks;code inspections;software reliability improvement;software development process;debugging effort;functional magnetic resonance imaging;fMRI;cognitive neuroscience research;realistic bugs;software faults;brain activity patterns;language processing;code reviewing;decision-making moment;suspicion-bug detection;anterior insula region;error awareness;error monitoring;bug removing quality prediction","","","15","","","","","","IEEE","IEEE Conferences"
"Estimating the number of faults remaining in software code documents inspected with iterative code reviews","A. Harel; K. Kantorowitz","Technion-Israel Inst. of Technol., Haifa, Israel; Technion-Israel Inst. of Technol., Haifa, Israel","IEEE International Conference on Software - Science, Technology & Engineering (SwSTE'05)","","2005","","","151","160","Code review is considered an efficient method for detecting faults in a software code document. The number of faults not detected by the review should be small. Current methods for estimating this number assume reviews with several inspectors, but there are many cases where it is practical to employ only two inspectors. Sufficiently accurate estimates may be obtained by two inspectors employing an iterative code review (ICR) process. This paper introduces a new estimator for the number of undetected faults in an ICR process, so the process may be stopped when a satisfactory result is estimated. This technique employs the Kantorowitz estimator for N-fold inspections, where the N teams are replaced by N reviews. The estimator was tested for three years in an industrial project, where it produced satisfactory results. More experiments are needed in order to fully evaluate the approach.","","0-7695-2335","10.1109/SWSTE.2005.1","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1421075","","Inspection;Animals;Fault detection;Computer science;Chromium;Iterative methods;Testing;Software engineering;Job shop scheduling;Biological information theory","program testing;program verification;program debugging;software performance evaluation","software code document;iterative code reviews;Kantorowitz estimator;N-fold inspections;industrial project","","1","33","","","","","","IEEE","IEEE Conferences"
"Situational awareness: Personalizing issue tracking systems","O. Baysal; R. Holmes; M. W. Godfrey","Software Architecture Group (SWAG), David R. Cheriton School of Computer Science, University of Waterloo, Canada; Software Architecture Group (SWAG), David R. Cheriton School of Computer Science, University of Waterloo, Canada; Software Architecture Group (SWAG), David R. Cheriton School of Computer Science, University of Waterloo, Canada","2013 35th International Conference on Software Engineering (ICSE)","","2013","","","1185","1188","Issue tracking systems play a central role in ongoing software development; they are used by developers to support collaborative bug fixing and the implementation of new features, but they are also used by other stakeholders including managers, QA, and end-users for tasks such as project management, communication and discussion, code reviews, and history tracking. Most such systems are designed around the central metaphor of the “issue” (bug, defect, ticket, feature, etc.), yet increasingly this model seems ill fitted to the practical needs of growing software projects; for example, our analysis of interviews with 20 Mozilla developers who use Bugzilla heavily revealed that developers face challenges maintaining a global understanding of the issues they are involved with, and that they desire improved support for situational awareness that is difficult to achieve with current issue management systems. In this paper we motivate the need for personalized issue tracking that is centered around the information needs of individual developers together with improved logistical support for the tasks they perform. We also describe an initial approach to implement such a system - extending Bugzilla - that enhances a developer's situational awareness of their working context by providing views that are tailored to specific tasks they frequently perform; we are actively improving this prototype with input from Mozilla developers.","0270-5257;1558-1225","978-1-4673-3076-3978-1-4673-3073","10.1109/ICSE.2013.6606674","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6606674","","Computer bugs;Software;Prototypes;Interviews;Electronic mail;Target tracking;Software engineering","online front-ends;project management;software development management","issue tracking system personalization;software development;collaborative bug fixing;project management;code review;history tracking;software project;Mozilla developers;Bugzilla;issue management system;information needs;logistical support;developer situational awareness","","3","20","","","","","","IEEE","IEEE Conferences"
"Synthesizing Continuous Deployment Practices Used in Software Development","A. A. U. Rahman; E. Helms; L. Williams; C. Parnin","NA; NA; NA; NA","2015 Agile Conference","","2015","","","1","10","Continuous deployment speeds up the process of existing agile methods, such as Scrum, and Extreme Programming (XP) through the automatic deployment of software changes to end-users upon passing of automated tests. Continuous deployment has become an emerging software engineering process amongst numerous software companies, such as Facebook, Github, Netflix, and Rally Software. A systematic analysis of software practices used in continuous deployment can facilitate a better understanding of continuous deployment as a software engineering process. Such analysis can also help software practitioners in having a shared vocabulary of practices and in choosing the software practices that they can use to implement continuous deployment. The goal of this paper is to aid software practitioners in implementing continuous deployment through a systematic analysis of software practices that are used by software companies. We studied the continuous deployment practices of 19 software companies by performing a qualitative analysis of Internet artifacts and by conducting follow-up inquiries. In total, we found 11 software practices that are used by 19 software companies. We also found that in terms of use, eight of the 11 software practices are common across 14 software companies. We observe that continuous deployment necessitates the consistent use of sound software engineering practices such as automated testing, automated deployment, and code review.","","978-1-4673-7153","10.1109/Agile.2015.12","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7284592","agile;continuous deployment;continuous delivery;industry practices;internet artifacts;follow-up inquiries","Software;Companies;Internet;Testing;Software engineering;Facebook;Industries","program testing;software prototyping","continuous deployment;software development;agile methods;Scrum;extreme programming;XP;automated tests;software engineering process;software companies;Internet artifacts;automated deployment;code reviewing","","12","43","","","","","","IEEE","IEEE Conferences"
"Evaluation of static analysis tools for software security","H. H. AlBreiki; Q. H. Mahmoud","Department of Computer Information Science, Higher Colleges of Technology, UAE; Department of Electrical, Computer and Software Eng. University of Ontario Institute of Technology, Canada","2014 10th International Conference on Innovations in Information Technology (IIT)","","2014","","","93","98","Security has been always treated as an add-on feature in the software development lifecycle, and addressed by security professionals using firewalls, proxies, intrusion prevention systems, antivirus and platform security. Software is at the root of all common computer security problems, and hence hackers don't create security holes, but rather exploit them. Security holes in software applications are the result of bad design and implementation of software systems and applications. To address this problem, several initiatives for integrating security in the software development lifecycle have been proposed, along with tools to support a security-centric software development lifecycle. This paper introduces a framework for evaluating security static analysis tools such as source code analyzers, and offers evaluation of non-commercial static analysis tools such as Yasca, CAT.NET, and FindBugs. In order to evaluate the effectiveness of such tools, common software weaknesses are defined based on CWE/SANS Top 25, OWASP Top Ten and NIST source code weaknesses. The evaluation methodology is based on the NIST Software Assurance Metrics And Tool Evaluation (SAMATE). Results show that security static analysis tools are, to some extent, effective in detecting security holes in source code; source code analyzers are able to detect more weaknesses than bytecode and binary code scanners; and while tools can assist the development team in security code review activities, they are not enough to uncover all common weaknesses in software. The new test cases developed for this research have been contributed to the NIST Software Assurance Reference Dataset (samate.nist.gov/SARD).","","978-1-4799-7212-8978-1-4799-7210","10.1109/INNOVATIONS.2014.6987569","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6987569","software security;static analysis;OWASP;SAMATE;security metrics","Security;Software;Java;Binary codes;NIST;Computer architecture;Industries","program diagnostics;security of data;software metrics;software tools;source code (software)","security static analysis tools;software security;firewalls;proxies;intrusion prevention systems;antivirus;platform security;hackers;security holes;security-centric software development lifecycle;source code analyzers;noncommercial static analysis tools;Yasca;CAT.NET;FindBugs;CWE-SANS Top 25;OWASP Top Ten;NIST source code weaknesses;NIST software assurance metrics and tool evaluation;NIST SAMATE;NIST software assurance reference dataset","","3","30","","","","","","IEEE","IEEE Conferences"
"State of Mutation Testing at Google","G. Petrovic; M. Ivankovic","NA; NA","2018 IEEE/ACM 40th International Conference on Software Engineering: Software Engineering in Practice Track (ICSE-SEIP)","","2017","","","163","171","Mutation testing assesses test suite efficacy by inserting small faults into programs and measuring the ability of the test suite to detect them. It is widely considered the strongest test criterion in terms of finding the most faults and it subsumes a number of other coverage criteria. Traditional mutation analysis is computationally prohibitive which hinders its adoption as an industry standard. In order to alleviate the computational issues, we present a diff-based probabilistic approach to mutation analysis that drastically reduces the number of mutants by omitting lines of code without statement coverage and lines that are determined to be uninteresting - we dub these arid lines. Furthermore, by reducing the number of mutants and carefully selecting only the most interesting ones we make it easier for humans to understand and evaluate the result of mutation analysis. We propose a heuristic for judging whether a node is arid or not, conditioned on the programming language. We focus on a code-review based approach and consider the effects of surfacing mutation results on developer attention. The described system is used by 6,000 engineers in Google on all code changes they author or review, affecting in total more than 13,000 code authors as part of the mandatory code review process. The system processes about 30% of all diffs across Google that have statement coverage calculated. About 15% of coverage statement calculations fail across Google.","","978-1-4503-5659-6978-1-5386-6360","","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8449247","mutation testing;code coverage;test efficacy","Google;Testing;Tools;Compounds;Computer languages;Probabilistic logic;Syntactics","","","","","18","","","","","","IEEE","IEEE Conferences"
"Are One-Time Contributors Different? A Comparison to Core and Periphery Developers in FLOSS Repositories","A. Lee; J. C. Carver","NA; NA","2017 ACM/IEEE International Symposium on Empirical Software Engineering and Measurement (ESEM)","","2017","","","1","10","Context: Free/Libre Open Source Software (FLOSS) communities consist of different types of contributors. Core contributors and peripheral contributors work together to create a successful project, each playing a different role. One-Time Contributors (OTCs), who are on the very fringe of the peripheral developers, are largely unstudied despite offering unique insights into the development process. In a prior survey, we identified OTCs and discovered their motivations and barriers. Aims: The objective of this study is to corroborate the survey results and provide a better understand of OTCs. We compare OTCs to other peripheral and core contributors to determine whether they are distinct. Method: We mined data from the same code-review repository used to identify survey respondents in our previous study. After identifying each contributor as core, periphery, or OTC, we compared them in terms of patch size, time interval from submission to decision, the nature of their conversations, and patch acceptance rates. Results: We identified a continuum between core developers and OTCs. OTCs create smaller patches, face longer time intervals between patch submission and rejection, have longer review conversations, and face lower patch acceptance rates. Conversely, core contributors create larger patches, face shorter time intervals for feedback, have shorter review conversations, and have patches accepted at the highest rate. The peripheral developers fall in between the OTCs and the core contributors. Conclusion: OTCs do, in fact, face the barriers identified in our prior survey. They represent a distinct group of contributors compared to core and peripheral developers.","","978-1-5090-4039-1978-1-5090-4040","10.1109/ESEM.2017.7","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8169979","FLOSS;One-Time Contributors;OTC;repository mining","Computer bugs;Face;Data mining;Computer science;Electronic mail;Open source software","data mining;public domain software","one-time contributors;periphery developers;Free/Libre Open Source Software communities;core contributors;peripheral contributors;playing a different role;OTC;peripheral developers;development process;time interval;core developers;face longer time intervals;face shorter time intervals","","1","16","","","","","","IEEE","IEEE Conferences"
"Cesar: Visual representation of source code vulnerabilities","H. Assal; S. Chiasson; R. Biddle","School of Computer Science, Carleton University; School of Computer Science, Carleton University; School of Computer Science, Carleton University","2016 IEEE Symposium on Visualization for Cyber Security (VizSec)","","2016","","","1","8","Code analysis tools are not widely accepted by developers, and software vulnerabilities are detected by the thousands every year. We take a user-centered approach to that problem, starting with analyzing one of the popular open source static code analyzers, and uncover serious usability issues facing developers. We then design Cesar, a system offering developers a visual analysis environment to support their quest to rid their code of vulnerabilities. We present a prototype implementation of Cesar, and perform a usability analysis of the prototype and the visualizations it employs. Our analysis shows that the prototype is promising in promoting collaboration, exploration, and enabling developers to focus on the overall quality of their code as well as inspect individual vulnerabilities. We finally provide general recommendations to guide future designs of code review tools to enhance their usability.","","978-1-5090-1605-1978-1-5090-1606","10.1109/VIZSEC.2016.7739576","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7739576","","Security;Visualization;Usability;Collaboration;Prototypes;Computer science","program diagnostics;program visualisation;source code (software)","user-centered approach;open source static code analyzers;usability issues;Cesar;visual analysis environment;source code vulnerabilities","","2","23","","","","","","IEEE","IEEE Conferences"
"The importance of testing Smart Grid IEDs against security vulnerabilities","P. E. Weerathunga; A. Cioraca","General Electric Grid Solutions - Canada; General Electric Grid Solutions - Canada","2016 69th Annual Conference for Protective Relay Engineers (CPRE)","","2016","","","1","21","As the Smart Grid becomes highly interconnected, the power protection, control, and monitoring functions of the grid are increasingly relying on the communications infrastructure, which has seen rapid growth. At the same time concerns regarding cyber threats have attracted significant attention towards the security of power systems. A properly designed security attack against the power grid can cause catastrophic damages to equipment and create large scale power outages. The smart grid consists of critical IEDs, which are considered high priority targets for malicious security attacks. For this reason it is very important to design the IEDs from the beginning with cyber security in mind, starting with the selection of hardware and operating systems, so that all facets of security are addressed and the product is robust and can stand attacks. Fact is that the subject of cyber security is vast and it covers many aspects. This paper focuses mainly on one of these aspects, namely the aspect of IED firmware system testing from the security point of view. The paper discusses practical aspects of IED security testing, and introduces the reader to types of vulnerability exploitations on the IED communication stack and SCADA applications, practical aspects of security testing, the importance of early vulnerability detection and ways in which the security testing helps towards regulatory standards compliance, such as NERC-CIP. Finally, based on the results from the simulated attacks, the paper discusses the importance of good security practices in design and coding, so that the potential to introduce vulnerabilities is kept to a minimum. Designing with security in mind also includes good security practices, both in design and coding, and adequate policies for the software development process. Critical software development milestones must be established, such as design and test documentation review, code review, unit, integration and system testing.","2474-9753","978-1-5090-1532-0978-1-5090-1533","10.1109/CPRE.2016.7914920","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7914920","IED = Intelligent Electronic Device;OT = Operational Technology;TCP/IP = Transmission Control Protocol/Internet Protocol;IT = Information Technology;CVE = Common Vulnerabilities and Exposures;CPU = Central Processing Unit;OSI = Open System Interconnect;UDP = User Datagram Protocol;DNP = Distributed Network Protocol;IP = Internet Protocol;MAC = Media Access Control;MTU = Maximum Transmission Unit","Protocols;Software;Computer security;System testing;Encoding","power system reliability;power system security;smart power grids","smart grid IED;security vulnerabilities;power protection;power control;power monitoring functions;communications infrastructure;cyber threats;power system security;power grid;large scale power outages;malicious security attacks;cyber security;IED firmware system testing;vulnerability exploitations;IED communication stack;SCADA applications;early vulnerability detection;NERC-CIP;software development process","","2","3","","","","","","IEEE","IEEE Conferences"
"BP: Integrating Cyber Vulnerability Assessments Earlier into the Systems Development Lifecycle: A Methodology to Conduct Early-Cycle Cyber Vulnerability Assessments","S. Glumich; J. Riley; P. Ratazzi; A. Ozanam","NA; NA; NA; NA","2018 IEEE Cybersecurity Development (SecDev)","","2018","","","77","84","During development of high assurance cyber systems, third-party security evaluations such as cyber vulnerability assessments (CVAs) and red teaming may not be conducted until after system implementation. This late in the systems development lifecycle (SDLC), mitigating a single implementation vulnerability may require altering the system requirements, architecture, and design, resulting in a cascade of secondary effects that necessitate additional implementation changes. This paper proposes to identify and mitigate vulnerabilities earlier in the SDLC by conducting early-cycle CVAs (eCVAs). eCVAs initiate the vulnerability assessment process earlier and integrate three CVAs into the SDLC. The three types of assessments include a requirements CVA to analyze system requirements specifications, an architecture and design CVA to evaluate architecture and design artifacts, and an implementation CVA with a focus on manual code review, static and dynamic analysis, and researching leveraged code for known vulnerabilities. This paper describes the three types of CVAs and outlines the results of a year-long pilot effort carried out by the Air Force Research Laboratory Information Directorate eCVA team.","","978-1-5386-7662-2978-1-5386-7661-5978-1-5386-7663","10.1109/SecDev.2018.00018","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8543390","Cyber Vulnerability Assessment, Systems Development Lifecycle, Cyber Security, Systems Engineering","Security;Unified modeling language;Computer architecture;Modeling;Documentation;Mathematical model;Hardware","formal specification;security of data;software development management;systems engineering","SDLC;vulnerability assessment process;Air Force Research Laboratory Information Directorate eCVA team;systems development lifecycle;early-cycle cyber vulnerability assessments;third-party security evaluations;system requirements specifications;system architecture;system design;eCVA;early-cycle CVA","","","7","","","","","","IEEE","IEEE Conferences"
"Software Security: Building Security In","G. McGraw","Cigital, Inc.","2006 17th International Symposium on Software Reliability Engineering","","2006","","","6","6","Summary form only given. Software security has come a long way in the last few years, but we've really only just begun. I will present a detailed approach to getting past theory and putting software security into practice. The three pillars of software security are applied risk management, software security best practices (which I call touchpoints), and knowledge. By describing a manageably small set of touchpoints based around the software artifacts that you already produce, I avoid religious warfare over process and get on with the business of software security. That means you can adopt the touchpoints without radically changing the way you work. The touchpoints I will describe include: code review using static analysis tools; architectural risk analysis; penetration testing; security testing; abuse case development; and security requirements. Like the yin and the yang, software security requires a careful balance-attack and defense, exploiting and designing, breaking and building-bound into a coherent package. Create your own Security Development Lifecycle by enhancing your existing software development lifecycle with the touchpoints","1071-9458;2332-6549","0-7695-2684","10.1109/ISSRE.2006.43","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4021964","","National security;Risk analysis;Software testing;Books;Java;Privacy;Risk management;Best practices;Software tools;Software packages","program diagnostics;program testing;risk analysis;security of data;software architecture;software reliability","software security;risk management;static analysis;architectural risk analysis;penetration testing;security testing;abuse case development;security requirements;security development lifecycle;software development lifecycle","","103","","","","","","","IEEE","IEEE Conferences"
"Multi-objective Cross-Project Defect Prediction","G. Canfora; A. De Lucia; M. Di Penta; R. Oliveto; A. Panichella; S. Panichella","NA; NA; NA; NA; NA; NA","2013 IEEE Sixth International Conference on Software Testing, Verification and Validation","","2013","","","252","261","Cross-project defect prediction is very appealing because (i) it allows predicting defects in projects for which the availability of data is limited, and (ii) it allows producing generalizable prediction models. However, existing research suggests that cross-project prediction is particularly challenging and, due to heterogeneity of projects, prediction accuracy is not always very good. This paper proposes a novel, multi-objective approach for cross-project defect prediction, based on a multi-objective logistic regression model built using a genetic algorithm. Instead of providing the software engineer with a single predictive model, the multi-objective approach allows software engineers to choose predictors achieving a compromise between number of likely defect-prone artifacts (effectiveness) and LOC to be analyzed/tested (which can be considered as a proxy of the cost of code inspection). Results of an empirical evaluation on 10 datasets from the Promise repository indicate the superiority and the usefulness of the multi-objective approach with respect to single-objective predictors. Also, the proposed approach outperforms an alternative approach for cross-project prediction, based on local prediction upon clusters of similar classes.","2159-4848","978-0-7695-4968-2978-1-4673-5961","10.1109/ICST.2013.38","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6569737","Cross-project defect prediction;multi-objective optimization;search-based software engineering","Predictive models;Software;Data models;Measurement;Logistics;Inspection;Accuracy","genetic algorithms;pattern clustering;regression analysis;search problems;software engineering;software management","multiobjective cross-project defect prediction accuracy;generalizable prediction models;project heterogeneity;multiobjective logistic regression model;genetic algorithm;defect-prone artifacts;LOC testing;Promise repository;software engineers;LOC analysis;GA","","38","21","","","","","","IEEE","IEEE Conferences"
"High-Assurance Distributed, Adaptive Software for Dynamic Systems","K. Rohloff; J. Loyall; P. Pal; R. Schantz","NA; NA; NA; NA","10th IEEE High Assurance Systems Engineering Symposium (HASE'07)","","2007","","","385","386","Exhaustive testing, documentation, code review, and formal methods have been the main approaches for software certification in high confidence cyber-physical systems. Although these methods have been sufficient in the past, continued reliance on these methods is no longer economically feasible for increasingly complex modern, distributed, dynamic systems due to inherent problems of state-explosions. Examples of such distributed high-assurance systems include DoD systems (including secure, timely command, control and information sharing systems and for military logistics), systems for manufacturing and process control (for industries whose safety is of critical national importance such as transportation, chemical, oil and natural gas), and medical systems among others. We need to develop innovative, economically feasible means to certify distributed dynamic control software for cyber-physical systems so that when these systems are deployed, harmful unpredictable emergent behavior does not manifest itself.","1530-2059","0-7695-3043-5978-0-7695-3043","10.1109/HASE.2007.17","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4404768","","Software systems;Medical control systems;Control systems;Chemical industry;Software testing;System testing;Documentation;Certification;Logistics;Manufacturing processes","adaptive systems;distributed processing","high-assurance distributed adaptive software;dynamic systems;software certification;distributed dynamic control software;cyberphysical systems","","1","3","","","","","","IEEE","IEEE Conferences"
"Toward an Empirical Theory of Feedback-Driven Development","M. Beller","NA","2018 IEEE/ACM 40th International Conference on Software Engineering: Companion (ICSE-Companion)","","2018","","","503","505","Software developers today crave for feedback, be it from their peers or even bots in the form of code review, static analysis tools like their compiler, or the local or remote execution of their tests in the Continuous Integration (CI) environment. With the advent of social coding sites like GitHub and tight integration of CI services like Travis CI, software development practices have fundamentally changed. Despite a highly changed software engineering landscape, however, we still lack a suitable description of an individual's contemporary software development practices, that is how an individual code contribution comes to be. Existing descriptions like the v-model are either too coarse-grained to describe an individual contributor's workflow, or only regard a sub-part of the development process like Test-Driven Development. In addition, most existing models are prerather than de-scriptive. By contrast, in our thesis, we perform a series of empirical studies to describe the individual constituents of Feedback-Driven Development (FDD) and then compile the evidence into an initial theory on how modern software development works. Our thesis culminates in the finding that feedback loops are the characterizing criterion of contemporary software development. Our model is flexible enough to accommodate a broad bandwidth of contemporary workflows, despite large variances in how projects use and configure parts of FDD.","2574-1934","978-1-4503-5663-3978-1-5386-6479","","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8449638","Feedback-Driven Development (FDD)","Software;Testing;Software engineering;Static analysis;Tools;Quality assurance;Debugging","","","","","","","","","","","IEEE","IEEE Conferences"
"Sound Software Development for Engineering Simulations","D. MacIsaac; A. D. C. Chan","Faculty of Computer Science & Dept Electrical and Computer Engineering, University of New Brunswick, Fredericton, CANADA. email: dmac@unb.ca; Dept of Systems and Computer Engineering, Carleton University, Ottawa, CANADA. email: adcchan@sce.carleton.ca","2006 Canadian Conference on Electrical and Computer Engineering","","2006","","","2373","2376","Nine engineering research projects involving software development were investigated to demonstrate the need for imposing some sound and practical software engineering practices in undergraduate and graduate research environments where simulation is a common occurrence. All nine projects were monitored through a development phase, a code review and a usage phase. Errors were classified and recorded along with anecdotal observations and a usability rating. Of the nine projects investigated, all had serious errors during usage indicating that software development is problematic. Miscommunication, student inexperience, software platform quirks, and frequent reuse of insufficiently documented software and models were all factors that contributed to errors in the implemented software. Based on the observations made during this investigation, a more rigorous approach to software development is warranted","0840-7789","1-4244-0038-41-4244-0038","10.1109/CCECE.2006.277497","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4054888","Software engineering;usability;simulation","Programming;Acoustical engineering;Computational modeling;Software engineering;Usability;Computer simulation;Software design;Software standards;Standards development;Data acquisition","digital simulation;software reusability","sound software development;engineering simulation;software engineering","","","9","","","","","","IEEE","IEEE Conferences"
"Static Memory and Execution Time Analysis of Embedded Code","J. Pimentel","Kettering University","Safety-Critical Automotive Systems","","2006","","","91","97","Failure of a safety-critical application on an embedded processor can lead to severe damage or even loss of life. Here we are concerned with two kinds of failure: stack overflow, which usually leads to run-time errors that are difficult to diagnose, and failure to meet deadlines, which is catastrophical for systems with hard real-time characteristics. Classical validation methods like code review and testing with repeated measurements require a lot of effort, are expensive, and do not really help in proving the absence of such errors. AbsInt’s tools StackAnalyzer and aiT (timing analyzer) provide a solution to this problem. They use abstract interpretation as a formal method that allows to obtain statements valid for all program runs with all inputs.","","97807680971","","","https://ieeexplore.ieee.org","","","","","","","","2006","","","","","SAE",""
"An Empirical Study on the Effect of Testing on Code Quality Using Topic Models: A Case Study on Software Development Systems","T. Chen; S. W. Thomas; H. Hemmati; M. Nagappan; A. E. Hassan","Department of Computer Science and Software Engineering, Concordia University, Montreal, QC, Canada; Software Analysis and Intelligence Lab (SAIL), Queen's University, Kingston, ON, Canada; University of Calgary, Calgary, AB, Canada; University of Waterloo, Waterloo, ON, Canada; Software Analysis and Intelligence Lab (SAIL), Queen's University, Kingston, ON, Canada","IEEE Transactions on Reliability","","2017","66","3","806","824","Previous research in defect prediction has proposed approaches to determine which files require additional testing resources. However, practitioners typically create tests at a higher level of abstraction, which may span across many files. In this paper, we study software testing, especially test resource prioritization, from a different perspective. We use topic models to generate topics that provide a high-level view of a system, allowing developers to look at the test case coverage from a different angle. We propose measures of how well tested and defect prone a topic is, allowing us to discover which topics are well tested and which are defect prone. We conduct case studies on the histories of Mylyn, Eclipse, and NetBeans. We find that 34-78% of topics are shared between source code and test files, indicating that we can use topic models to study testing; well-tested topics are usually less defect prone, defect-prone topics are usually undertested; we can predict which topics are defect prone but not well tested with an average precision and recall of 75% and 77%, respectively; our approach complements traditional prediction-based approaches by saving testing and code inspection effort; and our approach is not particularly sensitive to the parameters that we use.","0018-9529;1558-1721","","10.1109/TR.2017.2699938","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7949108","Code quality;empirical study;testing;topic models","Microwave integrated circuits;Software;Measurement;Correlation;Predictive models;Software testing","program testing;software quality;source code (software)","empirical analysis;code quality testing;topic model;software development systems;defect prediction;software testing;test resource prioritization;test case coverage;Mylyn;Eclipse;NetBeans;source code;test files;defect-prone topics;precision value;recall value","","3","69","","Traditional","","","","IEEE","IEEE Journals & Magazines"
"Towards Property Driven Hardware Security","W. Hu; A. Althoff; A. Ardeshiricham; R. Kastner","NA; NA; NA; NA","2016 17th International Workshop on Microprocessor and SOC Test and Verification (MTV)","","2016","","","51","56","Secure hardware design is a challenging task due to the fact that security properties are difficult or impossible to model and subsequently verify using traditional hardware design tools. The ""state of the art"" for hardware design security relies heavily on functional verification, manual inspection, and code review to identify security vulnerabilities. This labor intensive process significantly reduces productivity while proving no guarantee that a security flaw will be identified. In this paper, we describe a property driven approach to hardware security, which allows automatic synthesis and verification of both qualitative and quantitative security properties. We address hardware security by enforcing information flow and statistical security properties. By incorporating a new security property specification language, such security properties can be specified, translated and verified using hardware design tools. We present design examples to demonstrate our property driven hardware security solution for proving isolation, detecting timing channel, eliminating hardware Trojan, and enforcing security related statistical properties.","2332-5674","978-1-4673-8924-2978-1-4673-8925","10.1109/MTV.2016.12","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7880823","","Hardware;Timing;Trojan horses;Encryption;Logic gates;Computational modeling","security","property driven hardware security;hardware design;security properties;hardware design tools;security vulnerabilities;information flow;hardware Trojan;timing channel","","2","28","","","","","","IEEE","IEEE Conferences"
"Refinement-Based Specification and Security Analysis of Separation Kernels","Y. Zhao; D. Sanán; F. Zhang; Y. Liu","Beihang Univerisity, Beijing, China; Nanyang Technological University, Singapore; Nanyang Technological University, Singapore; Nanyang Technological University, Singapore","IEEE Transactions on Dependable and Secure Computing","","2019","16","1","127","141","Assurance of information-flow security by formal methods is mandated in security certification of separation kernels. As an industrial standard for improving safety, ARINC 653 has been complied with by mainstream separation kernels. Due to the new trend of integrating safe and secure functionalities into one separation kernel, security analysis of ARINC 653 as well as a formal specification with security proofs are thus significant for the development and certification of <underline>ARINC</underline> 653 compliant <underline>S</underline>eparation <underline>K</underline>ernels (ARINC SKs). This paper presents a specification development and security analysis method for ARINC SKs based on refinement. We propose a generic security model and a stepwise refinement framework. Two levels of functional specification are developed by the refinement. A major part of separation kernel requirements in ARINC 653 are modeled, such as kernel initialization, two-level scheduling, partition and process management, and inter-partition communication. The formal specification and its security proofs are carried out in the Isabelle/HOL theorem prover. We have reviewed the source code of one industrial and two open-source ARINC SK implementations, i.e., VxWorks 653, XtratuM, and POK, in accordance with the formal specification. During the verification and code review, six security flaws, which can cause information leakage, are found in the ARINC 653 standard and the implementations.","1545-5971;1941-0018;2160-9209","","10.1109/TDSC.2017.2672983","National Research Foundation Singapore; National Cybersecurity R&D Directorate; National Cybersecurity R&D Directorate; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7862167","Separation kernels;ARINC 653;refinement;formal specification;information-flow security;common criteria;theorem proving","Security;Kernel;Standards;Scheduling;Safety;Market research;Computer science","","","","2","52","","","","","","IEEE","IEEE Journals & Magazines"
"The Role of Stability Testing in Heterogeneous Application Environment","K. Rogoz; T. Padlo","NA; NA","2008 1st International Conference on Software Testing, Verification, and Validation","","2008","","","432","439","This paper presents an approach to system stability tests performed in Motorola private radio networks (PRN) department. The stability tests are among crucial elements of the department's testing strategy, such as functional testing, regression testing and stress testing. The gravity of the subject is illustrated with an example of a serious system defect: memory leak, whicht was detected in Solaris operating system during system stability tests. The paper provides technical background essential to understand the problem, as well as emphasizes the role of the tests in the problem solving. The following approaches to memory leaks detection are discussed: code review, memory debugging and system stability tests. The article presents several guidelines on stability test implementation and mentions the crucial elements of the PRN Department testing strategy: load definition, testing period and the system monitoring method.","2159-4848","978-0-7695-3127","10.1109/ICST.2008.41","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4539571","Stability Testing;Solaris;Performance;memory leak","Stability;System testing;Leak detection;Performance evaluation;Radio network;Stress;Gravity;Operating systems;Problem-solving;Debugging","program debugging;program testing","system stability tests;Motorola Private Radio Networks Department;functional testing;regression testing;stress testing;Solaris operating system;memory debugging","","1","7","","","","","","IEEE","IEEE Conferences"
"Using Peer Review to Assess Coding Standards - A Case Study","X. Li","School of Computing and Information Technology, Unitec New Zealand, Auckland, New Zealand xli@unitec.ac.nz","Proceedings. Frontiers in Education. 36th Annual Conference","","2006","","","9","14","This paper is based on a case study on using peer review for assessment. The peer review is a code review process (CRP), which was implemented in the second semester of 2005. It was found that the students with different cultural backgrounds had different opinions on how to learn coding standards. We particularly paid attention on providing a positive environment and opportunity to facilitate the communication among the students when we designed the CRP. The results suggest that not only did the students learned coding standards much more effectively, but also many more benefits beyond were achieved. This paper describes the background of the peer review, the rationale behind its use, and details of how it was implemented. The paper also analyzes and evaluates the practice from teaching and learning perspective. The data were collected by personal observation, informal interviews and a survey with rating scale questionnaires. The evaluation is based on the strengths, weaknesses, opportunities and threats (SWOT) analysis","0190-5848;2377-634X","1-4244-0257-31-4244-0256","10.1109/FIE.2006.322572","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4117187","Assessment;case study;coding standards;peer review","Education;Cultural differences;Global communication;Code standards;Guidelines;Peer to peer computing;Information technology;Communication standards;Data analysis;Instruments","computer science education;teaching","peer review;coding standard assessment;coding standard learning;teaching;SWOT analysis","","5","13","","","","","","IEEE","IEEE Conferences"
"Cross-Project Defect Prediction For Web Application Using Naive Bayes (Case Study: Petstore Web Application)","P. A. Habibi; V. Amrizal; R. B. Bahaweres","Department of Informatics, Syarif Hidayatullah State Islamic University, Jakarta, Indonesia; Department of Informatics, Syarif Hidayatullah State Islamic University, Jakarta, Indonesia; Department of Informatics, Syarif Hidayatullah State Islamic University, Jakarta, Indonesia","2018 International Workshop on Big Data and Information Security (IWBIS)","","2018","","","13","18","Predicting defect in software is a complicated process and time-consuming. AI-Based software defect predictor can predict 75% defect in software and help developer team to detect and to fix defect module before performing unit testing/system testing by quality assurance. Some research tried to construct prediction model using other project datasets, which is called cross-project defect prediction. Nevertheless, the project should have the same software metric attribute. Recently, web application takes a crucial part in human life, for that reason assuring the quality of web application is very serious. This research will implement defect prediction on the petstore web application with other project datasets. CK OO metric is employed as the parameter. Naive bayes algorithm is an effortless and successful algorithm for predicting defect on software. The objective of this research is to apply naive bayes algorithm in cross-project defect prediction for the web application using pandas and scikit-learn. The outcome of this research is naive bayes algorithm has an good accuracy level of 72.30% - 89.30% and slightly low false alarm around by 5% - 26.67%. However, it has low precision and recall score, around 12,5% - 25% and 20%-60%. Then, naive bayes algorithm predicting more defect module on software than code review.","","978-1-5386-5525-2978-1-5386-5524-5978-1-5386-5526","10.1109/IWBIS.2018.8471701","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8471701","defect prediction;cross-project defect prediction;CK OO metric;naive bayes","Measurement;Software;Prediction algorithms;Predictive models;Software algorithms;Testing;Computer bugs","Bayes methods;learning (artificial intelligence);object-oriented programming;public domain software;software fault tolerance;software metrics;software quality;Web design","cross-project defect prediction;software metric attribute;defect module;Naive Bayes algorithm;AI-based software defect predictor;CK OO metric","","","35","","","","","","IEEE","IEEE Conferences"
"Secure integration of multiprotocol instant messenger","S. Bala; T. Wasilczyk","Institute of Mathematics and Informatics, University of Opole, Poland; Google, Mountain View, United States of America","2017 IEEE International Conference on INnovations in Intelligent SysTems and Applications (INISTA)","","2017","","","495","500","Pidgin communicator is a multiprotocol instant messenger client, developed by open source community. It was originally a third party client of AIM (AOL Instant Messenger) protocol for Linux operating system founded in 1998. At present, its main goal is to provide common interface for every protocol it supports, so the user does not need care about protocol to use or peer's IM identifier, while he just want to talk with a Bob. The work focuses mainly on security and functionality aspects like password storage strategies, integration with plugins which provide privacy of communication. This paper shares experiences has been gained during the process of developing and replacement of existing code for version of Pidgin 3.0.0. The project realizes the list of suggestions, mainly concerning security, which has been created after code review and provide some new technical solutions that can be implemented in the future versions.","","978-1-5090-5795-5978-1-5090-5796","10.1109/INISTA.2017.8001210","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8001210","instant messaging;off-the-record;password storage;libpurple library;software integration","Protocols;Libraries;Software;Servers;Instant messaging;Encryption","Linux;protocols;public domain software;security of data;social networking (online)","Pidgin communicator;multiprotocol instant messenger client;open source community;AIM;AOL instant messenger;Linux operating system;peer IM identifier;Pidgin 3.0.0","","","8","","","","","","IEEE","IEEE Conferences"
"Multi-variant Program Execution: Using Multi-core Systems to Defuse Buffer-Overflow Vulnerabilities","B. Salamat; A. Gal; T. Jackson; K. Manivannan; G. Wagner; M. Franz","NA; NA; NA; NA; NA; NA","2008 International Conference on Complex, Intelligent and Software Intensive Systems","","2008","","","843","848","While memory-safe and type-safe languages have been available for many years, the vast majority of software is still implemented in type-unsafe languages such as C/C++. Despite massive concerted efforts by software vendors such as Microsoft to eliminate buffer overflow vulnerabilities through automated and manual code review, they continue to be found and exploited. We present a novel approach that accepts the existence of overflow vulnerabilities and uses parallelism available through current and future multi-core architectures to detect vulnerabilities by monitoring the parallel execution of several slightly varying instances of the same application. During regular execution each instance performs equivalent computations. When an attacker attempts to inject an attack vector through a buffer overflow vulnerability, however, each instance reacts differently due to the variances we introduced into each instance. We describe our prototype implementation of such a parallelism-based buffer overflow detection system and demonstrate that it is capable of stopping buffer overflow vulnerabilities using actual exploit codes for the popular Apache Web server. The experimental results show that the runtime overhead of our parallel execution framework is less than 10% on average.","","978-0-7695-3109","10.1109/CISIS.2008.136","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4606777","Multi-variant execution;Multi-core Processor;variant;vulnerability;buffer-overflow","Monitoring;Buffer overflow;Benchmark testing;Hardware;Linux;Registers;Software","parallel processing;security of data;storage management","multivariant program execution;multicore system;buffer-overflow vulnerability;parallel execution;attack vector;parallelism;Apache Web server","","16","21","","","","","","IEEE","IEEE Conferences"
"Assisted Discovery of Software Vulnerabilities","N. Munaiah","NA","2018 IEEE/ACM 40th International Conference on Software Engineering: Companion (ICSE-Companion)","","2018","","","464","467","As more aspects of our daily lives rely on technology, the software that enables the technology must be secure. Developers rely on practices such as threat modeling, static and dynamic analyses, code review, and fuzz and penetration testing to engineer secure software. These practices, while effective at identifying vulnerabilities in software, are limited in their ability to describe the potential reasons for the existence of vulnerabilities. In order to overcome this limitation, researchers have proposed empirically validated metrics to identify factors that may have led to the introduction of vulnerabilities in the past. Developers must be made aware of these factors so that they can proactively consider the security implications of each line of code that they contribute. The goal of our research is to assist developers in engineering secure software by providing a technique that generates scientific, interpretable, and actionable feedback on security as the software evolves. In this paper, we provide an overview of our proposed approach to accomplish this research goal through a series of three research studies in which we (1) systematize the knowledge on vulnerability discovery metrics, (2) leverage the metrics to generate feedback on security, and (3) implement a framework for providing automatically generated feedback on security using code reviews as a medium.","2574-1934","978-1-4503-5663-3978-1-5386-6479","","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8449628","vulnerability;metrics;feedback","Measurement;Security;Software;Software engineering;Tools;Predictive models;Testing","","","","","","","","","","","IEEE","IEEE Conferences"
"File-Level Defect Prediction: Unsupervised vs. Supervised Models","M. Yan; Y. Fang; D. Lo; X. Xia; X. Zhang","NA; NA; NA; NA; NA","2017 ACM/IEEE International Symposium on Empirical Software Engineering and Measurement (ESEM)","","2017","","","344","353","Background: Software defect models can help software quality assurance teams to allocate testing or code review resources. A variety of techniques have been used to build defect prediction models, including supervised and unsupervised methods. Recently, Yang et al. [1] surprisingly find that unsupervised models can perform statistically significantly better than supervised models in effort-aware change-level defect prediction. However, little is known about relative performance of unsupervised and supervised models for effort-aware file-level defect prediction. Goal: Inspired by their work, we aim to investigate whether a similar finding holds in effort-aware file-level defect prediction. Method: We replicate Yang et al.'s study on PROMISE dataset with totally ten projects. We compare the effectiveness of unsupervised and supervised prediction models for effort-aware file-level defect prediction. Results: We find that the conclusion of Yang et al. [1] does not hold under within-project but holds under cross-project setting for file-level defect prediction. In addition, following the recommendations given by the best unsupervised model, developers needs to inspect statistically significantly more files than that of supervised models considering the same inspection effort (i.e., LOC). Conclusions: (a) Unsupervised models do not perform statistically significantly better than state-of-art supervised model under within-project setting, (b) Unsupervised models can perform statistically significantly better than state-ofart supervised model under cross-project setting, (c) We suggest that not only LOC but also number of files needed to be inspected should be considered when evaluating effort-aware filelevel defect prediction models.","","978-1-5090-4039-1978-1-5090-4040","10.1109/ESEM.2017.48","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8170121","Replication Study;Inspection Effort;Effortaware Defect Prediction","Predictive models;Software;Data models;Inspection;Measurement;Logistics;Software engineering","software quality","unsupervised prediction models;software defect models;supervised prediction models;effort-aware file-level defect prediction;effort-aware change-level defect prediction","","3","52","","","","","","IEEE","IEEE Conferences"
"Source code review systems","J. Remillard","NA","IEEE Software","","2005","22","1","74","77","Inspections are a well-established, cost-effective way to find defects. But they are not universally used. There are many reasons, including the lack of training on how to do inspections well, the need for project managers to move resources away from testing into inspections, and the large amount of paperwork that formal inspections require. Because of these problems, the software inspections program at Soluris had withered away. When the software engineering group at Soluris decided to relaunch inspection process, they did two things. First, they purchased Peer Reviews in Software by Karl Wiegers. It helped them fix inspection process by describing how to have an inspection meeting, how much to limit the length of the items under inspection, and what data to collect to justify the inspections over the long term. Second, they selected a software tool to automate our inspections process and thus eliminate the paper forms. This article compares two open source tools ugzilla and Codestriker - and three commercial tools - the CodeReview add-on for Visual Studio .Net, CodeReviewer, and ReviewPro.","0740-7459;1937-4194","","10.1109/MS.2005.20","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1377127","inspection;inspection tool;inspections process;open source tool","Control systems;Inspection;Web server;Relational databases;Linux;Web pages;Visual databases;Filling","public domain software;inspection;program debugging;project management;software metrics;software reviews;software tools","source code review systems;project management;software inspections program;software engineering;Soluris;open source software tools;Bugzilla software tool;Codestriker software tool;CodeReview add-on;Visual Studio .Net;ReviewPro","","9","","","","","","","IEEE","IEEE Journals & Magazines"
"[Title page i]","","","2015 IEEE/ACM 12th Working Conference on Mining Software Repositories","","2015","","","i","i","The following topics are dealt with: software repository mining; interaction data; app mining; code review; ecosystems; API; architecture; bugs; computer musicians; bullies; gists; licenses; deep learning; and process mining.","2160-1852;2160-1860","978-0-7695-5594","10.1109/MSR.2015.1","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7180054","","","application program interfaces;data mining;law;learning (artificial intelligence);program debugging;software engineering;source code (software)","software repository mining;interaction data;app mining;code review;ecosystems;API;architecture;bugs;computer musicians;bullies;gists;licenses;deep learning;process mining","","","","","","","","","IEEE","IEEE Conferences"
"Invited talk: How the Fundamental Assurance Question pervades certification","M. Feather","Jet Propulsion Laboratory, California Institute of Technology","2013 IEEE International Symposium on Software Reliability Engineering Workshops (ISSREW)","","2013","","","1","1","Assurance Cases are promoted as a means by which to present an argument for why a system is sufficiently dependable (alternate terms for the same concept include “Dependability Cases”, “Safety Cases” when the concern is safety, “Security Cases”, etc.). The purpose of such an argument is typically to inform a decision maker, often in the context of a key certification decision, so he/she will be better able to make that decision. Examples of such decisions include whether to deploy a system, whether to make an upgrade to an existing system, whether to advance a system to the next phase in its development. Assurance Cases are widely practiced in Europe, and are receiving growing attention in North America. For software systems in particular, an assurance-case-based approach is often contrasted to a standards-based approach, the latter being characterized as more “prescriptive” in specifying the process and techniques to be applied to sufficiently assure software. The proponents of an assurance-case-based approach point out that the need to construct a sufficiently convincing Assurance Case puts the onus on the provider of the software to present the argument for its dependability, as compared to putting the onus on the regulator to have described in advance a sufficient process to be followed by the provider in their development of software. The distinction is not as clear-cut as it might at first seem. Both approaches have the need to assess by how much the outcomes of assurance activities (e.g., testing; code review; fault tree analysis; model-checking) raise confidence in decisions made about the system. For a standards-based approach, how is it possible to determine whether the required standard practice can be relaxed or waived entirely, when an alternate approach can be substituted, when additional activities are warranted? These determinations hinge on an understanding of the role of assurance activities, and the information conveyed by their outcome. These questions will arise more often and become more urgent to answer in the evolving world mentioned in the Call for Papers. For an assurance-case-based approach the outcome of an assurance activity will be evidence located within the assurance case, which makes it easier to see the role it plays in the overall assurance argument, but the same question arises — what is its information contribution to confidence? Distilling these gives the “Fundamental Assurance Question,” namely how much do assurance activities contribute to raising decision confidence about system qualities, such as safety? These questions — and an intriguing start at answering them — will be the focus of this talk.","","978-1-4799-2552","10.1109/ISSREW.2013.6688831","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6688831","","","","","","","","","","","","","IEEE","IEEE Conferences"
